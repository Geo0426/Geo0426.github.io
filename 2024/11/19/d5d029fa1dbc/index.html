<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++基础语法与C++11特性 | Geo0426</title><meta name="author" content="Geo0426"><meta name="copyright" content="Geo0426"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++基础语法与概念编译内存段C++程序编译后的内存布局可分为 静态内存段（可执行文件中预设的段） 和 运行时动态分配的内存段。 静态内存段（在编译时确定，存储在可执行文件中）：  代码段（.text 段） 存储程序的 可执行指令（机器码），如函数体的二进制代码。该段是只读的，确保程序运行时的稳定性 数据段（.data 段） 存储 已初始化的全局变量和静态变量（包括 static 修饰的局部变量）">
<meta property="og:type" content="article">
<meta property="og:title" content="C++基础语法与C++11特性">
<meta property="og:url" content="http://geo0426.github.io/2024/11/19/d5d029fa1dbc/index.html">
<meta property="og:site_name" content="Geo0426">
<meta property="og:description" content="C++基础语法与概念编译内存段C++程序编译后的内存布局可分为 静态内存段（可执行文件中预设的段） 和 运行时动态分配的内存段。 静态内存段（在编译时确定，存储在可执行文件中）：  代码段（.text 段） 存储程序的 可执行指令（机器码），如函数体的二进制代码。该段是只读的，确保程序运行时的稳定性 数据段（.data 段） 存储 已初始化的全局变量和静态变量（包括 static 修饰的局部变量）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2024/11/21/AiMCg4r1TwkVONa.jpg">
<meta property="article:published_time" content="2024-11-19T01:46:50.000Z">
<meta property="article:modified_time" content="2025-03-28T09:31:07.864Z">
<meta property="article:author" content="Geo0426">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2024/11/21/AiMCg4r1TwkVONa.jpg"><link rel="shortcut icon" href="https://s2.loli.net/2023/08/30/QAj3H8aliFE7DYO.png"><link rel="canonical" href="http://geo0426.github.io/2024/11/19/d5d029fa1dbc/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++基础语法与C++11特性',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-28 17:31:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2025/01/04/yNRjnlPDFiXgkao.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="Geo0426"><span class="site-name">Geo0426</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">C++基础语法与C++11特性</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-19T01:46:50.000Z" title="发表于 2024-11-19 09:46:50">2024-11-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-28T09:31:07.864Z" title="更新于 2025-03-28 17:31:07">2025-03-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95%E9%A2%98/">算法题</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++基础语法与C++11特性"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="post-content" id="article-container"><h1 id="C-基础语法与概念"><a href="#C-基础语法与概念" class="headerlink" title="C++基础语法与概念"></a>C++基础语法与概念</h1><h2 id="编译内存段"><a href="#编译内存段" class="headerlink" title="编译内存段"></a>编译内存段</h2><p>C++程序编译后的内存布局可分为 <strong>静态内存段（可执行文件中预设的段）</strong> 和 <strong>运行时动态分配的内存段</strong>。</p>
<p><strong>静态内存段（在编译时确定，存储在可执行文件中）</strong>：</p>
<ul>
<li><strong>代码段（.text 段）</strong> 存储程序的 <strong>可执行指令（机器码）</strong>，如函数体的二进制代码。该段是只读的，确保程序运行时的稳定性</li>
<li><strong>数据段（.data 段）</strong> 存储 <strong>已初始化的全局变量和静态变量</strong>（包括 <code>static</code> 修饰的局部变量）。</li>
<li><strong>BSS 段（.bss 段）</strong> 存储 <strong>未初始化的全局变量和静态变量</strong>，默认初始化为零值。</li>
<li><strong>常量区（.rodata 段）</strong> 存储 <strong>只读数据</strong>，如字符串常量和 <code>const</code> 修饰的全局常量。</li>
</ul>
<p><strong>动态内存段（运行时动态分配）</strong>：</p>
<ul>
<li><strong>堆（Heap）</strong> 由程序员通过 <code>new</code>&#x2F;<code>malloc</code> 动态分配内存，需手动释放（<code>delete</code>&#x2F;<code>free</code>）。</li>
<li><strong>栈（Stack）</strong> 存储 <strong>函数调用的上下文</strong>，包括局部变量、参数、返回地址等。</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/aaec8bc5c5704d539f3073b07e9538b9.png" alt="C语言的内存分配{静态内存&amp;动态内存&amp;堆栈}_c语言内存-CSDN博客"></p>
<h2 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h2><h4 id="静态链接（Static-Linking）"><a href="#静态链接（Static-Linking）" class="headerlink" title="静态链接（Static Linking）"></a>静态链接（Static Linking）</h4><p>在静态链接中，所有用到的库代码在<strong>编译时</strong>被直接打包到最终的可执行文件中。生成的可执行文件是独立的，不依赖外部的库文件。</p>
<ul>
<li><strong>文件格式</strong>：静态库通常以 <code>.a</code>（Unix&#x2F;Linux）或 <code>.lib</code>（Windows）为后缀。</li>
<li>特点：<ul>
<li>可执行文件较大，因为它包含了所有依赖的库代码。</li>
<li>运行时不需要外部的库文件。</li>
<li>部署简单，适合小型项目或独立程序。</li>
</ul>
</li>
</ul>
<h4 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h4><p>在动态链接中，库代码在<strong>运行时</strong>被加载到内存中，而不是在编译时打包到可执行文件中。可执行文件仅包含对库的引用。</p>
<ul>
<li><strong>文件格式</strong>：动态库通常以 <code>.so</code>（Unix&#x2F;Linux）或 <code>.dll</code>（Windows）为后缀。</li>
<li>特点：<ul>
<li>可执行文件较小，因为它不包含库代码。</li>
<li>运行时需要外部的库文件。</li>
<li>适合大型项目或需要共享库的场景</li>
</ul>
</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table>
<thead>
<tr>
<th>特性</th>
<th>静态链接</th>
<th>动态链接</th>
</tr>
</thead>
<tbody><tr>
<td><strong>可执行文件大小</strong></td>
<td>较大，包含所有库代码</td>
<td>较小，仅包含对库的引用</td>
</tr>
<tr>
<td><strong>运行时依赖</strong></td>
<td>无需外部库文件</td>
<td>需要外部的动态库文件</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>较高，每个程序都包含库代码</td>
<td>较低，多个程序共享同一份库代码</td>
</tr>
<tr>
<td><strong>部署复杂性</strong></td>
<td>简单，可执行文件独立</td>
<td>复杂，需确保动态库存在且版本匹配</td>
</tr>
<tr>
<td><strong>更新库代码</strong></td>
<td><strong>需重新编译整个程序</strong></td>
<td><strong>只需替换动态库文件</strong></td>
</tr>
<tr>
<td><strong>启动速度</strong></td>
<td>较快，无需加载外部库</td>
<td>较慢，需加载动态库</td>
</tr>
</tbody></table>
<h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul>
<li><p>虚函数的实现原理基于两个核心概念：<strong>虚函数表（virtual function table, vtbl）</strong>和<strong>虚函数表指针（virtual table pointer, vptr</strong>）。</p>
</li>
<li><p>每个含有虚函数的类都会有一个虚函数表，这个表中存放着该类所有虚函数的地址。编译器会为每个对象添加一个隐藏成员，即虚表指针，它指向对应的虚函数表。当调用一个虚函数时，程序会通过对象中的虚表指针找到虚函数表，再根据虚函数在表中的偏移量找到并执行正确的函数。</p>
</li>
</ul>
<h3 id="虚函数表属于C-编译程序的哪个段？"><a href="#虚函数表属于C-编译程序的哪个段？" class="headerlink" title="虚函数表属于C++编译程序的哪个段？"></a>虚函数表属于C++编译程序的哪个段？</h3><p>常量区&#x2F;只读数据段（.rodata段），因为其内容在编译时确定且不可修改</p>
<h3 id="虚函数表与虚函数表指针"><a href="#虚函数表与虚函数表指针" class="headerlink" title="虚函数表与虚函数表指针"></a>虚函数表与虚函数表指针</h3><ol>
<li><strong>虚函数表</strong>：当类中包含至少一个虚函数时，编译器会为该类生成一个虚函数表。虚函数表是一个静态数组，存储了类的虚函数指针（即虚函数的地址）。<ul>
<li><strong>虚函数表</strong> 在<strong>编译时生成</strong>（编译时遇到虚函数），是类级别的静态数据。</li>
</ul>
</li>
<li><strong>虚函数表指针</strong>：虚函数表指针指向类的虚函数表，类的不同对象通常共用一个虚函数表指针。<ul>
<li><strong>虚函数表指针</strong> 在对象构造时初始化（<strong>构造函数</strong>），指向所属类的虚函数表。因此<strong>构造函数不能定义为虚函数</strong>，构造时创建虚函数表指针。</li>
</ul>
</li>
</ol>
<h3 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a>虚析构</h3><p>如果不将析构函数定义为虚函数，当基类指针指向子类对象时，调用析构函数会执行基类的析构函数而不是子类的（静态绑定）；如果定义为虚函数则会先调用子类的析构函数，再调用基类的析构函数。因此<strong>多态场景必须使用虚析构</strong>。</p>
<ul>
<li>虚析构函数的主要作用是<strong>避免内存泄漏</strong>。当基类指针指向子类对象时，如果基类的析构函数不是虚函数，那么在删除基类指针时，只会调用基类的析构函数，而不会调用子类的析构函数。这会导致子类的资源没有被正确释放，从而造成内存泄漏。</li>
<li>虚析构函数的原理是通过<strong>虚函数表</strong>（vtable）实现的。当一个类包含虚函数时，编译器会为该类生成一个虚函数表，表中存储了虚函数的指针。当通过基类指针调用虚函数时，会根据虚函数表找到实际要调用的函数。</li>
</ul>
<h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，它在基类中声明但不提供实现，通常<strong>用于定义接口规范</strong>。纯虚函数的声明方式是在函数声明的末尾添加<code>= 0</code>。包含纯虚函数的类被称为抽象类，这意味着它<strong>不能被实例化</strong>，而是要求派生类必须实现这些纯虚函数。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="全局变量（Global-Variables）"><a href="#全局变量（Global-Variables）" class="headerlink" title="全局变量（Global Variables）"></a>全局变量（Global Variables）</h3><h4 id="定义位置"><a href="#定义位置" class="headerlink" title="定义位置"></a>定义位置</h4><p>在所有函数和类外部声明。</p>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li><p>从声明位置开始，到整个程序结束（整个文件内有效）。</p>
</li>
<li><p>可通过<code>extern</code>关键字在其他文件中访问。</p>
</li>
</ul>
<h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>程序启动时分配内存，程序结束时释放（整个程序运行期间存在）。</p>
<h4 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h4><p>静态存储区（全局&#x2F;静态区）。</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>若未显式初始化，默认初始化为<code>0</code>（或对应类型的零值）。</li>
<li>只能使用常量表达式初始化（不能依赖运行时数据）。</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; globalVar;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="非静态局部变量（Local-Variables）"><a href="#非静态局部变量（Local-Variables）" class="headerlink" title="非静态局部变量（Local Variables）"></a>非静态局部变量（Local Variables）</h3><h4 id="定义位置-1"><a href="#定义位置-1" class="headerlink" title="定义位置"></a>定义位置</h4><p>在函数、代码块（如<code>&#123;&#125;</code>）或类成员函数内部声明。</p>
<h4 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h4><p>仅在定义的函数或代码块内部有效。</p>
<h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h4><p>进入作用域时创建，离开作用域时销毁（栈内存自动释放）。</p>
<h4 id="存储位置-1"><a href="#存储位置-1" class="headerlink" title="存储位置"></a>存储位置</h4><p>栈内存。</p>
<h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>若未显式初始化，值为随机垃圾数据（未定义行为）。</li>
<li>可用运行时数据初始化。</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">20</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    cout &lt;&lt; localVar;   <span class="comment">// 输出 20</span></span><br><span class="line">&#125; <span class="comment">// 函数结束，localVar 被销毁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; localVar; // 错误！作用域外无法访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态局部变量（Static-Local-Variables）"><a href="#静态局部变量（Static-Local-Variables）" class="headerlink" title="静态局部变量（Static Local Variables）"></a>静态局部变量（Static Local Variables）</h3><h4 id="定义位置-2"><a href="#定义位置-2" class="headerlink" title="定义位置"></a>定义位置</h4><p>在函数内部用<code>static</code>关键字声明。</p>
<h4 id="作用域-2"><a href="#作用域-2" class="headerlink" title="作用域"></a>作用域</h4><p>仅在函数内部有效（与局部变量相同）。</p>
<h4 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h4><p>程序启动时分配内存，程序结束时释放（与全局变量相同）。</p>
<h4 id="存储位置-2"><a href="#存储位置-2" class="headerlink" title="存储位置"></a>存储位置</h4><p>静态存储区。</p>
<h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>仅在第一次进入作用域时初始化一次。</li>
<li>若未显式初始化，默认初始化为<code>0</code>。</li>
</ul>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 静态局部变量</span></span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">counter</span>();  <span class="comment">// 输出 1</span></span><br><span class="line">    <span class="built_in">counter</span>();  <span class="comment">// 输出 2（保留上次的值）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>常用于保留函数调用间的状态（如计数器、单例模式）。</li>
</ul>
<h3 id="静态成员变量（Static-Member-Variables）"><a href="#静态成员变量（Static-Member-Variables）" class="headerlink" title="静态成员变量（Static Member Variables）"></a>静态成员变量（Static Member Variables）</h3><h4 id="定义位置-3"><a href="#定义位置-3" class="headerlink" title="定义位置"></a>定义位置</h4><p>在类内部用<code>static</code>关键字声明，但需在类外定义和初始化（C++17后支持类内初始化）。</p>
<h4 id="作用域-3"><a href="#作用域-3" class="headerlink" title="作用域"></a>作用域</h4><ul>
<li>属于类，所有类的对象共享同一个静态成员变量。</li>
<li>可通过类名直接访问（无需对象实例）。</li>
</ul>
<h4 id="生命周期-3"><a href="#生命周期-3" class="headerlink" title="生命周期"></a>生命周期</h4><p>程序启动时分配内存，程序结束时释放。</p>
<h4 id="存储位置-3"><a href="#存储位置-3" class="headerlink" title="存储位置"></a>存储位置</h4><p>静态存储区。</p>
<h4 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h4><ul>
<li>必须在类外显式初始化（除非是<code>const static</code>整型或枚举类型）。这是因为静态成员变量<strong>属于整个类而不是某个对象</strong>。如果在类内初始化，每个对象都会包含一个静态成员的副本，这与静态成员的设计初衷相悖。</li>
<li>初始化时不加<code>static</code>关键字。</li>
</ul>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;  <span class="comment">// 声明静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">30</span>;  <span class="comment">// 类外定义并初始化，不需要static关键字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1, obj2;</span><br><span class="line">    obj1.staticVar = <span class="number">40</span>;</span><br><span class="line">    cout &lt;&lt; obj2.staticVar;  <span class="comment">// 输出 40（所有对象共享）</span></span><br><span class="line">    cout &lt;&lt; MyClass::staticVar; <span class="comment">// 直接通过类名访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li>静态成员变量不占用对象的内存空间（属于类级别）。</li>
</ul>
<h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left">全局变量</th>
<th align="left">局部变量</th>
<th align="left">静态局部变量</th>
<th align="left">静态成员变量</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>作用域</strong></td>
<td align="left">全局</td>
<td align="left">函数&#x2F;代码块内</td>
<td align="left">函数内部</td>
<td align="left">类作用域</td>
</tr>
<tr>
<td align="left"><strong>生命周期</strong></td>
<td align="left">程序运行期</td>
<td align="left">函数执行期间</td>
<td align="left">程序运行期</td>
<td align="left">程序运行期</td>
</tr>
<tr>
<td align="left"><strong>存储位置</strong></td>
<td align="left">静态存储区</td>
<td align="left">栈内存</td>
<td align="left">静态存储区</td>
<td align="left">静态存储区</td>
</tr>
<tr>
<td align="left"><strong>初始化</strong></td>
<td align="left">默认零值</td>
<td align="left">未初始化随机值</td>
<td align="left">第一次进入作用域初始化</td>
<td align="left">类外显式初始化</td>
</tr>
<tr>
<td align="left"><strong>访问方式</strong></td>
<td align="left">直接或<code>extern</code></td>
<td align="left">函数内部</td>
<td align="left">函数内部</td>
<td align="left">类名或对象</td>
</tr>
<tr>
<td align="left"><strong>共享性</strong></td>
<td align="left">全局共享</td>
<td align="left">每次调用独立</td>
<td align="left">函数内共享</td>
<td align="left">所有对象共享</td>
</tr>
</tbody></table>
<h4 id="选择优先级"><a href="#选择优先级" class="headerlink" title="选择优先级"></a>选择优先级</h4><ol>
<li><strong>避免全局变量</strong>：优先使用局部变量或封装为类的静态成员。</li>
<li><strong>静态局部变量</strong>：用于保留函数调用间的状态（如单例模式）。</li>
<li><strong>静态成员变量</strong>：表示类的全局属性（如统计对象数量）。</li>
<li><strong>局部变量</strong>：默认选择，限制作用域以提高安全性。</li>
</ol>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">1</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticMember; <span class="comment">// 静态成员变量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> MyClass::staticMember = <span class="number">4</span>; <span class="comment">// 类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">2</span>;         <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticLocal = <span class="number">3</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local: &quot;</span> &lt;&lt; localVar </span><br><span class="line">         &lt;&lt; <span class="string">&quot;, staticLocal: &quot;</span> &lt;&lt; staticLocal </span><br><span class="line">         &lt;&lt; <span class="string">&quot;, global: &quot;</span> &lt;&lt; globalVar </span><br><span class="line">         &lt;&lt; <span class="string">&quot;, staticMember: &quot;</span> &lt;&lt; MyClass::staticMember &lt;&lt; endl;</span><br><span class="line">    localVar++;</span><br><span class="line">    staticLocal++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 输出: local: 2, staticLocal: 3, global: 1, staticMember: 4</span></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 输出: local: 2, staticLocal: 4, global: 1, staticMember: 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针本质也是一个变量，但是它存储的是另一个变量的地址，需要通过*符号来获取地址存储的值</p>
<p>因此指针作为参数传递时，与普通变量一样也会拷贝一份，当指针作为参数传递给函数时，<strong>传递的是指针的值（即地址）的副本</strong>。这意味着：</p>
<ul>
<li>函数内部会创建一个新的指针变量（副本），它的值和传入的指针相同（即指向同一个地址）。</li>
<li>函数内对指针副本的修改（如改变指向）不会影响主函数的指针。</li>
<li>函数内通过指针副本<strong>修改目标变量的值会影响</strong>主函数的目标变量。</li>
</ul>
<h3 id="alloca函数"><a href="#alloca函数" class="headerlink" title="alloca函数"></a>alloca函数</h3><p><code>alloca</code> 是一个在 C 和 C++ 中可用的函数，用于在栈上动态分配内存空间。它类似于 <code>malloc</code> 函数，但是分配的内存空间在函数返回后会自动释放，无需显式调用 <code>free</code> 函数。</p>
<p>返回类型是void *，函数本身只负责分配空间，使用时需要进行类型转换，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dynamicStackAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* dynamicArray;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    dynamicArray = (<span class="type">int</span>*)<span class="built_in">alloca</span>(size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用动态分配的栈空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        dynamicArray[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印动态分配的栈空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dynamicArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dynamicStackAllocation</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量指针与指针常量"><a href="#常量指针与指针常量" class="headerlink" title="常量指针与指针常量"></a>常量指针与指针常量</h3><ul>
<li>常量指针是<strong>不能改变</strong>指向的指针，指针本身是个常量；</li>
<li>指针常量是指向一个常量的指针，<strong>可以改变</strong>指向；</li>
</ul>
<h3 id="野指针和悬空指针"><a href="#野指针和悬空指针" class="headerlink" title="野指针和悬空指针"></a>野指针和悬空指针</h3><ul>
<li>野指针是<strong>没被初始化的指针</strong></li>
<li>悬空指针是指向<strong>被释放了的内存的指针</strong></li>
</ul>
<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>指向全局函数或静态成员函数的指针。作用域是全局或命名空间作用域，无需依赖类的实例。</p>
<h4 id="函数指针与成员函数指针对比"><a href="#函数指针与成员函数指针对比" class="headerlink" title="函数指针与成员函数指针对比"></a>函数指针与成员函数指针对比</h4><ul>
<li>函数指针的赋值可直接<strong>赋值函数名</strong>或<strong>显式取地址</strong>。</li>
<li>成员函数指针的赋值必须<strong>显式使用取地址</strong>运算符，不能隐式转换。</li>
</ul>
<p><strong>代码示例</strong>：</p>
<p><strong>赋值定义</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="comment">// 定义时与函数名无关，仅与返回类型和参数类型有关</span></span><br><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">int</span>, <span class="type">int</span>) = &amp;add; <span class="comment">// 指向全局函数</span></span><br><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">int</span>, <span class="type">int</span>) = add; <span class="comment">// 隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (A::*pmf)(<span class="type">int</span>, <span class="type">int</span>) = &amp;A::add; <span class="comment">// 指向类成员函数</span></span><br><span class="line"><span class="built_in">int</span> (A::*pmf)(<span class="type">int</span>, <span class="type">int</span>) = A::add; <span class="comment">// 隐式转换，错误❌</span></span><br></pre></td></tr></table></figure>

<p><strong>调用方式</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line">pf = add;       <span class="comment">// 隐式转换</span></span><br><span class="line">pf = &amp;add;      <span class="comment">// 显式取地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = (*pf)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 传统方式</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">pf</span>(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// 简化调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数指针</span></span><br><span class="line">pmf = &amp;A::add; <span class="comment">// 正确</span></span><br><span class="line">pmf = A::add;  <span class="comment">// 错误，无法隐式转换</span></span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">(a.*pmf)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 对象实例调用</span></span><br><span class="line">A* ptr = &amp;a;</span><br><span class="line">(ptr-&gt;*pmf)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 对象指针调用</span></span><br></pre></td></tr></table></figure>

<p><strong>特性对比</strong></p>
<table>
<thead>
<tr>
<th align="center"><strong>特性</strong></th>
<th><strong>函数指针</strong></th>
<th><strong>成员函数指针</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>作用域</strong></td>
<td>全局或静态作用域</td>
<td>类作用域，依赖对象实例</td>
</tr>
<tr>
<td align="center"><strong>声明语法</strong></td>
<td><code>int (*pf)(int, int);</code></td>
<td><code>int (A::*pmf)(int, int);</code></td>
</tr>
<tr>
<td align="center"><strong>调用方式</strong></td>
<td>直接调用 <code>pf(2, 3)</code></td>
<td>通过对象 <code>(a.*pmf)(2, 3)</code></td>
</tr>
<tr>
<td align="center"><strong>内存占用</strong></td>
<td>普通指针大小（4&#x2F;8 字节）</td>
<td>可能为双倍或三倍指针大小（8-16 字节）</td>
</tr>
<tr>
<td align="center"><strong>典型应用</strong></td>
<td>回调函数、函数表</td>
<td>类策略模式、消息处理</td>
</tr>
<tr>
<td align="center"><strong>赋值限制</strong></td>
<td>可隐式转换函数名</td>
<td>必须显式取地址 <code>&amp;A::add</code></td>
</tr>
</tbody></table>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>定义</strong></p>
<ul>
<li><p><strong>指针</strong>是一个变量，存储另一个对象的内存地址。指针可以为空（<code>nullptr</code>），也可以重新指向其他对象。</p>
</li>
<li><p><strong>引用</strong>是一个对象的别名，必须在初始化时绑定到一个对象，且不能重新绑定到其他对象。引用不能为空。</p>
</li>
</ul>
<p><strong>指针与引用的区别</strong></p>
<ul>
<li>引用必须初始化；指针不必初始化</li>
<li>引用无法重新绑定其他对象；指针可以更改指向</li>
<li>引用不能为空；指针可以指向空值</li>
<li>引用本质是别名，通常不占用额外内存；指针是变量，需要分配内存</li>
</ul>
<h2 id="union（共同体-联合体）"><a href="#union（共同体-联合体）" class="headerlink" title="union（共同体&#x2F;联合体）"></a>union（共同体&#x2F;联合体）</h2><p><strong>共同体</strong>的所有成员共享同一块内存空间，<strong>同一时间只能存储一个成员的值</strong>。共同体的大小等于最大成员的大小。</p>
<p><strong>代码示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义共同体</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;      <span class="comment">// 4字节</span></span><br><span class="line">    <span class="type">char</span> ch;      <span class="comment">// 1字节</span></span><br><span class="line">    <span class="type">double</span> value; <span class="comment">// 8字节（最大成员）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Data d;</span><br><span class="line">    d.num = <span class="number">42</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; d.num &lt;&lt; endl; <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    d.ch = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ch: &quot;</span> &lt;&lt; d.ch &lt;&lt; endl;   <span class="comment">// 输出 Z</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; d.num &lt;&lt; endl; <span class="comment">// 输出垃圾值（内存被覆盖）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共同体大小 = 最大成员的大小 = 8 字节</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of union Data: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Data) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">num: <span class="number">42</span></span><br><span class="line">ch: Z</span><br><span class="line">num: <span class="number">90</span>  <span class="comment">// 具体值取决于内存覆盖后的结果</span></span><br><span class="line">Size of <span class="keyword">union</span> <span class="title class_">Data</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>特点</strong>：</p>
<ul>
<li>成员共享内存，修改一个成员会影响其他成员。</li>
<li>适用场景：节省内存，同一时间只使用一个成员（如网络协议解析）。</li>
</ul>
<table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>结构体（Struct）</strong></th>
<th align="left"><strong>共同体（Union）</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>内存分配</strong></td>
<td align="left">成员占用独立内存，总大小为各成员之和（含对齐）</td>
<td align="left">成员共享内存，总大小为最大成员的大小</td>
</tr>
<tr>
<td align="left"><strong>成员访问</strong></td>
<td align="left">所有成员可同时访问</td>
<td align="left">同一时间只能使用一个成员</td>
</tr>
<tr>
<td align="left"><strong>内存效率</strong></td>
<td align="left">内存占用较高</td>
<td align="left">内存占用较低（仅用最大成员的空间）</td>
</tr>
<tr>
<td align="left"><strong>典型应用场景</strong></td>
<td align="left">存储多个相关数据（如坐标、学生信息）</td>
<td align="left">节省内存，类型转换（如协议解析）</td>
</tr>
</tbody></table>
<h3 id="如何判断当前系统是大端（Big-Endian）还是小端（Little-Endian）？"><a href="#如何判断当前系统是大端（Big-Endian）还是小端（Little-Endian）？" class="headerlink" title="如何判断当前系统是大端（Big-Endian）还是小端（Little-Endian）？"></a>如何判断当前系统是大端（Big-Endian）还是小端（Little-Endian）？</h3><p><strong>方法一</strong>：使用union定义一个int类型成员变量和一个char类型成员变量，利用共享内存的性质读取低地址存放值判断大小端</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLittleEndian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">char</span> byte;</span><br><span class="line">    &#125; test;</span><br><span class="line">    test.num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (test.byte == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLittleEndian</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;系统是小端（Little-Endian）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;系统是大端（Big-Endian）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：定义一个值为1多字节整数例如<code>int</code>，将它的地址从<code>int*</code>类型使用<code>reinterpret_cast&lt;char&gt;</code>转换到<code>char*</code>类型，从低地址读取第一个字节的值，如果结果是1则是小端，是0则是大端。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLittleEndian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>; <span class="comment">// 多字节整数，值为 1</span></span><br><span class="line">    <span class="type">char</span>* bytePtr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;num); <span class="comment">// 获取第一个字节的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第一个字节是 1，则是小端；否则是大端</span></span><br><span class="line">    <span class="keyword">return</span> (*bytePtr == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLittleEndian</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;系统是小端（Little-Endian）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;系统是大端（Big-Endian）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="变量声明与定义"><a href="#变量声明与定义" class="headerlink" title="变量声明与定义"></a>变量声明与定义</h2><ul>
<li>变量可以多次声明（使用 <code>extern</code>），但只能定义一次。</li>
<li>声明通常放在头文件中，定义放在源文件中。</li>
</ul>
<p>变量的声明是告诉编译器变量的存在及其类型，但<strong>不分配内存</strong>。在头文件中声明变量，以便多个源文件可以共享该变量。如果在头文件中定义变量，同时多个源文件包含了该头文件则会出现错误。</p>
<h3 id="多次定义示例"><a href="#多次定义示例" class="headerlink" title="多次定义示例"></a>多次定义示例</h3><p>**头文件 <code>example.h</code>**：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义变量（错误用法）</span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">42</span>; <span class="comment">// 在头文件中定义变量</span></span><br></pre></td></tr></table></figure>

<p>**源文件 <code>example1.cpp</code>**：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;globalVar in func1: %d\n&quot;</span>, globalVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**源文件 <code>example2.cpp</code>**：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;globalVar in func2: %d\n&quot;</span>, globalVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**主文件 <code>main.cpp</code>**：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译错误</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">multiple definition of <span class="string">&#x27;globalVar&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>：</p>
<ul>
<li>在 <code>example.h</code> 中，<code>int globalVar = 42;</code> 是变量的定义。</li>
<li>当 <code>example.h</code> 被多个源文件（<code>example1.cpp</code> 和 <code>example2.cpp</code>）包含时，<code>globalVar</code> 会被多次定义。</li>
<li>这违反了 <strong>“一次定义规则”</strong>（One Definition Rule, ODR），导致链接错误。</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>在构造函数中，编译器会在用户代码之前依次插入：</p>
<ol>
<li><p>按各虚基类的声明顺序（从左到右）调用构造函数。此步骤<strong>只有在继承链最底层（most-derived）的类会执行</strong>，而继承链中间的只需共享最底层构建的即可。</p>
</li>
<li><p>按各非虚基类的声明顺序(从左到右）调用构造函数</p>
</li>
<li><p>设置本类的<code>vptr</code>指向本类的<code>vtable</code></p>
</li>
<li><p>按各成员的声明顺序（从上到下）调用构造函数</p>
</li>
</ol>
<p>以上工作做完之后才开始真正执行用户写的构造函数代码。</p>
<h4 id="为什么虚函数表指针在成员构造之前，基类构造之后进行初始化？"><a href="#为什么虚函数表指针在成员构造之前，基类构造之后进行初始化？" class="headerlink" title="为什么虚函数表指针在成员构造之前，基类构造之后进行初始化？"></a>为什么虚函数表指针在成员构造之前，基类构造之后进行初始化？</h4><ul>
<li><code>vptr</code>的设置位置，在成员的构造之前，因为这样才能保证成员构造时以及用户代码中调用的虚函数是本类的版本。</li>
<li>同时其在各种基类的构造之后，这样才能保证基类构造时使用基类自己的虚函数版本，基类是在其自己的构造函数中设置的<code>vptr</code>的。</li>
<li><code>vptr</code>在构造过程中经过了多次的改变，从指向基类的<code>vtable</code>一直沿继承链向下到最终派生类的<code>vtable</code>。</li>
</ul>
<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><ul>
<li>如果类显式定义了拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，编译器不会自动生成默认的移动构造函数和移动赋值运算符。</li>
<li>如果定义了拷贝赋值运算符，仍然会生成默认的拷贝构造函数；如果定义了拷贝构造函数，仍然会生成默认的拷贝赋值运算符；</li>
</ul>
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>生成默认版本的条件</strong></th>
<th>C++标准</th>
</tr>
</thead>
<tbody><tr>
<td>默认构造函数</td>
<td>用户未定义任何构造函数</td>
<td>C++03</td>
</tr>
<tr>
<td>析构函数</td>
<td>用户未定义析构函数</td>
<td>C++03</td>
</tr>
<tr>
<td>拷贝构造函数</td>
<td>用户未定义拷贝构造函数、移动构造函数、移动赋值运算符或析构函数</td>
<td>C++03</td>
</tr>
<tr>
<td>拷贝赋值运算符</td>
<td>用户未定义拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数</td>
<td>C++03</td>
</tr>
<tr>
<td>移动构造函数</td>
<td>用户未定义拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数</td>
<td>C++11</td>
</tr>
<tr>
<td>移动赋值运算符</td>
<td>用户未定义拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数</td>
<td>C++11</td>
</tr>
</tbody></table>
<h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><h4 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h4><ul>
<li><strong>行为</strong>：直接复制对象的成员值（包括指针的地址），但<strong>不复制指针指向的实际内存</strong>。</li>
<li><strong>结果</strong>：两个对象的指针成员指向<strong>同一块内存地址</strong>，修改其中一个对象会影响另一个对象，且可能导致重复释放内存（崩溃）。</li>
<li><strong>默认生成的拷贝操作</strong>：如果类未显式定义拷贝构造函数或拷贝赋值运算符，编译器会生成浅拷贝版本。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shallow</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="built_in">Shallow</span>(<span class="type">int</span> val) &#123; data = <span class="keyword">new</span> <span class="built_in">int</span>(val); &#125;</span><br><span class="line">    <span class="comment">// 默认拷贝构造函数和拷贝赋值运算符是浅拷贝</span></span><br><span class="line">    ~<span class="built_in">Shallow</span>() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Shallow <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    Shallow obj2 = obj1; <span class="comment">// 浅拷贝：obj2.data 指向 obj1.data 的地址</span></span><br><span class="line">    *obj1.data = <span class="number">20</span>;     <span class="comment">// 修改 obj1.data 会影响 obj2.data</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;            <span class="comment">// 析构时，同一块内存被 delete 两次 → 崩溃！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h4><ul>
<li><strong>行为</strong>：不仅复制对象的成员值，还为指针成员<strong>重新分配内存</strong>，并复制指针指向的完整内容。</li>
<li><strong>结果</strong>：两个对象的指针成员指向<strong>不同的内存地址</strong>，彼此独立，修改互不影响。</li>
<li><strong>必须显式实现</strong>：如果类中有动态分配的资源，需手动定义拷贝构造函数和拷贝赋值运算符。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deep</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="built_in">Deep</span>(<span class="type">int</span> val) &#123; data = <span class="keyword">new</span> <span class="built_in">int</span>(val); &#125;</span><br><span class="line">    <span class="comment">// 显式定义深拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Deep</span>(<span class="type">const</span> Deep&amp; other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 重新分配内存并复制值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显式定义深拷贝赋值运算符</span></span><br><span class="line">    Deep&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Deep&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span> data;             <span class="comment">// 释放原有内存</span></span><br><span class="line">            data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 重新分配并复制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Deep</span>() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Deep <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    Deep obj2 = obj1; <span class="comment">// 深拷贝：obj2.data 指向新内存</span></span><br><span class="line">    *obj1.data = <span class="number">20</span>;  <span class="comment">// obj2.data 的值仍为 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;         <span class="comment">// 析构时各自释放自己的内存 → 无问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>默认拷贝构造是浅拷贝，只进行值的复制，包括指针值，并不重新分配内存，只适用于不含动态资源的类</li>
<li>深拷贝不仅进行值得复制，还会进行动态资源内存的重新分配，不会出现同一内存重复释放。</li>
</ul>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul>
<li>const常量在定义时必须初始化，之后无法更改</li>
<li>const形参可以接受const和非const类型的实参</li>
<li>const成员变量只能在构造函数初始化列表进行初始化，不能在类声明时初始化因为不同对象的const成员值可以不同</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 通过构造函数初始化列表初始化 const 成员变量</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>const对象只能调用const成员函数，另外const成员函数只能修改<strong>mutable</strong>修饰的变量</li>
<li><code>int const</code> 和 <code>const int</code>两种写法是等价的（推荐写法是<code>const int</code>），都表示一个常量整型，因此书写<strong>指针常量</strong>时可以有两种写法<code>int const* p</code> 或者 <code>const int* p</code></li>
<li><strong>指向常量的常量指针</strong>：<code>int const* const p</code> 和 <code>const int* const p</code></li>
</ul>
<h3 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h3><ul>
<li>顶层const修饰的变量本身是一个常量，例如常量指针；</li>
<li>底层const指修饰的变量所指对象是一个常量，例如指针常量；</li>
</ul>
<h3 id="const函数"><a href="#const函数" class="headerlink" title="const函数"></a>const函数</h3><ul>
<li><p>在C++中，<strong>成员函数const</strong>是指在成员函数声明的末尾添加<code>const</code>关键字，这表明该成员函数不会修改对象的任何成员变量（mutable除外）。这种函数通常被称为“只读”函数，因为它们不会改变对象的状态。成员函数const的使用不仅提高了代码的可读性，还增强了程序的可靠性，因为编译器会阻止这些函数修改任何成员变量。</p>
</li>
<li><p>const成员函数与对象的交互</p>
<ul>
<li><p><strong>const对象</strong>只能调用const成员函数，因为非const成员函数可能会修改对象的状态，这与const对象的定义相矛盾。</p>
</li>
<li><p><strong>非const对象</strong>可以调用任何成员函数，无论它是否是const。这是因为非const对象没有限制，它们可以被修改。</p>
</li>
</ul>
</li>
</ul>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul>
<li><p>在普通成员函数中，this是一个指向<strong>非const对象的const指针</strong>（类型为<code>Base</code>，那么this就是<code>Base* const</code>类型的指针）;</p>
</li>
<li><p>在const成员函数中，this指针是一个<strong>指向const对象的const指针</strong>（类型为<code>Base</code>，那么this就是<code>const Base* const</code>类型的指针)</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span> arg1)</span></span>;</span><br><span class="line">    <span class="comment">// 相当于 void func(Base *this, float arg1);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span> arg1)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 相当于 void func(const Base *this, float arg1);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><ul>
<li>在C++中视为一种特殊的类，默认成员是public，默认继承也是public；</li>
<li>在C语言中是没有权限控制的，C++中有权限控制；</li>
<li>C语言中声明了一个结构体之后无法直接使用普通类型的语法创建该结构体，需要添加struct关键字。C++中可以使用普通类型的创建方式创建对象。</li>
</ul>
<h3 id="如何计算成员内存偏移量？"><a href="#如何计算成员内存偏移量？" class="headerlink" title="如何计算成员内存偏移量？"></a>如何计算成员内存偏移量？</h3><p><strong>方法一</strong>：成员地址减去结构体对象地址得到内存偏移量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyStruct s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结构体对象的地址</span></span><br><span class="line">    <span class="type">uintptr_t</span> structAddress = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结构体成员的地址</span></span><br><span class="line">    <span class="type">uintptr_t</span> memberAddress = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;s.b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算偏移量</span></span><br><span class="line">    <span class="type">uintptr_t</span> offset = memberAddress - structAddress;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Offset of b in MyStruct: &quot;</span> &lt;&lt; offset &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法二</strong>：C++标准库提供了 <code>offsetof</code> 宏，专门用于计算结构体成员的偏移量，无需创建结构体实例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span>  <span class="comment">// for offsetof</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> offset = <span class="built_in">offsetof</span>(MyStruct, b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Offset of b in MyStruct: &quot;</span> &lt;&lt; offset &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数传递结构体名称与参数名称会返回偏移量</p>
<h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><table>
<thead>
<tr>
<th align="left"><strong>用法</strong></th>
<th align="left"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">静态局部变量</td>
<td align="left">生命周期延长到程序结束，作用域限于函数内部。</td>
</tr>
<tr>
<td align="left">静态全局变量</td>
<td align="left">作用域限于当前文件，其他文件无法访问。</td>
</tr>
<tr>
<td align="left">静态成员变量</td>
<td align="left">属于类本身，所有实例共享同一个变量。</td>
</tr>
<tr>
<td align="left">静态成员函数</td>
<td align="left">属于类本身，只能访问静态成员变量和静态成员函数，可以被非静态成员函数访问。</td>
</tr>
</tbody></table>
<h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul>
<li>静态成员函数<strong>不隐含this指针参数</strong>，这是它与非静态成员函数的关键区别，没有this指针因此<strong>无法访问成员变量</strong>，只能直接访问静态成员变量和其他静态成员函数。虽然可以通过对象调用静态成员函数，但这只是语法上的便利，实际上<strong>静态成员函数并不属于任何对象</strong>。</li>
<li>静态成员函数不能被修饰为const函数，因为关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。但是静态成员函数并不单独属于任何一个对象，属于类本身。</li>
<li>静态成员函数不能被修饰为virtual函数，因为虚函数的调用关系是<strong>this指针-&gt;vptr(4字节）-&gt;vtable -&gt;virtual虚函数</strong>，但是静态成员函数没有this指针</li>
</ul>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p><strong>宏定义</strong>是 C&#x2F;C++ 中的一种预处理指令，用于在编译之前对代码进行文本替换。宏定义通过 <code>#define</code> 指令实现，可以用来定义常量、简化代码、实现条件编译等功能。宏定义的本质是<strong>文本替换</strong>，它在编译之前由预处理器处理。</p>
<h3 id="与const的区别"><a href="#与const的区别" class="headerlink" title="与const的区别"></a>与const的区别</h3><table>
<thead>
<tr>
<th align="left"><strong>特性</strong></th>
<th align="left"><strong>宏定义</strong></th>
<th align="left"><strong>常量</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>类型检查</strong></td>
<td align="left">无类型检查，纯文本替换。</td>
<td align="left">有类型检查，类型安全。</td>
</tr>
<tr>
<td align="left"><strong>内存分配</strong></td>
<td align="left">无内存分配，仅替换</td>
<td align="left">有内存分配，值无法更改</td>
</tr>
<tr>
<td align="left"><strong>作用域</strong></td>
<td align="left">无作用域，全局有效（除非 <code>#undef</code>）。</td>
<td align="left">有作用域，遵循变量作用域规则。</td>
</tr>
<tr>
<td align="left"><strong>调试</strong></td>
<td align="left">无法直接查看宏的展开结果。</td>
<td align="left">可以直接查看常量的值。</td>
</tr>
<tr>
<td align="left"><strong>生效阶段</strong></td>
<td align="left">编译前预处理阶段生效</td>
<td align="left">编译时生效</td>
</tr>
<tr>
<td align="left"><strong>灵活性</strong></td>
<td align="left">可以定义带参数的宏。</td>
<td align="left">只能是固定值。</td>
</tr>
</tbody></table>
<h3 id="与inline区别"><a href="#与inline区别" class="headerlink" title="与inline区别"></a>与inline区别</h3><p><strong>内联函数</strong>是一种常用于提高程序运行效率的函数，其基本思想是在编译阶段将函数调用处用函数体替换，减少函数调用开销</p>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><code>inline</code> 函数</th>
<th>宏定义（<code>#define</code>）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>处理阶段</strong></td>
<td>编译器处理（语法检查、类型安全）</td>
<td>预处理器处理（文本替换，无语法检查）</td>
</tr>
<tr>
<td><strong>类型检查</strong></td>
<td>支持参数和返回值的类型检查</td>
<td>无类型检查（可能引发隐式错误）</td>
</tr>
<tr>
<td><strong>调试</strong></td>
<td>可调试（有函数符号）</td>
<td>无法调试（替换后代码不可见）</td>
</tr>
<tr>
<td><strong>作用域</strong></td>
<td>遵守作用域和命名空间</td>
<td>全局替换（可能引发命名冲突）</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>无副作用（参数只计算一次）</td>
<td>可能因多次展开导致副作用</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>替代简单函数，避免调用开销</td>
<td>条件编译、代码片段复用</td>
</tr>
</tbody></table>
<h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>封装</strong>是将对象的属性和方法隐藏起来，只通过公开的接口与外界进行交互。这样可以保护数据的安全性，防止外部直接访问和修改对象的内部状态。</p>
<h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul>
<li><strong>提高代码的可维护性</strong>：内部实现细节对外部隐藏，修改内部实现不会影响外部代码。</li>
<li><strong>增强数据安全性</strong>：可以通过设置私有属性和方法，控制数据的访问权限</li>
<li><strong>简化接口</strong>：对外提供简洁的接口，方便使用</li>
</ul>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><strong>继承</strong>是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的复用。</p>
<h3 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h3><ul>
<li><strong>代码复用</strong>：子类可以复用父类的代码，减少重复代码。</li>
<li><strong>逻辑层次化</strong>：通过“is-a”关系（如“狗是动物”）组织类结构，使代码更符合现实逻辑。</li>
<li><strong>支持多态</strong>：为多态的实现提供基础。</li>
</ul>
<h3 id="public-protected-private"><a href="#public-protected-private" class="headerlink" title="public &#x2F; protected &#x2F; private"></a>public &#x2F; protected &#x2F; private</h3><p>在 C++ 中，类的继承方式有三种：<strong>public 继承</strong>、<strong>protected 继承</strong> 和 <strong>private 继承</strong>。它们的核心区别在于基类（父类）成员在派生类（子类）中的访问权限变化。</p>
<p>假设基类 <code>Base</code> 包含三种访问权限的成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base public method&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protectedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base protected method&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base private method&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="三种继承方式的区别"><a href="#三种继承方式的区别" class="headerlink" title="三种继承方式的区别"></a>三种继承方式的区别</h3><h4 id="1-public-继承"><a href="#1-public-继承" class="headerlink" title="(1) public 继承"></a>(1) public 继承</h4><ul>
<li><strong>语法</strong>：<code>class Derived : public Base &#123; ... &#125;;</code></li>
<li><strong>规则</strong>：<ul>
<li>基类的 <code>public</code> 成员 → 在派生类中保持 <code>public</code>。</li>
<li>基类的 <code>protected</code> 成员 → 在派生类中保持 <code>protected</code>。</li>
<li>基类的 <code>private</code> 成员 → <strong>不可访问</strong>。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PublicDerived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicVar = <span class="number">10</span>;       <span class="comment">// ✅ 允许访问（public）</span></span><br><span class="line">        protectedVar = <span class="number">20</span>;    <span class="comment">// ✅ 允许访问（protected）</span></span><br><span class="line">        <span class="comment">// privateVar = 30;   // ❌ 不可访问（private）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PublicDerived obj;</span><br><span class="line">    obj.publicVar = <span class="number">100</span>;      <span class="comment">// ✅ 允许访问（public）</span></span><br><span class="line">    <span class="comment">// obj.protectedVar = 200; // ❌ 外部不可访问（protected）</span></span><br><span class="line">    <span class="comment">// obj.privateVar = 300;  // ❌ 不可访问（private）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-protected-继承"><a href="#2-protected-继承" class="headerlink" title="(2) protected 继承"></a>(2) protected 继承</h4><ul>
<li><strong>语法</strong>：<code>class Derived : protected Base &#123; ... &#125;;</code></li>
<li><strong>规则</strong>：<ul>
<li>基类的 <code>public</code> 成员 → 在派生类中变为 <code>protected</code>。</li>
<li>基类的 <code>protected</code> 成员 → 在派生类中保持 <code>protected</code>。</li>
<li>基类的 <code>private</code> 成员 → <strong>不可访问</strong>。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProtectedDerived</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicVar = <span class="number">10</span>;       <span class="comment">// ✅ 允许访问（protected）</span></span><br><span class="line">        protectedVar = <span class="number">20</span>;    <span class="comment">// ✅ 允许访问（protected）</span></span><br><span class="line">        <span class="comment">// privateVar = 30;   // ❌ 不可访问（private）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProtectedDerived obj;</span><br><span class="line">    <span class="comment">// obj.publicVar = 100;   // ❌ 外部不可访问（protected）</span></span><br><span class="line">    <span class="comment">// obj.protectedVar = 200;// ❌ 外部不可访问（protected）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-private-继承"><a href="#3-private-继承" class="headerlink" title="(3) private 继承"></a>(3) private 继承</h4><ul>
<li><strong>语法</strong>：<code>class Derived : private Base &#123; ... &#125;;</code></li>
<li><strong>规则</strong>：<ul>
<li>基类的 <code>public</code> 成员 → 在派生类中变为 <code>private</code>。</li>
<li>基类的 <code>protected</code> 成员 → 在派生类中变为 <code>private</code>。</li>
<li>基类的 <code>private</code> 成员 → <strong>不可访问</strong>。</li>
</ul>
</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateDerived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicVar = <span class="number">10</span>;       <span class="comment">// ✅ 允许访问（private）</span></span><br><span class="line">        protectedVar = <span class="number">20</span>;    <span class="comment">// ✅ 允许访问（private）</span></span><br><span class="line">        <span class="comment">// privateVar = 30;   // ❌ 不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PrivateDerived obj;</span><br><span class="line">    <span class="comment">// obj.publicVar = 100;   // ❌ 外部不可访问（private）</span></span><br><span class="line">    <span class="comment">// obj.protectedVar = 200;// ❌ 外部不可访问（private）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table>
<thead>
<tr>
<th align="left"><strong>继承方式</strong></th>
<th align="left">基类 <code>public</code> 成员在子类中的权限</th>
<th align="left">基类 <code>protected</code> 成员在子类中的权限</th>
<th align="left">基类 <code>private</code> 成员在子类中的权限</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>public</strong></td>
<td align="left"><code>public</code></td>
<td align="left"><code>protected</code></td>
<td align="left">不可访问</td>
</tr>
<tr>
<td align="left"><strong>protected</strong></td>
<td align="left"><code>protected</code></td>
<td align="left"><code>protected</code></td>
<td align="left">不可访问</td>
</tr>
<tr>
<td align="left"><strong>private</strong></td>
<td align="left"><code>private</code></td>
<td align="left"><code>private</code></td>
<td align="left">不可访问</td>
</tr>
</tbody></table>
<h3 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a>关键注意事项</h3><ol>
<li><strong>基类的 <code>private</code> 成员无论何种继承都不可访问</strong>。</li>
<li><strong>protected 继承和 private 继承会降低基类成员的访问权限</strong>：<ul>
<li>一般建议使用 <code>public 继承</code>（体现 “is-a” 关系）。</li>
<li><code>protected/private 继承</code> 通常用于实现细节（类似组合关系）。</li>
</ul>
</li>
<li><strong>实际开发中</strong>：<ul>
<li>若需要隐藏基类接口，优先使用组合（对象成员）而非 <code>private 继承</code>。</li>
</ul>
</li>
</ol>
<h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>某个类不希望被继承或者某个虚函数不希望被重写，可以使用final关键字，无法进行override或者继承</p>
<h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>对父类某个虚函数进行重写时用override修饰，函数名写错时会报错提示</p>
<p>如果不添加 <code>override</code>，代码仍然可以正常运行，但会失去以下好处：</p>
<ol>
<li><strong>可读性</strong>：其他开发者可能不清楚 <code>Derived::show()</code> 是否是重写父类的函数。</li>
<li><strong>安全性</strong>：如果父类的函数签名发生变化（例如参数类型改变），子类的函数不会报错，可能导致未定义行为。</li>
</ol>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多重继承的语法很简单，只需在类定义中用逗号分隔多个基类即可。例如，如果有基类A、B和C，可以这样声明派生类D：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C &#123;</span><br><span class="line"><span class="comment">// 类D新增加的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，D类以公有方式继承A类，以私有方式继承B类，以保护方式继承C类。这意味着D类可以访问A类的公有成员，但不能访问B类和C类的私有成员。</p>
<h4 id="菱形继承问题及解决方法"><a href="#菱形继承问题及解决方法" class="headerlink" title="菱形继承问题及解决方法"></a>菱形继承问题及解决方法</h4><p>菱形继承是多重继承中的一个特殊情况，其中两个派生类继承自同一个基类，然后又有一个类同时继承这两个派生类。这会导致基类的数据和方法在最终派生类中出现多次，造成资源浪费和潜在的错误。为了解决这个问题，C++提供了虚继承的概念。通过将基类声明为虚基类，可以确保在继承层次结构中只有一个基类实例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="comment">// 基类A的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="comment">// 派生类B的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="comment">// 派生类C的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="comment">// 最终派生类D的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，B和C都虚继承自A，这样在D中就只有一个A的实例。</p>
<h4 id="虚继承和虚基类"><a href="#虚继承和虚基类" class="headerlink" title="虚继承和虚基类"></a>虚继承和虚基类</h4><ul>
<li><strong>抽象类是指有纯虚函数的类，而虚基类是指被虚继承的类。</strong>编译器检查，如果发生了菱形继承，但同时两个子类都是虚继承同一个父类，则在最终的子类D中只会保留一份A对象。</li>
<li><code>D</code>对象的内存布局：<code>B</code>的<code>vbptr</code> + <code>B</code>的成员 + <code>C</code>的<code>vbptr</code> + <code>C</code>的成员 + <code>D</code>的成员 + <strong>唯一的<code>A</code>成员</strong> </li>
<li>B和C的虚基类表指针指向虚基类表，记录了 <strong>虚基类 <code>A</code> 相对于当前类实例的偏移量</strong>，B和C通过这种方式访问A</li>
<li>在构造 <code>D</code> 时，<code>A</code> 的构造函数由 <code>D</code> 直接调用（而非通过 <code>B</code> 或 <code>C</code>），确保 <code>A</code> 只初始化一次</li>
</ul>
<p>虚继承的主要影响体现在<strong>继承子类的类（D）</strong> 上，而不是直接体现在 <code>B</code> 或 <code>C</code> 上。</p>
<p>单独的B或C实例，采用与普通继承一样的方式去访问A的成员和函数。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>多态就是允许不同类的对象对同一消息或同一接口做出响应，根据对象的不同而采用不同的行为方式。</p>
<h3 id="好处-2"><a href="#好处-2" class="headerlink" title="好处"></a>好处</h3><ul>
<li><strong>接口统一</strong>：用父类指针或引用调用方法，实际执行子类重写的方法。（最重要的）</li>
<li><strong>灵活扩展</strong>：新增子类时，无需修改使用父类接口的代码。</li>
<li><strong>解耦设计</strong>：调用方只需依赖抽象接口，而非具体实现，降低模块间耦合度。</li>
</ul>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e0648f1ecdfc6d09ef77ba2f57adf80.png#pic_center" alt="继承和成员对象"></p>
<ul>
<li><p>子类<code>Derive</code>的内存实际就是在其父类的后面再添加上自己的内容,需要注意的是编译器在构造<code>Derive</code>对象时会将<code>vptr</code>指向<code>Derive</code>类的<code>vtable</code>而不是基类<code>Base</code>的，该<code>vtable</code>中存储的是<code>Derive</code>的虚函数，包括重写父类的虚函数，也包括此类新添加的虚函数（如<code>unc3</code>)</p>
</li>
<li><p>继承并不会添加新的<code>vptr</code>项，而是复用父类的<code>vptr</code>。但如果父类没有虚函数（即没有<code>vptr</code>）则会在该有虚函数的子类后面加<code>vptr</code>项。</p>
</li>
<li><p>注意到的基类<code>Base</code>和子类<code>Derive</code>的初始地址相同，这也是为什么可以使用基类指针指向子类。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Derive d;</span><br><span class="line"></span><br><span class="line">Base *p_b = &amp;d;</span><br><span class="line">p_b-&gt;<span class="built_in">func2</span>(<span class="number">1.0</span>); <span class="comment">// 编译器将其转为 (*p_b-&gt;vptr[1])(p_b, 1.0);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>此例中将<code>Derive</code>对象<code>d</code>赋值给<code>Base</code>类指针<code>p_b</code>，编译器使用该指针时就当作其是一个<code>Base</code>对象，只能访问<code>Base</code>的成员。这没关系，因为<code>Derive</code>对象的内存中前面本来就是一个完整<code>Base</code>对象，各种偏移也和真正的<code>Base</code>对象保持一样，因此这样访问是没问题的。只是无法访问<code>Derive</code>特有的成员而已。（注意到这里只适用于单继承，多继承时编译器还需要调整指针位置来保证此特性）</p>
</li>
<li><p>虽然编译器是很无脑的看到<code>Base</code>指针就认为是<code>Base</code>对象，但这里却可以实现多态特性，即调用虚函数时会调用<code>Derive</code>类的版本。前面说到在构造<code>Derive</code>对象时，会将其<code>vptr</code>指向<code>Derive</code>的<code>vtable</code>，现在虽然改为使用<code>Base</code>指针来访问了，但是其<code>vptr</code>依然存的时<code>Derive</code>的<code>vtable</code>的地址。当调用<code>func2</code>时，编译器还是无脑的转换成<code>(*p_b-&gt;vptr[1])(p_b, 1.0)</code>，这里从<code>vptr</code>便会取出<code>Derive</code>的虚函数版本。</p>
</li>
<li><p>这就是C++多态的实现原理。归根结底是虽然改变了指针的类型为基类指针，改变了对这块内存的解释方式，但是并没有改变这块内存的内容，而因此<code>vptr</code>的得以保留其子类的<code>vtable</code>地址进而调用子类的函数。</p>
</li>
</ul>
<h3 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h3><ul>
<li>在子类中，重写的函数<strong>不需要</strong>再加 <code>virtual</code> 关键字，父类的 <code>virtual</code> 属性会自动继承。即使子类不加 <code>virtual</code>，函数仍然是虚函数。</li>
<li><code>virtual</code> 关键字的作用：</li>
</ul>
<h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  <span class="comment">// 使用 virtual 关键字</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  <span class="comment">// 重写父类的 show() 函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向子类对象</span></span><br><span class="line">    basePtr-&gt;<span class="built_in">show</span>();  <span class="comment">// 调用子类的 show() 函数</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Derived class show()&quot;</span><br></pre></td></tr></table></figure>

<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul>
<li><code>virtual</code> 关键字使得 <code>show()</code> 函数成为 <strong>虚函数</strong>。</li>
<li>当基类指针指向子类对象时，调用 <code>show()</code> 会执行子类的实现（动态绑定）。</li>
<li>如果没有 <code>virtual</code>，<code>basePtr-&gt;show()</code> 会调用基类的 <code>show()</code> 函数（<strong>静态绑定</strong>）。</li>
</ul>
<h2 id="初始化与赋值"><a href="#初始化与赋值" class="headerlink" title="初始化与赋值"></a>初始化与赋值</h2><ul>
<li>如果等号 <code>=</code> 出现在对象<strong>声明</strong>中，则是初始化，调用<strong>拷贝构造函数</strong>（不是拷贝赋值运算符）。</li>
<li>如果等号 <code>=</code> 出现在对象<strong>已经声明</strong>后的语句中，则是赋值操作，调用赋值运算符函数。</li>
</ul>
<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>英文翻译是不稳定的，易变的。<code>volatile</code> 关键字用于告诉编译器，某个变量的值可能会在程序之外被修改（例如硬件寄存器或多线程共享变量），因此编译器不应优化对该变量的访问。系统总是重新从该变量所在的内存中读取它，而不是读取某个寄存器中对这个变量的备份。</p>
<h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>只用于修饰类的构造函数，被修饰过的类不能进行隐式的类型转换</p>
<h2 id="emplace和push"><a href="#emplace和push" class="headerlink" title="emplace和push"></a>emplace和push</h2><ul>
<li><code>push</code>方法需要先构造好一个对象，然后将这个对象复制或移动到容器中。</li>
<li><code>emplace</code>方法则是直接在容器内部构造对象，避免了不必要的复制或移动操作。</li>
</ul>
<h3 id="i和i"><a href="#i和i" class="headerlink" title="++i和i++"></a>++i和i++</h3><ul>
<li><p>++i的效率更高，因为i++需要创建临时对象，原对象的值进行修改后，返回临时对象的值；++i直接修改原对象的值并返回引用</p>
</li>
<li><p>i++需要调用两次拷贝构造函数与析构函数（将原对象赋给临时对象调用一次，临时对象以值传递方式返回调用一次）</p>
</li>
<li><p>++i可以作为左值，i++不能作为左值</p>
</li>
</ul>
<h2 id="new-delete和malloc-free"><a href="#new-delete和malloc-free" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free"></a>new&#x2F;delete和malloc&#x2F;free</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p><code>new</code>操作符的底层行为分为两个阶段：</p>
<ul>
<li><strong>调用<code>operator new</code>分配内存，内存大小通过sizeof获取</strong></li>
<li><strong>调用构造函数初始化对象</strong></li>
</ul>
<p><code>operator new</code>核心功能包括内存分配和异常处理，内存分配基于<code>malloc</code>实现</p>
<h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><code>delete</code>操作符的执行流程与<code>new</code>相反：</p>
<ul>
<li><strong>调用析构函数清理资源</strong>：</li>
<li><strong>调用<code>operator delete</code>释放内存</strong></li>
</ul>
<p><code>operator delete</code>核心功能包括内存释放和异常处理，内存释放基于<code>free</code>实现</p>
<p><strong><code>operator new</code>与<code>operator delete</code>的可重载性</strong>：可以全局重载，也可以类专属重载</p>
<h3 id="差异与共同点"><a href="#差异与共同点" class="headerlink" title="差异与共同点"></a>差异与共同点</h3><p><strong>类型安全</strong></p>
<ul>
<li><code>new</code> 返回与对象类型匹配的指针（如 <code>int*</code>），无需类型转换；</li>
<li><code>malloc</code> 返回 <code>void*</code>，需强制类型转换，可能导致类型错误</li>
</ul>
<p><strong>初始化和析构</strong></p>
<ul>
<li><code>new</code> 在分配内存后<strong>自动调用构造函数</strong>，<code>delete</code> 在释放内存前<strong>调用析构函数</strong>；</li>
<li><code>malloc/free</code> 仅分配和释放内存，不涉及对象的构造与析构</li>
</ul>
<p><strong>内存大小计算</strong></p>
<ul>
<li><code>new/delete</code> 根据类型自动计算所需内存（如 <code>new int</code> 分配 <code>sizeof(int)</code>）；</li>
<li><code>malloc/free</code> 需手动指定字节数（如 <code>malloc(sizeof(int))</code>）</li>
</ul>
<p><strong>分配失败行为</strong></p>
<ul>
<li><code>new</code> 失败时抛出 <code>std::bad_alloc</code> 异常，需通过 <code>try-catch</code> 处理；</li>
<li><code>malloc</code> 失败时返回 <code>NULL</code>，需显式检查返回值</li>
</ul>
<h3 id="delete和delete"><a href="#delete和delete" class="headerlink" title="delete和delete[ ]"></a>delete和delete[ ]</h3><ul>
<li><code>delete</code>用于释放通过 <code>new</code>分配的<strong>单个对象</strong>的内存。</li>
<li><code>delete[]</code>用于释放通过 <code>new[]</code> 分配的<strong>对象数组</strong>的内存。</li>
<li><code>delete[]</code> 会调用数组中 <strong>每个元素的析构函数</strong>，而 <code>delete</code> 只会调用 <strong>第一个元素的析构函数</strong>，导致其他对象的资源泄漏。</li>
</ul>
<h2 id="三种new"><a href="#三种new" class="headerlink" title="三种new"></a>三种new</h2><ol>
<li><p><code>plain new</code>即普通的new</p>
</li>
<li><p><code>nothrow new</code>，空间分配失败时不抛出异常而返回空指针的new</p>
</li>
<li><p><code>placement new</code>，在已分配的指定内存上重新构造对象或者对象数组</p>
<p><code>placement new</code>不能简单使用delete进行销毁，因为指定的内存空间可能比构造对象更大</p>
</li>
</ol>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p><code>vector</code>的底层实现是一个动态数组，它通过连续的内存块存储元素。当元素数量超过当前容量时，<code>vector</code>会自动分配更大的内存块，并将原有元素复制到新内存中</p>
<h3 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h3><p>当前容量不足以容纳新元素时，<code>vector</code>会申请一块大小为当前容量两倍的新内存，然后将原有元素复制到新内存中，最后释放旧内存 。</p>
<p><strong>为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用。</strong></p>
<h3 id="与list的区别"><a href="#与list的区别" class="headerlink" title="与list的区别"></a>与list的区别</h3><ul>
<li><code>vector</code>是基于数组的动态数组，支持快速随机访问，但在中间插入或删除元素时效率较低O(n)，因为需要移动后续元素。内存连续，缓存友好，动态扩容。</li>
<li><code>list</code>是基于双向链表的容器，插入和删除效率高，但随机访问效率低O(n)，因为需要遍历链表。内存不连续，缓存不友好，自行控制扩容。</li>
</ul>
<h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>当<code>vector</code>进行扩容或插入&#x2F;删除操作时，原有的迭代器可能会失效，因为它们指向的内存可能已经被重新分配或移动</p>
<h3 id="reserve和resize"><a href="#reserve和resize" class="headerlink" title="reserve和resize"></a>reserve和resize</h3><ul>
<li><code>reserve</code>只改变<code>vector</code>的容量（<code>capacity</code>），不改变其大小（<code>size</code>）。<code>reserve</code>的空间大小比原空间小不做任何操作。</li>
<li><code>resize</code>会改变<code>vector</code>的大小（<code>size</code>），并可能初始化新元素。<code>resize</code>的空间大小比原空间小会释放空间。</li>
</ul>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><code>deque</code>是一种双向开口的连续线性空间，允许在头部和尾部进行<code>O(1)</code>复杂度的插入和删除操作。<code>deque</code>的存储空间由多段等长的连续空间（称为缓冲区）组成，这些缓冲区在内存中并不一定是连续的。为了管理这些缓冲区，<code>deque</code>使用一个称为<code>map</code>的中央控制器。<code>map</code>是一小块连续空间，其中每个元素都是指针，指向一个缓冲区 。结构如图所示：</p>
<p><img src="http://oss.interviewguide.cn/img/202205220021322.png" alt="img"></p>
<h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><code>deque</code>的迭代器设计复杂，主要任务是维护“整体连续”的假象，并支持随机访问。迭代器包含以下四个指针：</p>
<ul>
<li>**<code>cur</code>**：指向当前元素。</li>
<li>**<code>first</code>**：指向当前缓冲区的首地址。</li>
<li>**<code>last</code>**：指向当前缓冲区的尾地址。</li>
<li>**<code>node</code>**：指向<code>map</code>中当前缓冲区的位置。</li>
</ul>
<p><strong>随机访问</strong>：<code>deque</code>通过计算元素在<code>map</code>中的位置和缓冲区中的偏移量来实现随机访问。例如，查找第<code>n</code>个元素时，首先确定它在<code>map</code>中的第几个节点，然后确定在缓冲区中的具体位置</p>
<h4 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入&#x2F;删除"></a>插入&#x2F;删除</h4><p>在头部或尾部插入元素时，<code>deque</code>会检查当前缓冲区是否有足够空间。如果空间不足，会申请新的缓冲区并链接到<code>map</code>中。</p>
<ul>
<li><p><strong>头部插入</strong>：<code>deque</code>会在头部缓冲区的当前位置（即<code>cur</code>指针指向的位置）插入新元素，并将<code>cur</code>指针向<code>first</code>指针移动&#x2F;靠近。如果头部缓冲区已满，会先申请新的缓冲区，再在新缓冲区的末尾位置插入元素。</p>
</li>
<li><p><strong>尾部插入</strong>：<code>deque</code>会在尾部缓冲区的末尾位置（即<code>cur</code>指针指向的位置）插入新元素，并将<code>cur</code>指针向<code>last</code>指针移动&#x2F;靠近。如果头部缓冲区已满，会先申请新的缓冲区，再在新缓冲区的起始位置插入元素。</p>
</li>
</ul>
<blockquote>
<p>[!Note]</p>
<p>初始化<code>deque</code>的第一块缓冲区时， <code>_M_start</code> 迭代器与<code>_M_finish</code>迭代器均指向这一块缓冲区，迭代器的<code>cur</code>指向缓冲区的中间位置，执行<code>push_front</code>时在<code>_M_start</code>迭代器的<code>cur</code>位置插入元素并将<code>cur</code>向<code>_M_start</code>迭代器的<code>first</code>靠近；执行<code>push_back</code>时在<code>_M_finish</code>迭代器的<code>cur</code>位置插入元素并将<code>cur</code>向<code>_M_finish</code>迭代器的<code>last</code>靠近</p>
</blockquote>
<h2 id="queue-stack"><a href="#queue-stack" class="headerlink" title="queue&#x2F;stack"></a>queue&#x2F;stack</h2><p>准确来说不是容器，是适配器（参考适配器模式）。源码封装了一个<code>_Sequence</code>，是一个模板参数，表示底层容器类型，默认是<code>deque</code></p>
<ul>
<li><strong>queue</strong>：<code>push()</code>封装了<code>push_back()</code>，<code>pop()</code>封装了<code>pop_front()</code></li>
<li><strong>stack</strong>：<code>push()</code>封装了<code>push_back()</code>，<code>pop()</code>封装了<code>pop_back()</code></li>
</ul>
<h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>迭代器是C++标准模板库（STL）中用于<strong>统一访问容器元素</strong>的抽象机制。它通过重载指针操作（如<code>++</code>、<code>*</code>、<code>-&gt;</code>等），为不同容器（如<code>vector</code>、<code>list</code>、<code>map</code>）提供一致的遍历接口，同时将算法（如<code>sort</code>、<code>find</code>）与容器实现解耦。</p>
<h3 id="作用-好处"><a href="#作用-好处" class="headerlink" title="作用 &#x2F; 好处"></a>作用 &#x2F; 好处</h3><ul>
<li><strong>统一访问方式</strong>：无论容器是数组（<code>vector</code>）还是链表（<code>list</code>），迭代器隐藏底层数据结构差异，提供<code>begin()</code>和<code>end()</code>接口</li>
<li><strong>算法与容器解耦</strong>：例如<code>std::find</code>可通过迭代器操作任意容器，无需关心其内部实现</li>
<li><strong>支持泛型编程</strong>：迭代器是模板编程的核心，允许编写与容器无关的代码</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol>
<li><strong>输入迭代器（Input Iterator）</strong>：只读且单向遍历（如<code>istream_iterator</code>），支持<code>++</code>和<code>*</code>操作</li>
<li><strong>输出迭代器（Output Iterator）</strong>：只写且单向遍历（如<code>ostream_iterator</code>），支持<code>++</code>和赋值操作</li>
<li><strong>前向迭代器（Forward Iterator）</strong>：可读写且单向遍历（如单向链表的迭代器），支持重复访问</li>
<li><strong>双向迭代器（Bidirectional Iterator）</strong>：可双向移动（如<code>list</code>、<code>map</code>的迭代器），支持<code>++</code>和<code>--</code></li>
<li><strong>随机访问迭代器（Random Access Iterator）</strong>：支持任意步长跳跃（如<code>vector</code>、<code>deque</code>的迭代器），允许<code>+n</code>、<code>-n</code>及下标访问<code>[index]</code></li>
</ol>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>迭代器本质是<strong>类模板</strong>，内部封装了指向容器元素的指针或句柄，并通过重载运算符实现类似指针的行为：</p>
<ul>
<li><strong>操作符重载</strong>：如<code>operator*()</code>返回元素引用，<code>operator++()</code>移动指针</li>
<li><strong>类型别名</strong>：STL迭代器通过<code>typedef</code>定义<code>value_type</code>、<code>iterator_category</code>等类型，供算法识别其特性。迭代器本身在容器类内部实现，通常是私有的，使用public别名<code>iterator</code>提供给外部访问</li>
</ul>
<h3 id="元素删除-迭代器失效"><a href="#元素删除-迭代器失效" class="headerlink" title="元素删除&#x2F;迭代器失效"></a>元素删除&#x2F;迭代器失效</h3><ul>
<li><strong>顺序容器</strong>删除了一个迭代器，该迭代器以及之后的所有迭代器均失效，因此不能使用erase(it++)的方式进行迭代器删除，但是erase(it)会返回下一个有效的迭代器，可以基于此进行遍历元素删除。</li>
<li><strong>关联容器</strong>删除迭代器只有被删除的迭代器会失效，返回值是void，可以采用erase(it++)的方式进行迭代器删除</li>
</ul>
<h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是C++11引入的一种解决内存管理问题的方式，它可以自动释放指向的对象，避免内存泄漏。</p>
<h3 id="RAII自动释放原理"><a href="#RAII自动释放原理" class="headerlink" title="RAII自动释放原理"></a>RAII自动释放原理</h3><p>智能指针类内部包含一个指向动态分配内存的指针。在构造函数中获取资源（如通过<code>new</code>分配内存），在析构函数中释放资源（如通过<code>delete</code>释放内存）。当智能指针对象超出其作用域时（如函数返回或局部变量被销毁），栈内存的管理是自动的，由编译器负责，编译器会自动调用其析构函数。</p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><h4 id="如何保证所有权唯一？"><a href="#如何保证所有权唯一？" class="headerlink" title="如何保证所有权唯一？"></a>如何保证所有权唯一？</h4><p>通过删除拷贝构造与拷贝赋值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;         <span class="comment">// 禁用拷贝构造</span></span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝赋值</span></span><br></pre></td></tr></table></figure>

<h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><h4 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h4><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Node</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">		:_pPre(<span class="literal">NULL</span>)</span><br><span class="line">		, _pNext(<span class="literal">NULL</span>)</span><br><span class="line">		, _value(value)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	~<span class="built_in">Node</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;~Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	shared_ptr&lt;Node&lt;T&gt;&gt; _pPre;</span><br><span class="line">	shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">	T _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funtest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp1</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">	shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp2</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	sp1-&gt;_pNext = sp2; <span class="comment">//sp2的引用+1</span></span><br><span class="line">	sp2-&gt;_pPre = sp1; <span class="comment">//sp1的引用+1</span></span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">Funtest</span>();</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//sp1.use_count:1</span></span><br><span class="line"><span class="comment">//sp2.use_count:1</span></span><br><span class="line"><span class="comment">//sp1.use_count:2</span></span><br><span class="line"><span class="comment">//sp2.use_count:2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>sp1</code> 和 <code>sp2</code> 的生命周期结束，<code>Node(1)</code> 和 <code>Node(2)</code> 的引用计数各减 1。</p>
</li>
<li><p><strong>最终状态</strong>：</p>
<ul>
<li><code>sp1</code> 和 <code>sp2</code> 被析构了，但是<code>Node(1)</code> 和 <code>Node(2)</code> 的内存没能被释放，因为指向<code>Node(1)</code> 和 <code>Node(2)</code> 的智能指针引用计数不为0，当<code>use_count</code>归0时，<code>shared_ptr</code>管理的对象会被销毁，其占用的内存也会被释放。</li>
<li><code>Node(1)</code> 的引用计数 &#x3D; 1（因为 <code>Node(2)</code> 的 <code>_pPre</code> 指向它）。</li>
<li><code>Node(2)</code> 的引用计数 &#x3D; 1（因为 <code>Node(1)</code> 的 <code>_pNext</code> 指向它）。</li>
</ul>
</li>
<li><p>引用计数无法归零 → 内存泄漏。</p>
</li>
<li><p><strong><code>sp1</code> 和 <code>sp2</code> 管理的是不同对象</strong>：</p>
<ul>
<li><code>sp1</code> 管理 <code>Node(1)</code>，<code>sp2</code> 管理 <code>Node(2)</code>。</li>
<li><code>sp2</code> 析构只会减少 <code>Node(2)</code> 的引用计数，与 <code>Node(1)</code> 无关。</li>
</ul>
</li>
</ul>
<p><strong>解决方案</strong>：</p>
<p>使用 <code>weak_ptr</code>（弱引用）替代其中一个 <code>shared_ptr</code>。<code>weak_ptr</code> 不会增加引用计数，从而打破循环依赖。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T&amp; value) : _value(value) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">    weak_ptr&lt;Node&lt;T&gt;&gt; _pPre; <span class="comment">// 将其中一个改为 weak_ptr</span></span><br><span class="line">    T _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funtest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp1</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">    shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp2</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    sp1-&gt;_pNext = sp2;  <span class="comment">// Node(2) 引用计数 +1 → 2</span></span><br><span class="line">    sp2-&gt;_pPre = sp1;   <span class="comment">// Node(1) 引用计数不变 → 1</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Funtest</span>();</span><br><span class="line">    <span class="comment">// 函数结束时：</span></span><br><span class="line">    <span class="comment">// 1. sp2 析构 → Node(2) 引用计数 -1 → 1</span></span><br><span class="line">    <span class="comment">// 2. sp1 析构 → Node(1) 引用计数 -1 → 0 → 调用 ~Node(1)</span></span><br><span class="line">    <span class="comment">// 3. Node(1) 析构时，其 _pNext（shared_ptr）析构 → Node(2) 引用计数 -1 → 0 → 调用 ~Node(2)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="built_in">Node</span>()</span><br><span class="line"><span class="built_in">Node</span>()</span><br><span class="line">sp1.use_count:<span class="number">1</span></span><br><span class="line">sp2.use_count:<span class="number">2</span></span><br><span class="line">~<span class="built_in">Node</span>()</span><br><span class="line">~<span class="built_in">Node</span>()</span><br></pre></td></tr></table></figure>

<ol>
<li>**将 <code>_pPre</code> 改为 <code>weak_ptr</code>**：<ul>
<li><code>weak_ptr</code> 不会增加 <code>Node(1)</code> 的引用计数。</li>
<li><code>Node(1)</code> 的引用计数始终为 1（仅由 <code>sp1</code> 持有）。</li>
</ul>
</li>
<li><strong>析构顺序</strong>：<ul>
<li><code>sp1</code> 析构 → <code>Node(1)</code> 引用计数归零 → 调用 <code>~Node(1)</code>。</li>
<li><code>Node(1)</code> 析构时，其 <code>_pNext</code>（<code>shared_ptr&lt;Node(2)&gt;</code>）析构 → <code>Node(2)</code> 引用计数减 1 → 归零 → 调用 <code>~Node(2)</code>。</li>
</ul>
</li>
</ol>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>依赖关联的 <code>shared_ptr</code>，指向 <code>shared_ptr</code> 管理的对象，但不增加引用计数。用于解决循环引用问题</p>
<h4 id="如何判断指向对象是否存活？"><a href="#如何判断指向对象是否存活？" class="headerlink" title="如何判断指向对象是否存活？"></a>如何判断指向对象是否存活？</h4><p><code>weak_ptr</code>通过其内部数据结构与<code>shared_ptr</code>的控制块（Control Block）协同工作，判断指向对象是否存活。</p>
<ol>
<li><p>通过<code>expired()</code>方法：</p>
<ul>
<li><strong>原理</strong>：检查控制块的<strong>强引用计数（<code>_Uses</code>）是否为0</strong>。若为0，表示所有<code>shared_ptr</code>已释放，对象被销毁。</li>
</ul>
</li>
<li><p>通过<code>lock()</code>方法</p>
<ul>
<li><strong>原理</strong>：尝试将<code>weak_ptr</code>提升为<code>shared_ptr</code>，若提升成功则对象存活。</li>
</ul>
</li>
</ol>
<p><strong>控制块的销毁时机</strong></p>
<ul>
<li><strong>对象销毁</strong>：当强引用计数（<code>_Uses</code>）减为0时，调用<code>_Destroy()</code>销毁被管理对象。</li>
<li><strong>控制块销毁</strong>：当弱引用计数（<code>_Weaks</code>）也减为0时，调用<code>_Delete_this()</code>销毁控制块自身</li>
</ul>
<h3 id="是否存在shared-ptr引用计数归零，内存已释放，weak-ptr仍指向该内存导致内存泄漏的情况？"><a href="#是否存在shared-ptr引用计数归零，内存已释放，weak-ptr仍指向该内存导致内存泄漏的情况？" class="headerlink" title="是否存在shared_ptr引用计数归零，内存已释放，weak_ptr仍指向该内存导致内存泄漏的情况？"></a>是否存在<code>shared_ptr</code>引用计数归零，内存已释放，<code>weak_ptr</code>仍指向该内存导致内存泄漏的情况？</h3><p>不存在，<code>weak_ptr</code>在STL的设计中无法直接访问内存，需要先通过<code>lock()</code>函数提升为<code>shared_ptr</code>才能访问该内存，<code>lock()</code>函数在强引用计数为0时会返回空的<code>shared_ptr</code>，即无法将<code>weak_ptr</code>提升为<code>shared_ptr</code>因此不会导致内存泄漏。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; weak;</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    weak = shared;</span><br><span class="line">&#125; <span class="comment">// shared 离开作用域，对象被销毁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> shared = weak.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; *shared &lt;&lt; std::endl; <span class="comment">// 不会执行，因为对象已销毁</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对象已销毁&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出：对象已销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="强制转换（cast）"><a href="#强制转换（cast）" class="headerlink" title="强制转换（cast）"></a>强制转换（cast）</h2><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p><code>dynamic_cast</code> 是一种用于处理继承体系中类型安全向下转型（downcasting）和交叉转型（cross-casting）的操作符。它依赖于<strong>运行时类型信息（RTTI, Run-Time Type Information）</strong>，能够在运行时检查对象类型是否与目标类型兼容，从而确保转换的安全性。</p>
<ol>
<li><strong>向下转型</strong>：将基类指针&#x2F;引用转换为派生类指针&#x2F;引用。</li>
<li><strong>交叉转型</strong>：在多重继承中，将指向一个基类的指针&#x2F;引用转换为另一个基类的指针&#x2F;引用。</li>
</ol>
<h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>dynamic_cast</code> 的核心机制依赖于 <strong>RTTI</strong> 和 <strong>虚函数表（vtable）</strong>。</p>
<ol>
<li><strong>RTTI 和虚函数表</strong>：</li>
</ol>
<ul>
<li><strong>RTTI 结构</strong>：每个多态类型（至少有一个虚函数的类）的虚函数表中会包含一个指向其 <code>type_info</code> 对象的指针。<code>type_info</code> 存储了类的名称和继承关系信息。</li>
<li><strong>运行时类型检查</strong>：当执行 <code>dynamic_cast</code> 时，编译器生成的代码会通过对象的 <code>type_info</code> 检查类型兼容性。</li>
</ul>
<ol start="2">
<li><strong>类型兼容性检查</strong>：</li>
</ol>
<ul>
<li><strong>单继承</strong>：直接比较目标类型的 <code>type_info</code> 是否与对象的实际类型（基类指针指向派生类，将基类指针转换为派生类指针）或其基类一致（将基类指针转换为另一个基类指针）。</li>
<li><strong>多重继承&#x2F;虚继承</strong>：需要遍历继承树，检查目标类型是否在继承路径中。如果存在多个基类子对象，可能需要调整指针偏移量。</li>
</ul>
<h4 id="RTTI应用场景"><a href="#RTTI应用场景" class="headerlink" title="RTTI应用场景"></a>RTTI应用场景</h4><ol>
<li><strong>运行时类型检查</strong>：通过 <code>typeid</code> 判断对象的实际类型，执行不同的逻辑</li>
<li><strong>安全类型转换</strong>：使用 <code>dynamic_cast</code> 在多态场景下安全地转换类型</li>
</ol>
<h4 id="向下转型行为"><a href="#向下转型行为" class="headerlink" title="向下转型行为"></a>向下转型行为</h4><p>如果检查通过，返回有效的派生类指针&#x2F;引用；否则返回 <code>nullptr</code>（指针）或抛出 <code>std::bad_cast</code> 异常（引用）。</p>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><ol>
<li><strong>安全的向下转型</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">   </span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* derived_ptr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base_ptr);  <span class="comment">// 安全转换</span></span><br></pre></td></tr></table></figure>

<p>目标类型是Derived，实际类型也是Derived，因此转换成功</p>
<ol start="2">
<li><strong>处理多重继承中的交叉转型</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base1* base1_ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2* base2_ptr = <span class="built_in">dynamic_cast</span>&lt;Base2*&gt;(base1_ptr);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>base1_ptr</code> 指向 <code>Derived</code> 对象中的 <code>Base1</code> 子对象。</li>
<li><code>dynamic_cast</code> 需要将指针从 <code>Base1</code> 子对象的位置调整到 <code>Base2</code> 子对象的起始位置。</li>
<li>这种调整是通过 RTTI 中的偏移信息实现的。</li>
</ul>
<h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p><code>static_cast</code> 是一种显式类型转换运算符，用于在<strong>编译时</strong>进行类型转换。它适用于相关类型之间的转换，依赖编译器的静态类型检查，不涉及运行时类型信息（RTTI）。</p>
<h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul>
<li>基本数据类型转换（如 <code>int</code> → <code>double</code>，<code>float</code> → <code>int</code>）。</li>
<li>类层次结构中的 <strong>上行转换</strong>（派生类指针&#x2F;引用 → 基类指针&#x2F;引用）。</li>
<li>用户自定义类型转换（通过转换构造函数或类型转换运算符）。</li>
<li>将 <code>void*</code> 转换为具体类型的指针。</li>
<li>枚举类型与整数类型之间的转换。</li>
</ul>
<h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><ul>
<li><code>static_cast</code> 在编译时完成所有类型检查，不涉及运行时开销。</li>
<li>编译器会验证源类型（<code>source</code>）和目标类型（<code>TargetType</code>）是否具有<strong>隐式转换关系</strong>或<strong>明确的转换路径</strong>。</li>
</ul>
<p>向下转换（downcasting）时，<code>dynamic_cast</code> 和 <code>static_cast</code> 编译都能正常通过：</p>
<ul>
<li><code>dynamic_cast</code> 编译器只会检查源类型和目标类型是不是多态类型（至少有一个虚函数），运行失败会返回nullptr或者抛出异常</li>
<li><code>static_cast</code>编译器只会检查源类型和目标类型之间存在某种转换关系（如继承关系）。</li>
</ul>
<h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p><code>const_cast</code>是用于移除对象的<code>const</code>或<code>volatile</code>限定符的类型转换运算符。它主要<strong>用于指针和引用的类型转换</strong>，允许修改原本被声明为<code>const</code>的变量。这种转换通常在需要对<code>const</code>对象进行写操作时使用，但必须非常小心，因为修改<code>const</code>对象是未定义行为，可能会导致程序错误。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ol>
<li><strong>编译时操作</strong></li>
</ol>
<ul>
<li><code>const_cast</code> 是一种<strong>编译时操作</strong>，不涉及运行时开销。</li>
<li>它仅仅修改编译器对类型的解释方式，而不改变对象的底层二进制表示。</li>
</ul>
<ol start="2">
<li><strong>类型检查</strong></li>
</ol>
<ul>
<li>编译器会检查源类型（<code>source</code>）和目标类型（<code>TargetType</code>）是否除了 <code>const</code> 或 <code>volatile</code> 限定符外完全相同。</li>
<li>如果类型不匹配（例如 <code>int*</code> 转换为 <code>double*</code>），编译器会报错。</li>
</ul>
<ol start="3">
<li><strong>底层实现</strong></li>
</ol>
<ul>
<li><code>const_cast</code> 不会生成额外的机器指令。</li>
<li>它只是告诉编译器：“忽略 <code>const</code> 或 <code>volatile</code> 限定符，将指针&#x2F;引用视为目标类型”。</li>
</ul>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><code>const_cast</code>不能用来修改声明为常量的数据，会产生未定义行为。但是可以用来移除指针常量和引用常量的const，用来修改非常量的值。<strong>即只能作用于底层const，不能作用于顶层const。</strong></li>
<li>当我们调用第三方库和一些API时，它们需要使用非<code>const</code>形式的数据，但我们只有<code>const</code>形式数据时候才能使用<code>const_cast</code>。</li>
</ul>
<h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><ul>
<li><strong>reinterpret_cast</strong> 是 C++ 中的一个类型转换运算符，它用于在不同类型之间进行低级转换，通常是为了对数据的二进制表示进行重新解释。这种转换不会改变原始数据的比特位，但会改变数据的类型。</li>
<li>通常可用于将地址转化为整数类型，计算地址偏移量（不做类型检查，只检查变量大小匹配）。</li>
</ul>
<h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ul>
<li><code>reinterpret_cast</code> 是一种编译时操作，不涉及运行时开销。</li>
<li>它仅仅告诉编译器：“将源类型的内存表示重新解释为目标类型”</li>
<li><code>reinterpret_cast</code> 几乎不进行类型检查。只要源类型和目标类型的大小兼容，转换就是合法的。</li>
</ul>
<h2 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h2><h3 id="类型萃取（TODO）"><a href="#类型萃取（TODO）" class="headerlink" title="类型萃取（TODO）"></a>类型萃取（TODO）</h3><p><strong>类型萃取（Type Traits）</strong> 是C++模板元编程的核心技术，用于在编译时提取或操作类型的特性（如是否可拷贝、是否有特定成员函数等）。而 <strong>迭代器萃取（Iterator Traits）</strong> 是类型萃取的一种具体应用，专门用于获取迭代器的相关类型信息（如元素类型、迭代器类别等），以支持泛型算法的统一操作</p>
<h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><ul>
<li>检查类型属性：例如判断类型是否为指针、是否可移动构造等。</li>
<li>修改类型属性：例如移除引用（<code>remove_reference&lt;T&gt;</code>）、添加常量（<code>add_const&lt;T&gt;</code>）等。</li>
<li>类型关系判断：例如判断两个类型是否相同（<code>is_same&lt;T, U&gt;</code>）</li>
</ul>
<h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左右值定义"><a href="#左右值定义" class="headerlink" title="左右值定义"></a>左右值定义</h3><ul>
<li>C++03标准，把具有标识（identity）的表达式规定为左值，不具有标识的表达式规定为右值。因而，名字、指针、引用等是左值，是命名对象，<strong>具有确定的内存地址</strong>；字面量、临时对象等为右值，右值仅在创建它的表达式中可以被访问。</li>
<li>C++11标准分成左值（lvalue），将亡值（xvalue）和纯右值(prvalue)，将右值拆分成将亡值和纯右值。在C++11，对于值的分类，要考虑标识（identity）与可移动性（movability）。<ul>
<li>左值lvalue：可以用取地址运算符&amp;获取地址的表达式。也可定义为非临时对象或非成员函数。具有标识，但不可移动。</li>
<li>将亡值（xvalue）：具有标识，并且可以移动。对应的对象接近生存期结束，但其内容尚未被移走。例如：函数返回的右值引用，static_cast&lt;T&amp;&amp;&gt;进行的左值到右值引用的转换。</li>
<li>纯右值prvalue：不具有标识，但可以移动。对应临时对象或不对应任何对象的值。</li>
</ul>
</li>
</ul>
<blockquote>
<p>[!Note]</p>
<p>具有标识的右值引用被定义为左值</p>
</blockquote>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>右值引用</strong>是C++11引入的一种新的引用类型，用于引用右值。右值引用使用<code>&amp;&amp;</code>符号声明，可以绑定到右值。右值引用的主要目的是支持<strong>移动语义</strong>，这是一种资源管理技术，允许资源从临时对象转移到另一个对象，而不是进行复制。</p>
<h3 id="介绍一下右值引用"><a href="#介绍一下右值引用" class="headerlink" title="介绍一下右值引用"></a>介绍一下右值引用</h3><p>在C++中值通常被分为左值和右值，左值是具有标识并且可以用取地址运算符获取地址的表达式或变量，右值通常是字面量、临时对象等不可重复使用的表达式。<strong>右值引用</strong>是C++11引入的一种新的引用类型，用于匹配右值，主要是为了解决资源管理效率和性能优化的问题。右值引用允许我们标记某些对象为“可以移动”，而不是只能拷贝。比如，在处理一些临时对象或者即将销毁的对象时，我们可以通过右值引用直接“转移”它们的资源，而不是复制一份，这样可以避免不必要的开销。</p>
<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>完美转发的实现依赖于<code>万能引用</code>+<code>引用折叠</code>+<code>std::forward</code>，协同实现完美转发功能</p>
<h3 id="万能引用（Universal-Reference）"><a href="#万能引用（Universal-Reference）" class="headerlink" title="万能引用（Universal Reference）"></a>万能引用（Universal Reference）</h3><p><strong>定义</strong>： 万能引用是指模板函数中形如 <code>T&amp;&amp;</code> 的参数，它既可以绑定到左值，也可以绑定到右值。其核心特性是能够根据传入参数的类型自动推导出 <code>T</code> 的类型，从而决定 <code>T&amp;&amp;</code> 是左值引用还是右值引用。</p>
<p><strong>原理</strong>：</p>
<ul>
<li>当传入左值时，<code>T</code> 被推导为 <code>T&amp;</code>，根据引用折叠规则，<code>T&amp; &amp;&amp;</code> 折叠为 <code>T&amp;</code>，即左值引用。</li>
<li>当传入右值时，<code>T</code> 被推导为 <code>T&amp;&amp;</code>，<code>T&amp;&amp; &amp;&amp;</code> 折叠为 <code>T&amp;&amp;</code>，即右值引用。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// t 可以是左值引用或右值引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(x);  <span class="comment">// x 是左值，T 推导为 int&amp;</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 10 是右值，T 推导为 int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="引用折叠（Reference-Collapsing）"><a href="#引用折叠（Reference-Collapsing）" class="headerlink" title="引用折叠（Reference Collapsing）"></a>引用折叠（Reference Collapsing）</h3><p><strong>定义</strong>： 引用折叠是C++中的一种规则，用于处理“引用的引用”情况。当模板参数推导或类型别名中产生引用的引用时，编译器会根据规则将其折叠为单一引用。</p>
<p><strong>规则</strong>：</p>
<ul>
<li><code>T&amp; &amp;</code> → <code>T&amp;</code></li>
<li><code>T&amp; &amp;&amp;</code> → <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;</code> → <code>T&amp;</code></li>
<li><code>T&amp;&amp; &amp;&amp;</code> → <code>T&amp;&amp;</code></li>
</ul>
<p><strong>原理</strong>： 引用折叠是万能引用的基础。通过引用折叠，<code>T&amp;&amp;</code> 可以根据传入参数的类型推导出正确的引用类型。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据传入参数类型，T&amp;&amp; 折叠为 T&amp; 或 T&amp;&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(x);  <span class="comment">// T 推导为 int&amp;，int&amp; &amp;&amp; 折叠为 int&amp;</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// T 推导为 int&amp;&amp;，int&amp;&amp; &amp;&amp; 折叠为 int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h3><p><strong>定义</strong>： 完美转发是指在函数模板中将参数以原始的左值或右值属性传递给另一个函数。其目的是在多层函数调用中保持参数的左值或右值特性。</p>
<p><strong>原理</strong>： 完美转发依赖于万能引用和 <code>std::forward</code> 函数。<code>std::forward</code> 根据模板参数 <code>T</code> 的类型决定是否保留参数的左值或右值属性：</p>
<ul>
<li>如果 <code>T</code> 是左值引用，<code>std::forward</code> 返回左值引用。</li>
<li>如果 <code>T</code> 是右值引用，<code>std::forward</code> 返回右值引用。</li>
</ul>
<p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数 t 完美转发给 func</span></span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Lvalue\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rvalue\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x);  <span class="comment">// 调用 func(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">10</span>); <span class="comment">// 调用 func(int&amp;&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现机制</strong>： <code>std::forward</code> 的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  _GLIBCXX_NODISCARD</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>static_cast</code>，<code>std::forward</code> 将参数 <code>t</code> 转换为正确的左值或右值引用类型 </p>
<h3 id="三者的关系"><a href="#三者的关系" class="headerlink" title="三者的关系"></a>三者的关系</h3><ul>
<li><strong>万能引用</strong>：通过 <code>T&amp;&amp;</code> 和引用折叠规则，可以同时绑定左值和右值。</li>
<li><strong>引用折叠</strong>：是万能引用的基础，用于处理引用的引用情况。</li>
<li><strong>完美转发</strong>：依赖万能引用和 <code>std::forward</code>，确保参数在传递过程中保持其原始的左值或右值属性。</li>
</ul>
<p>通过这三者的结合，C++11实现了高效的参数传递机制，避免了不必要的拷贝和移动操作</p>
<h3 id="完美转发解决的问题"><a href="#完美转发解决的问题" class="headerlink" title="完美转发解决的问题"></a>完美转发解决的问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有完美转发的包装函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(t);  <span class="comment">// 直接传递 t，丢失了右值属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x);  <span class="comment">// 传入左值，调用 process(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">10</span>); <span class="comment">// 传入右值，调用 process(int&amp;)，而不是 process(int&amp;&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述示例中，由于变量t在wrapper函数中是一个具名变量，因此尽管传入右值，类型是int&amp;&amp;，但是值类别是左值，函数重载会绑定到void process(int&amp; x)。基于此，得出一个结论：<strong>函数重载的选择值类别匹配优先级高于类型匹配</strong>。</p>
<p>使用完美转发可以解决上述问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(t));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x);  <span class="comment">// 传入左值，调用 process(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">10</span>); <span class="comment">// 传入右值，调用 process(int&amp;&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Lvalue: 10</span></span><br><span class="line"><span class="comment">// Rvalue: 10</span></span><br></pre></td></tr></table></figure>

<h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>移动构造函数是 C++11 引入的一种特殊构造函数，用于将资源（如动态内存、文件句柄等）从一个对象“移动”到另一个对象，而不是复制。它通过<strong>右值引用</strong>（<code>&amp;&amp;</code>）实现，通常用于优化性能。</p>
<h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        data = other.data;  <span class="comment">// 接管资源</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;  <span class="comment">// 将原对象的资源置为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString str2 = std::<span class="built_in">move</span>(str1);  <span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    str1.<span class="built_in">print</span>();  <span class="comment">// 输出空（资源已被移动）</span></span><br><span class="line">    str2.<span class="built_in">print</span>();  <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>std::move()</code>调用移动构造函数</p>
<h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a><strong>关键点</strong></h3><ol>
<li><p><strong>右值引用</strong>：</p>
<p>移动构造函数使用右值引用（<code>&amp;&amp;</code>）作为参数，表示可以“窃取”临时对象的资源。</p>
</li>
<li><p><strong>资源移动</strong>：</p>
<p>移动构造函数将资源从源对象（<code>other</code>）移动到当前对象，避免不必要的复制。</p>
</li>
<li><p><strong>性能优化</strong>：</p>
<p>移动构造函数通常用于管理动态内存、文件句柄等资源，避免深拷贝的开销。</p>
</li>
<li><p>**<code>noexcept</code>**：</p>
<p>移动构造函数通常标记为 <code>noexcept</code>，表示不会抛出异常，以便在标准库中优化性能。</p>
</li>
</ol>
<h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    _GLIBCXX_NODISCARD</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure>

<p>参数接受一个万能引用，使用<code>std::remove_reference</code>去除引用，使得最终参数类型变成<code>T &amp;&amp;</code>类型的右值引用，从而保证可以被移动</p>
<h3 id="移动过后的对象生命周期在什么时候结束？"><a href="#移动过后的对象生命周期在什么时候结束？" class="headerlink" title="移动过后的对象生命周期在什么时候结束？"></a>移动过后的对象生命周期在什么时候结束？</h3><p>资源被转移但是生命周期不发生改变，仍然在它原本的作用域结束时结束。</p>
<h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>委托构造函数是 C++11 引入的特性，允许一个构造函数调用同一个类中的另一个构造函数，从而避免代码重复。</p>
<h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 主构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">double</span> y) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Primary constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">MyClass</span>(x, <span class="number">0.0</span>) &#123;  <span class="comment">// 委托给主构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Delegating constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;  <span class="comment">// 调用委托构造函数</span></span><br><span class="line"></span><br><span class="line">    obj1.<span class="built_in">print</span>();  <span class="comment">// 输出 &quot;a = 10, b = 3.14&quot;</span></span><br><span class="line">    obj2.<span class="built_in">print</span>();  <span class="comment">// 输出 &quot;a = 20, b = 0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a><strong>关键点</strong></h3><ol>
<li><p><strong>代码重用</strong>：</p>
<p>委托构造函数可以调用同一个类中的其他构造函数，避免重复代码。</p>
</li>
<li><p><strong>初始化顺序</strong>：</p>
<p>委托构造函数会先调用被委托的构造函数，然后再执行自己的函数体。</p>
</li>
<li><p><strong>适用场景</strong>：</p>
<p>当一个类有多个构造函数，且某些构造函数的逻辑可以复用时，可以使用委托构造函数。</p>
</li>
</ol>
<h2 id="Lambda表达式（匿名函数对象）"><a href="#Lambda表达式（匿名函数对象）" class="headerlink" title="Lambda表达式（匿名函数对象）"></a>Lambda表达式（匿名函数对象）</h2><p>在C++中，匿名函数通常指的是Lambda表达式，它是C++11标准中引入的一种功能，允许我们定义和使用没有具体名称的函数对象。Lambda表达式的主要用途是<strong>简化代码</strong>，特别是在需要使用简短函数但不想单独定义一个函数时。Lambda表达式也使得<strong>代码更加紧凑和可读</strong>，因为它允许我们直接在代码中定义一个函数的行为，而不是在别处。Lambda表达式的基本语法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure>

<p>其中：</p>
<ul>
<li><strong>capture</strong> 是捕获列表，用于指定Lambda表达式可以访问的外部变量，以及是否通过值或引用来捕获它们。</li>
<li><strong>parameters</strong> 是参数列表，与普通函数的参数列表类似。</li>
<li><strong>mutable</strong> 关键字用于指定Lambda表达式可以修改通过值捕获的变量。</li>
<li><strong>return_type</strong> 是返回类型，如果Lambda表达式的返回类型可以自动推断，则可以省略。</li>
<li><strong>body</strong> 是Lambda表达式的函数体，包含了表达式的执行代码。</li>
</ul>
<p>Lambda表达式只能捕获父作用域的局部变量或形参，不能捕获全局变量或静态变量。捕获全局变量时编译器提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;var&#x27; cannot be captured because it does not have automatic storage duration</span><br></pre></td></tr></table></figure>

<p>捕获方式可以是值捕获（通过值传递），也可以是引用捕获（通过引用传递）。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lambda = [x]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125;; <span class="comment">// 值捕获</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lambda_ref = [&amp;x]() &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125;; <span class="comment">// 引用捕获</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在上述例子中，第一个Lambda表达式通过值捕获变量x，而第二个通过引用捕获x。值得注意的是，如果Lambda表达式被声明为mutable，那么即使是通过值捕获，Lambda表达式也可以修改捕获的变量（但不会影响外部变量本身，引用捕获会影响）。</li>
<li>这里的lambda只是Lambda表达式的别名，它依然是一个匿名类，由编译器进行转换</li>
</ul>
<h3 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h3><p>编译器实现 <strong>lambda 表达式</strong>大致分为以下几个步骤：</p>
<ol>
<li>创建 <strong>lambda匿名类</strong>，实现构造函数，使用 lambda 表达式的函数体重载 **operator()**（所以 lambda 表达式 也叫匿名函数对象）</li>
<li>创建 lambda 对象</li>
<li>通过对象调用 <strong>operator()</strong></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://geo0426.github.io">Geo0426</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://geo0426.github.io/2024/11/19/d5d029fa1dbc/">http://geo0426.github.io/2024/11/19/d5d029fa1dbc/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://geo0426.github.io" target="_blank">Geo0426</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2024/11/21/AiMCg4r1TwkVONa.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/01/04/cc49a10a70da/" title="常见聚类方法与朴素贝叶斯"><img class="cover" src="https://s2.loli.net/2025/01/04/gW4vRhYBJkV3m7H.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">常见聚类方法与朴素贝叶斯</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/09/3158dd3ea568/" title="LeetCode日常刷题总结"><img class="cover" src="https://s2.loli.net/2024/10/09/GYABsLJmzQ6PwDH.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">LeetCode日常刷题总结</div></div></a></div></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="lv-container" data-id="city" data-uid="MTAyMC81ODk0Mi8zNTQwNA=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2025/01/04/yNRjnlPDFiXgkao.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Geo0426</div><div class="author-info__description">Record daily learning</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Geo0426"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Geo0426" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:hujunchi0426@163.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">C++基础语法与概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%86%85%E5%AD%98%E6%AE%B5"><span class="toc-number">1.1.</span> <span class="toc-text">编译内存段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.</span> <span class="toc-text">静态链接与动态链接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88Static-Linking%EF%BC%89"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">静态链接（Static Linking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%EF%BC%88Dynamic-Linking%EF%BC%89"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">动态链接（Dynamic Linking）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.1.</span> <span class="toc-text">对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.</span> <span class="toc-text">虚函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%B1%9E%E4%BA%8EC-%E7%BC%96%E8%AF%91%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%93%AA%E4%B8%AA%E6%AE%B5%EF%BC%9F"><span class="toc-number">1.3.2.</span> <span class="toc-text">虚函数表属于C++编译程序的哪个段？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E4%B8%8E%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">虚函数表与虚函数表指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%9E%90%E6%9E%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">虚析构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.5.</span> <span class="toc-text">纯虚函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">1.4.</span> <span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%88Global-Variables%EF%BC%89"><span class="toc-number">1.4.1.</span> <span class="toc-text">全局变量（Global Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">定义位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">存储位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%88Local-Variables%EF%BC%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">非静态局部变量（Local Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE-1"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">定义位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-1"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE-1"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">存储位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-1"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%88Static-Local-Variables%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">静态局部变量（Static Local Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE-2"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">定义位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-2"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-2"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE-2"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">存储位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-2"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.3.7.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%EF%BC%88Static-Member-Variables%EF%BC%89"><span class="toc-number">1.4.4.</span> <span class="toc-text">静态成员变量（Static Member Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE-3"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">定义位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F-3"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-3"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE-3"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">存储位置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-3"><span class="toc-number">1.4.4.5.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">1.4.4.6.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.4.7.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">1.4.5.</span> <span class="toc-text">对比总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">选择优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.5.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#alloca%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.</span> <span class="toc-text">alloca函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E4%B8%8E%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">1.5.2.</span> <span class="toc-text">常量指针与指针常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.5.3.</span> <span class="toc-text">野指针和悬空指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.5.4.</span> <span class="toc-text">函数指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E4%B8%8E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.4.1.</span> <span class="toc-text">函数指针与成员函数指针对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#union%EF%BC%88%E5%85%B1%E5%90%8C%E4%BD%93-%E8%81%94%E5%90%88%E4%BD%93%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">union（共同体&#x2F;联合体）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A4%A7%E7%AB%AF%EF%BC%88Big-Endian%EF%BC%89%E8%BF%98%E6%98%AF%E5%B0%8F%E7%AB%AF%EF%BC%88Little-Endian%EF%BC%89%EF%BC%9F"><span class="toc-number">1.7.1.</span> <span class="toc-text">如何判断当前系统是大端（Big-Endian）还是小端（Little-Endian）？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E4%B8%8E%E5%AE%9A%E4%B9%89"><span class="toc-number">1.8.</span> <span class="toc-text">变量声明与定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E5%AE%9A%E4%B9%89%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.8.1.</span> <span class="toc-text">多次定义示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.9.1.</span> <span class="toc-text">执行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E6%8C%87%E9%92%88%E5%9C%A8%E6%88%90%E5%91%98%E6%9E%84%E9%80%A0%E4%B9%8B%E5%89%8D%EF%BC%8C%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E4%B9%8B%E5%90%8E%E8%BF%9B%E8%A1%8C%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%9F"><span class="toc-number">1.9.1.1.</span> <span class="toc-text">为什么虚函数表指针在成员构造之前，基类构造之后进行初始化？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.9.2.</span> <span class="toc-text">默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.9.3.</span> <span class="toc-text">深拷贝与浅拷贝</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%85%E6%8B%B7%E8%B4%9D%EF%BC%88Shallow-Copy%EF%BC%89"><span class="toc-number">1.9.3.1.</span> <span class="toc-text">浅拷贝（Shallow Copy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88Deep-Copy%EF%BC%89"><span class="toc-number">1.9.3.2.</span> <span class="toc-text">深拷贝（Deep Copy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.3.3.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const"><span class="toc-number">1.10.</span> <span class="toc-text">const</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E5%B1%82const%E5%92%8C%E5%BA%95%E5%B1%82const"><span class="toc-number">1.10.1.</span> <span class="toc-text">顶层const和底层const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E5%87%BD%E6%95%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">const函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#this"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">this</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct"><span class="toc-number">1.11.</span> <span class="toc-text">struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97%E6%88%90%E5%91%98%E5%86%85%E5%AD%98%E5%81%8F%E7%A7%BB%E9%87%8F%EF%BC%9F"><span class="toc-number">1.11.1.</span> <span class="toc-text">如何计算成员内存偏移量？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static"><span class="toc-number">1.12.</span> <span class="toc-text">static</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.12.1.</span> <span class="toc-text">静态成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.13.</span> <span class="toc-text">宏定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Econst%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.1.</span> <span class="toc-text">与const的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Einline%E5%8C%BA%E5%88%AB"><span class="toc-number">1.13.2.</span> <span class="toc-text">与inline区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85"><span class="toc-number">1.14.</span> <span class="toc-text">封装</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.14.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">1.14.2.</span> <span class="toc-text">好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.15.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-1"><span class="toc-number">1.15.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84-1"><span class="toc-number">1.15.2.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public-protected-private"><span class="toc-number">1.15.3.</span> <span class="toc-text">public &#x2F; protected &#x2F; private</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.4.</span> <span class="toc-text">三种继承方式的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-public-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">(1) public 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-protected-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.15.4.2.</span> <span class="toc-text">(2) protected 继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-private-%E7%BB%A7%E6%89%BF"><span class="toc-number">1.15.4.3.</span> <span class="toc-text">(3) private 继承</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94"><span class="toc-number">1.15.5.</span> <span class="toc-text">总结对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.15.6.</span> <span class="toc-text">关键注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final"><span class="toc-number">1.15.7.</span> <span class="toc-text">final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#override"><span class="toc-number">1.15.8.</span> <span class="toc-text">override</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.15.9.</span> <span class="toc-text">多继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8F%B1%E5%BD%A2%E7%BB%A7%E6%89%BF%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-number">1.15.9.1.</span> <span class="toc-text">菱形继承问题及解决方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E7%BB%A7%E6%89%BF%E5%92%8C%E8%99%9A%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.15.9.2.</span> <span class="toc-text">虚继承和虚基类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">1.16.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-2"><span class="toc-number">1.16.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84-2"><span class="toc-number">1.16.2.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">1.16.3.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#virtual"><span class="toc-number">1.16.4.</span> <span class="toc-text">virtual</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.16.4.1.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">1.16.4.2.</span> <span class="toc-text">输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">1.16.4.3.</span> <span class="toc-text">解释</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E8%B5%8B%E5%80%BC"><span class="toc-number">1.17.</span> <span class="toc-text">初始化与赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">1.18.</span> <span class="toc-text">volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explicit"><span class="toc-number">1.19.</span> <span class="toc-text">explicit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#emplace%E5%92%8Cpush"><span class="toc-number">1.20.</span> <span class="toc-text">emplace和push</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#i%E5%92%8Ci"><span class="toc-number">1.20.1.</span> <span class="toc-text">++i和i++</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-delete%E5%92%8Cmalloc-free"><span class="toc-number">1.21.</span> <span class="toc-text">new&#x2F;delete和malloc&#x2F;free</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">1.21.1.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete"><span class="toc-number">1.21.2.</span> <span class="toc-text">delete</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E5%BC%82%E4%B8%8E%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">1.21.3.</span> <span class="toc-text">差异与共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%E5%92%8Cdelete"><span class="toc-number">1.21.4.</span> <span class="toc-text">delete和delete[ ]</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8Dnew"><span class="toc-number">1.22.</span> <span class="toc-text">三种new</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#STL"><span class="toc-number">2.</span> <span class="toc-text">STL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vector"><span class="toc-number">2.1.</span> <span class="toc-text">vector</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E7%AD%96%E7%95%A5"><span class="toc-number">2.1.1.</span> <span class="toc-text">扩容策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8Elist%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.2.</span> <span class="toc-text">与list的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">2.1.3.</span> <span class="toc-text">迭代器失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reserve%E5%92%8Cresize"><span class="toc-number">2.1.4.</span> <span class="toc-text">reserve和resize</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deque"><span class="toc-number">2.2.</span> <span class="toc-text">deque</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.2.0.1.</span> <span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5-%E5%88%A0%E9%99%A4"><span class="toc-number">2.2.0.2.</span> <span class="toc-text">插入&#x2F;删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#queue-stack"><span class="toc-number">2.3.</span> <span class="toc-text">queue&#x2F;stack</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="toc-number">2.4.</span> <span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">2.4.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-%E5%A5%BD%E5%A4%84"><span class="toc-number">2.4.2.</span> <span class="toc-text">作用 &#x2F; 好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">2.4.3.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">2.4.4.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E5%88%A0%E9%99%A4-%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-number">2.4.5.</span> <span class="toc-text">元素删除&#x2F;迭代器失效</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C-11%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">3.</span> <span class="toc-text">C++11新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-number">3.1.</span> <span class="toc-text">智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RAII%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.1.</span> <span class="toc-text">RAII自动释放原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">3.1.2.</span> <span class="toc-text">unique_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%89%80%E6%9C%89%E6%9D%83%E5%94%AF%E4%B8%80%EF%BC%9F"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">如何保证所有权唯一？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr"><span class="toc-number">3.1.3.</span> <span class="toc-text">shared_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">循环引用问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr"><span class="toc-number">3.1.4.</span> <span class="toc-text">weak_ptr</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E6%8C%87%E5%90%91%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-number">3.1.4.1.</span> <span class="toc-text">如何判断指向对象是否存活？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8shared-ptr%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%BD%92%E9%9B%B6%EF%BC%8C%E5%86%85%E5%AD%98%E5%B7%B2%E9%87%8A%E6%94%BE%EF%BC%8Cweak-ptr%E4%BB%8D%E6%8C%87%E5%90%91%E8%AF%A5%E5%86%85%E5%AD%98%E5%AF%BC%E8%87%B4%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">3.1.5.</span> <span class="toc-text">是否存在shared_ptr引用计数归零，内存已释放，weak_ptr仍指向该内存导致内存泄漏的情况？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%EF%BC%88cast%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">强制转换（cast）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dynamic-cast"><span class="toc-number">3.2.1.</span> <span class="toc-text">dynamic_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RTTI%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.1.2.</span> <span class="toc-text">RTTI应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.1.3.</span> <span class="toc-text">向下转型行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.2.1.4.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-cast"><span class="toc-number">3.2.2.</span> <span class="toc-text">static_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-3"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-cast"><span class="toc-number">3.2.3.</span> <span class="toc-text">const_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reinterpret-cast"><span class="toc-number">3.2.4.</span> <span class="toc-text">reinterpret_cast</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%85%83%E7%BC%96%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">模板元编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%90%83%E5%8F%96%EF%BC%88TODO%EF%BC%89"><span class="toc-number">3.3.1.</span> <span class="toc-text">类型萃取（TODO）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8-3"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text">右值引用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A6%E5%8F%B3%E5%80%BC%E5%AE%9A%E4%B9%89"><span class="toc-number">3.4.1.</span> <span class="toc-text">左右值定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">3.4.2.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8"><span class="toc-number">3.4.3.</span> <span class="toc-text">介绍一下右值引用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91"><span class="toc-number">3.5.</span> <span class="toc-text">完美转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%87%E8%83%BD%E5%BC%95%E7%94%A8%EF%BC%88Universal-Reference%EF%BC%89"><span class="toc-number">3.5.1.</span> <span class="toc-text">万能引用（Universal Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%8A%98%E5%8F%A0%EF%BC%88Reference-Collapsing%EF%BC%89"><span class="toc-number">3.5.2.</span> <span class="toc-text">引用折叠（Reference Collapsing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-forward"><span class="toc-number">3.5.3.</span> <span class="toc-text">std::forward</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%80%85%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.4.</span> <span class="toc-text">三者的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.5.5.</span> <span class="toc-text">完美转发解决的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.6.</span> <span class="toc-text">移动构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">3.6.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9"><span class="toc-number">3.6.2.</span> <span class="toc-text">关键点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-move"><span class="toc-number">3.6.3.</span> <span class="toc-text">std::move</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8%E8%BF%87%E5%90%8E%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%BB%93%E6%9D%9F%EF%BC%9F"><span class="toc-number">3.6.4.</span> <span class="toc-text">移动过后的对象生命周期在什么时候结束？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.</span> <span class="toc-text">委托构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">3.7.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9-1"><span class="toc-number">3.7.2.</span> <span class="toc-text">关键点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">3.8.</span> <span class="toc-text">Lambda表达式（匿名函数对象）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-4"><span class="toc-number">3.8.1.</span> <span class="toc-text">实现原理</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/04/cc49a10a70da/" title="常见聚类方法与朴素贝叶斯"><img src="https://s2.loli.net/2025/01/04/gW4vRhYBJkV3m7H.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="常见聚类方法与朴素贝叶斯"/></a><div class="content"><a class="title" href="/2025/01/04/cc49a10a70da/" title="常见聚类方法与朴素贝叶斯">常见聚类方法与朴素贝叶斯</a><time datetime="2025-01-04T07:22:00.000Z" title="发表于 2025-01-04 15:22:00">2025-01-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/19/d5d029fa1dbc/" title="C++基础语法与C++11特性"><img src="https://s2.loli.net/2024/11/21/AiMCg4r1TwkVONa.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C++基础语法与C++11特性"/></a><div class="content"><a class="title" href="/2024/11/19/d5d029fa1dbc/" title="C++基础语法与C++11特性">C++基础语法与C++11特性</a><time datetime="2024-11-19T01:46:50.000Z" title="发表于 2024-11-19 09:46:50">2024-11-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/09/3158dd3ea568/" title="LeetCode日常刷题总结"><img src="https://s2.loli.net/2024/10/09/GYABsLJmzQ6PwDH.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LeetCode日常刷题总结"/></a><div class="content"><a class="title" href="/2024/10/09/3158dd3ea568/" title="LeetCode日常刷题总结">LeetCode日常刷题总结</a><time datetime="2024-10-08T16:26:43.000Z" title="发表于 2024-10-09 00:26:43">2024-10-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/06/06/439ed6e98726/" title="C#常见概念与常用语法"><img src="https://s2.loli.net/2024/08/29/RUKrfsYxPF7pbAO.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="C#常见概念与常用语法"/></a><div class="content"><a class="title" href="/2024/06/06/439ed6e98726/" title="C#常见概念与常用语法">C#常见概念与常用语法</a><time datetime="2024-06-06T14:47:50.000Z" title="发表于 2024-06-06 22:47:50">2024-06-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/11/21/bcabc54fc9a6/" title="DWA path planning algorithm"><img src="https://s2.loli.net/2024/08/29/B4xrwhDAez9ygc1.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="DWA path planning algorithm"/></a><div class="content"><a class="title" href="/2023/11/21/bcabc54fc9a6/" title="DWA path planning algorithm">DWA path planning algorithm</a><time datetime="2023-11-21T08:05:02.000Z" title="发表于 2023-11-21 16:05:02">2023-11-21</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By Geo0426</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Livere' === 'Livere' || !false) {
  if (false) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>