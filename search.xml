<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringCloud-GateWay</title>
      <link href="/2023/09/02/SpringCloud-GateWay/"/>
      <url>/2023/09/02/SpringCloud-GateWay/</url>
      
        <content type="html"><![CDATA[<h3 id="网关功能"><a href="#网关功能" class="headerlink" title="网关功能"></a>网关功能</h3><ol><li>身份认证，权限认证</li><li>服务路由，负载均衡</li><li>请求限流</li></ol><h3 id="搭建网关"><a href="#搭建网关" class="headerlink" title="搭建网关"></a>搭建网关</h3><ol><li>添加依赖，nacos服务发现以及网关的依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--网关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写路由配置以及nacos的地址</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由的id，自定义，唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址，lb是负载均衡的意思，后面跟着服务的名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路由断言，请求匹配规则，只要以user开头的就匹配</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着向网关所在端口发送请求信息，如<a href="http://localhost:10010/user/1%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0userService%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E3%80%82">http://localhost:10010/user/1，就可以得到userService服务的返回。</a></p><p>服务流程：</p><p><img src="https://s2.loli.net/2023/09/02/oTYa7EjHKGSqIVC.png" alt="image-20230902161302541"></p><h3 id="路由断言工厂"><a href="#路由断言工厂" class="headerlink" title="路由断言工厂"></a>路由断言工厂</h3><p>Spring提供了多种断言工厂，除了Path用来限制路径以外，还可以限制ip，限制时间等</p><p><img src="https://s2.loli.net/2023/09/02/z782hbNTxtBpIZS.png" alt="image-20230902162312852"></p><p>详情实例见SpringCloudGateway文档<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">路由断言工厂</a></p><h3 id="路由过滤器"><a href="#路由过滤器" class="headerlink" title="路由过滤器"></a>路由过滤器</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>对请求或者响应做加工处理，比如添加请求头</p><h4 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h4><p>客户端向网关发起请求，请求经过多层过滤器到达服务端，服务端的响应也会经过过滤器再返回给客户端</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>加入想要给请求头添加一个token</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由的id，自定义，唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 路由的目标地址，lb是负载均衡的意思，后面跟着服务的名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路由断言，请求匹配规则，只要以user开头的就匹配</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=token,</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=token,</span> <span class="string">xxx</span> <span class="comment"># 默认过滤器，会对所有请求都生效的过滤器</span></span><br></pre></td></tr></table></figure><p>SpringCloud官网提供了31种过滤器，详细可以参考<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">过滤器工厂</a></p><h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><p>定义一个类并且实现GlobalFilter接口，并且重写函数filter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取参数</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span><br><span class="line">    <span class="comment">//  获取具体参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">    <span class="comment">//  判断身份信息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(authorization)) &#123;</span><br><span class="line">      <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">    <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">    <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">    response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response.setComplete();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Order(-1)注解是过滤器的执行顺序（或者说优先级），值越小优先级越高</p><p>@Component注解将过滤器注册为一个Bean</p><p><strong>总结步骤：</strong></p><ol><li>实现GlobalFilter接口</li><li>添加@Order和@Component注解至类</li><li>编写过滤处理逻辑</li></ol><h4 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h4><p>每个过滤器都有一个order值，根据order值进行排序</p><p>GlobalFilter是由我们自定义order的值的</p><p>路由过滤器与默认过滤器的order值由spring决定，spring默认按照声明顺序从1开始递增</p><p>当order值一样时，会按照默认过滤器&gt;路由过滤器&gt;全局过滤器的顺序执行</p><h3 id="跨域处理"><a href="#跨域处理" class="headerlink" title="跨域处理"></a>跨域处理</h3><p>只需要通过spring的配置就可以对网关的跨域进行处理</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">globalcors:</span></span><br><span class="line">    <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line"><span class="attr">corsConfigurations:</span></span><br><span class="line">  <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line"><span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求，spring boot2.4以前的配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;http://localhost&quot;</span></span><br><span class="line"><span class="comment"># allowedOriginPatterns: &quot;*&quot; # spring boot2.4以后的配置  </span></span><br><span class="line"><span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#  是否允许带cookie</span></span><br><span class="line"><span class="attr">allowedMethods:</span> <span class="comment"># 跨域方法设置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">OPTIONS</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许携带的请求头信息</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">36000</span> <span class="comment"># 跨域检测的有效期,单位s</span></span><br></pre></td></tr></table></figure><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>接SpringCloud-Feign的题外话，果然有时候无法理解某个知识的时候，不妨继续学下去看看，后继拉动前驱了属于是</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> GateWay </tag>
            
            <tag> 权限认证 </tag>
            
            <tag> 服务路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Feign</title>
      <link href="/2023/09/02/SpringCloud-Feign/"/>
      <url>/2023/09/02/SpringCloud-Feign/</url>
      
        <content type="html"><![CDATA[<h3 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h3><p>由于微服务架构，无法直接请求其他服务的service，需要远程调用，因此会用到RestTemplate来做远程调用。同时我们使用Ribbon结合RestTemplate来实现使用服务名称代替ip和端口以及负载均衡。Feign则是一种更加优雅的方式，不会需要像RestTemplate一样出现url</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>首先添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后主启动类上加上@EnableFeignClients注解，就像@EnableEurekaServer注解一样</p><p>在Service接口上添加@FeignClient注解，并且指定服务的名称（注册到服务注册中心的名称），因此这里就可以实现跨服务调用，只需要实现注册其他服务的名称的接口。使用起来的整体感觉像controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Feign配置"><a href="#Feign配置" class="headerlink" title="Feign配置"></a>Feign配置</h3><p><strong>方式一：</strong>通过修改yml文件对feign进行配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  OrderService</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span></span><br></pre></td></tr></table></figure><p><strong>方式二：</strong>通过配置类和注解</p><p>创建一个configuration类，配置Logger.Level这个Bean，加在指定服务的@FeignClient(value &#x3D; “userservice”)注解中，或者加在启动类的@EnableFeignClients( defaultConfiguration &#x3D; xxxconfiguration.class )注解中。</p><h3 id="Feign性能优化"><a href="#Feign性能优化" class="headerlink" title="Feign性能优化"></a>Feign性能优化</h3><p>Feign底层默认使用的URLConnection，不支持连接池，可以通过使用Apache HttpClient来支持连接池（减少连接的创建与释放）</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>添加HttpClient依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置连接池</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 支持HttpClient的开关</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 单个路径的最大连接数</span></span><br></pre></td></tr></table></figure><h3 id="Feign-Api"><a href="#Feign-Api" class="headerlink" title="Feign-Api"></a>Feign-Api</h3><p>controller和FeignClient的重合度较高，可以通过采用定义接口，让二者都去继承这个接口，利用这种方式提供便捷。</p><p>存在的问题：紧耦合</p><p>我更偏向的方法是将FeignClient、POJO、Feign的默认配置封装到一个模块中，通过引入模块来供其他消费者使用。这样做也可以避免每个服务都要去实现一样的FeignClient，创建实体类等。</p><p>存在的问题：有的服务可能仅仅需要部分实体类和功能，有所冗余</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><p>在其他服务的pom文件中引入该feign-api的依赖，这样就可以引入本模块中未创建的实体类，实现复用</p><p>在使用过程中会出现一个问题：对FeignClient的自动装配，@Autowired只能装配项目所在包目录下的Bean，因此需要在@EnableFeignClients注解上添加clients参数。</p><p>@EnableFeignClients( clients &#x3D; {UserClient.class, OrderClent.class}, defaultConfiguration &#x3D; xxxconfiguration.class ) clients参数可以是数组</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>流程梳理：</p><ol><li>服务模块不需要实现FeignClient来实现跨服务，不需要创建其他的实体</li><li>通过创建feign-api来对服务进行封装，为其他服务的跨服务调用提供接口，同时减少了实体类重复写的情况</li></ol><h3 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h3><p>昨晚一直在思考前端到底是如何调用有多个实例的后端服务，为此去了解了一下nginx的负载均衡和反向代理。</p><p>我的纠结点在于，我目前学到的springcloud内部的负载均衡都是服务之间的调用，可以通过其他服务的名称向注册中心进行请求，然后再根据返回的服务实例列表负载均衡。那如果这个服务本身我从前端向他发起请求，又应该怎么做才能不访问固定的端口号呢？</p><p>最初想到的方法是将对这台主机的http请求，全部向nacos寻找服务名称的这种方式，当然只是我的猜想。今天查资料，貌似是通过向网关发出请求，再由网关进行路由到具体服务。就我个人而言，从设计的角度感觉非常合理，前端的请求可以通过nginx的负载均衡向不同网关实例发送，网关又可以根据url的路径向具体的服务请求，服务则又被注册到了nacos，若存在多个实例也会在openfeign中实现负载均衡。</p><p>莫名其妙就串联起来了，学完网关再看看</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Feign </tag>
            
            <tag> RestTemplate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Nacos</title>
      <link href="/2023/09/01/SpringCloud-Nacos/"/>
      <url>/2023/09/01/SpringCloud-Nacos/</url>
      
        <content type="html"><![CDATA[<h3 id="Nacos服务注册"><a href="#Nacos服务注册" class="headerlink" title="Nacos服务注册"></a>Nacos服务注册</h3><p>首先父模块的依赖控制处需要添加spring cloud alibaba</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringCloudAlibaba有关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着在服务模块的pom中添加spring-cloud-starter-alibaba-nacos-discovery依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更改配置，nacos是在springcloud配置中的</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><p>注：EnableDiscoveryClient注解现在是可选项了，只要依赖了以spring-cloud-starter-netflix为前缀的库(例如spring-cloud-starter-netflix-eureka-client)，就启用了<strong>服务注册发现</strong>功能；</p><h3 id="服务分层架构"><a href="#服务分层架构" class="headerlink" title="服务分层架构"></a>服务分层架构</h3><p>Nacos的服务按照服务-&gt;集群-&gt;实例来分层，优先调用本地集群内的实例，本地集群中实例不可用再调用其他集群的实例</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span> </span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HangZhou</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p>如果想要配置优先调用本地集群内的实例，需要修改nacos的配置，例如订单服务想要优先调用本地用户服务的实例，需要使用nacos的负载均衡策略</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 规则类的名称</span></span><br></pre></td></tr></table></figure><p>NacosRule优先选择本地集群，集群内部随机选择；当本地集群健康服务数为0时，选择跨集群访问并警告</p><h4 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h4><p>控制台可以修改实例的权重，权重越高，用户请求更多的向该实例迁移。在服务升级中，可以通过将权重比例调为0然后进行升级，之后再调成小权重进行一段时间测试，稳定后恢复权重</p><h3 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h3><p>环境隔离，对相似的服务可以进行分组，如果不同组的服务也无法相互访问。每个namespace有唯一的id，需要在配置文件中修改它的值来设置环境</p><h3 id="Nacos和Eureka的区别"><a href="#Nacos和Eureka的区别" class="headerlink" title="Nacos和Eureka的区别"></a>Nacos和Eureka的区别</h3><h4 id="健康监测"><a href="#健康监测" class="headerlink" title="健康监测"></a>健康监测</h4><p>对于服务提供者的健康状态监测，nacos将服务实例分为临时实例和非临时实例</p><p>临时实例：</p><p>和Eureka一样，使用心跳检测，如果不在服务就会主动剔除（默认情况下如果不配置，实例都是临时的）</p><p>非临时实例：</p><p>非临时实例则会由nacos主动发起询问服务实例的健康状态，并且不会将不健康的服务实例清楚，会等待恢复</p><p>创建非临时实例只需要修改discovery的值</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span> </span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HangZhou</span> <span class="comment"># 集群名称</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 是否为临时实例</span></span><br></pre></td></tr></table></figure><h4 id="服务列表"><a href="#服务列表" class="headerlink" title="服务列表"></a>服务列表</h4><p>Eureka和Nacos都会定时拉取服务列表加到缓存中，提高效率。但是Nacos还采取了消息推送的形式，当服务发生变更，会主动推送消息给消费者</p><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><h4 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h4><p>命名规则是 服务名-运行环境.yaml如userservice-dev.yaml</p><p>配置内容只设置有热更新需求的配置项，例如日期格式等；像数据库地址这种可以不放上去</p><h4 id="配置拉取"><a href="#配置拉取" class="headerlink" title="配置拉取"></a>配置拉取</h4><p>配置读取步骤：</p><p><img src="https://s2.loli.net/2023/09/01/iCF7szOZ6HVGjlS.png" alt="image-20230901202139446.png"></p><p>bootstap.yml配置的优先级较高，可以读取到nacos的地址，再读取nacos的配置文件，最后读取application.yml的配置文件</p><p>首先引入nacos-config依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos config依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着创建bootstrap.yml文件，引导配置文件，优先级高于application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 开发环境</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>三者结合发现就是在控制台创建的配置id即userservice-dev.yaml</p><p>同时，之前的application.yml中的重复配置可以删除了，如服务名称和nacos地址</p><h4 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h4><p>前置知识：</p><p>使用@Value(“${pattern.dateformat}”)注解可以获取配置项</p><p>@ConfigurationProperties(prefix &#x3D; “xxx”) 约定大于配置，只要prefix前缀xxx与变量名进行拼接与配置一致，就可以注入</p><p>方法一：在Value注解所在类上加一个注解@RefreshScope，可以实现配置热更新，无需重启服务</p><p>方法二：使用@ConfigurationProperties(prefix &#x3D; “xxx”)注解，</p><h3 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h3><p>浪费了近一个小时时间在处理依赖和配置的问题上。这里属于是对dependencymanagement不熟悉了。</p><p>使用dependencyManagement可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。</p><p>误解：以为在父模块中定义dependencyManagement之后，子模块就可以继承下来，但是在maven中发现子模块中并没有继承下来依赖。实际上是子模块中依然需要添加相关依赖但是不用加版本号。</p><p>解决方法：想要实现我的需求只需要将父模块的依赖标签dependencyManagement删除，仅使用dependencies即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mysql --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--web起步依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Ribbon</title>
      <link href="/2023/08/30/SpringCloud-Ribbon/"/>
      <url>/2023/08/30/SpringCloud-Ribbon/</url>
      
        <content type="html"><![CDATA[<h3 id="Ribbon负载均衡流程"><a href="#Ribbon负载均衡流程" class="headerlink" title="Ribbon负载均衡流程"></a>Ribbon负载均衡流程</h3><p>像这样的url：<a href="http://userservice/user/1">http://userservice/user/1</a> 是没有办法通过http访问的，因为实际上不存在这么一个网站，因此Ribbon起到一个请求拦截处理的作用</p><ol><li><p>收到请求后，向Eureka拉取服务</p></li><li><p>返回服务列表，进行负载均衡，轮询获取具体服务端口</p></li></ol><p>具体操作需要在xxx-service模块中的xxxServiceApplication中将RestTemplate注入spring容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Ribbon底层"><a href="#Ribbon底层" class="headerlink" title="Ribbon底层"></a>Ribbon底层</h3><ol><li>LoadBalancerInterceptor拦截http请求，将请求解析得到服务名称</li><li>将服务名称交给RibbonLoadBalancerClient</li><li>RibbonLoadBalancerClient通过DynamicServerListLoadBalancer向eureka拉取服务列表</li><li>DynamicServerListLoadBalancer通过负载均衡策略IRule从服务列表中进行选择，提交给RibbonLoadBalancerClient</li><li>RibbonLoadBalancerClient对url进行修改，发起请求</li></ol><h3 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h3><p><img src="https://s2.loli.net/2023/08/30/Vc82tw4vB5gkmPi.png" alt="image-20230830184232870.png"></p><h4 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h4><ol><li>通过在相关服务中将IRule注入spring容器实现对负载均衡策略的修改，例如xxx-service模块中的xxxServiceApplication中（本身也算是配置类）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件的方式，在xxx-service模块中的yml配置中添加</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.magus.config.RandomRule</span> <span class="comment"># 规则类的名称</span></span><br></pre></td></tr></table></figure><h3 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h3><p>Ribbon默认是懒加载，第一次访问才会创建LoadBalancerClient，请求时间较长。使用饥饿加载可以在服务启动时就创建，减少请求时间</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment"># 单个服务</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="comment"># 多个服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">userservice</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orderservice</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Eureka</title>
      <link href="/2023/08/30/SpringCloud-Eureka/"/>
      <url>/2023/08/30/SpringCloud-Eureka/</url>
      
        <content type="html"><![CDATA[<h3 id="Eureka角色"><a href="#Eureka角色" class="headerlink" title="Eureka角色"></a>Eureka角色</h3><p>服务端：EurekaServer，服务端，注册中心。负责心跳监控，记录服务信息</p><p>客户端：EurekaClient，分为消费者和提供者。</p><h3 id="Eureka的作用"><a href="#Eureka的作用" class="headerlink" title="Eureka的作用"></a>Eureka的作用</h3><p>eureka服务类似注册中心：</p><ol><li>服务消费者和提供者将服务信息注册到注册中心</li><li>消费者向注册中心拉取提供者的新消息</li><li>通过负载均衡进行选择</li><li>实现远程调用</li></ol><p>注册中心使用心跳续约，随时监控服务状态</p><h3 id="Eureka搭建"><a href="#Eureka搭建" class="headerlink" title="Eureka搭建"></a>Eureka搭建</h3><p>搭建服务步骤如下：</p><ol><li>创建模块，引入spring-cloud-starter-netflix-eureka-server依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka服务端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果父工程中已经选好了springcloud的版本以及相关依赖，这里不需要填写版本号</p><ol start="2"><li>编写启动类，并添加@EnableEurekaServer注解</li><li>编写yml配置文件，服务端口、服务名称、地址信息（用于eureka集群通信）</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tomcat</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9099</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 应用名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hms_eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">sevice-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:$&#123;server.port&#125;/eureka</span></span><br><span class="line">    <span class="comment"># 这里选择不将自己注册 </span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h3><p>在依赖中引入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时在application.yml中配置eureka相关信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9099/eureka</span></span><br></pre></td></tr></table></figure><p>注：启动类上要加上@EnableEurekaServer注解</p><p>一直遇到一个问题，日志内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023-08-30 16:57:34.306  INFO 1076 --- [           main] com.magus.UserServiceApplication         : No active profile <span class="built_in">set</span>, falling back to default profiles: default</span><br><span class="line">2023-08-30 16:57:34.580  INFO 1076 --- [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory <span class="built_in">id</span>=24ae86d6-4a71-3421-838c-868a60323ef7</span><br><span class="line">2023-08-30 16:57:34.621  INFO 1076 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">&#x27;org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration&#x27;</span> of <span class="built_in">type</span> [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$9adaa148</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2023-08-30 16:57:34.632  INFO 1076 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">&#x27;org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration&#x27;</span> of <span class="built_in">type</span> [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$b6f4a445</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2023-08-30 16:57:34.644  WARN 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span><br><span class="line">2023-08-30 16:57:34.644  INFO 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : To <span class="built_in">enable</span> URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span><br><span class="line">2023-08-30 16:57:34.649  WARN 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span><br><span class="line">2023-08-30 16:57:34.649  INFO 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : To <span class="built_in">enable</span> URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span><br><span class="line">2023-08-30 16:57:36.516  INFO 1076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine <span class="built_in">local</span> hostname</span><br><span class="line">2023-08-30 16:57:38.145  INFO 1076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine <span class="built_in">local</span> hostname</span><br><span class="line">2023-08-30 16:57:38.203  INFO 1076 --- [           main] o.s.c.n.eureka.InstanceInfoFactory       : Setting initial instance status as: STARTING</span><br><span class="line">2023-08-30 16:57:38.224  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Initializing Eureka <span class="keyword">in</span> region us-east-1</span><br><span class="line">2023-08-30 16:57:38.855  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON encoding codec LegacyJacksonJson</span><br><span class="line">2023-08-30 16:57:38.855  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON decoding codec LegacyJacksonJson</span><br><span class="line">2023-08-30 16:57:38.928  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML encoding codec XStreamXml</span><br><span class="line">2023-08-30 16:57:38.929  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML decoding codec XStreamXml</span><br><span class="line">2023-08-30 16:57:39.042  INFO 1076 --- [           main] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2023-08-30 16:57:39.460  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Disable delta property : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null</span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application is null : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : <span class="literal">true</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application version is -1: <span class="literal">true</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server</span><br><span class="line">2023-08-30 16:57:39.535  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : The response status is 200</span><br><span class="line">2023-08-30 16:57:39.536  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 30</span><br><span class="line">2023-08-30 16:57:39.538  INFO 1076 --- [           main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4</span><br><span class="line">2023-08-30 16:57:39.541  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1693385859540 with initial instances count: 0</span><br><span class="line">2023-08-30 16:57:39.542  INFO 1076 --- [           main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application USER-SERVICE with eureka with status UP</span><br><span class="line">2023-08-30 16:57:39.543  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Saw <span class="built_in">local</span> status change event StatusChangeEvent [timestamp=1693385859543, current=UP, previous=STARTING]</span><br><span class="line">2023-08-30 16:57:39.544  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999: registering service...</span><br><span class="line">2023-08-30 16:57:39.554  INFO 1076 --- [           main] com.magus.UserServiceApplication         : Started UserServiceApplication <span class="keyword">in</span> 9.058 seconds (JVM running <span class="keyword">for</span> 10.165)</span><br><span class="line">2023-08-30 16:57:39.556  INFO 1076 --- [       Thread-5] o.s.c.n.e.s.EurekaServiceRegistry        : Unregistering application USER-SERVICE with eureka with status DOWN</span><br><span class="line">2023-08-30 16:57:39.557  WARN 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Saw <span class="built_in">local</span> status change event StatusChangeEvent [timestamp=1693385859557, current=DOWN, previous=UP]</span><br><span class="line">2023-08-30 16:57:39.561  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Shutting down DiscoveryClient ...</span><br><span class="line">2023-08-30 16:57:39.602  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - registration status: 204</span><br><span class="line">2023-08-30 16:57:39.603  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999: registering service...</span><br><span class="line">2023-08-30 16:57:39.614  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - registration status: 204</span><br><span class="line">2023-08-30 16:57:39.615  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Unregistering ...</span><br><span class="line">2023-08-30 16:57:39.630  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - deregister  status: 200</span><br><span class="line">2023-08-30 16:57:39.637  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Completed shut down of DiscoveryClient</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> Eureka客户端（服务提供者&#x2F;消费者）没有成功引入web的starter（头疼了半小时）。</p><h4 id="注册多个实例"><a href="#注册多个实例" class="headerlink" title="注册多个实例"></a>注册多个实例</h4><p>可以对服务的配置进行复制然后在VM设置中添加参数-Dserver.port&#x3D;xxxx</p><h3 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h3><ol><li>同注册，引入依赖，配置eureka地址。</li><li>给ResTemplate添加@LoadBanlanced注解（负载均衡）</li><li>用服务提供者的注册服务名称代替url中的一部分进行远程调用，例如 <a href="http://userservice/user/1">http://userservice/user/1</a> (restful)</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Eureka起到为服务之间提供远程调用的作用，来实现将服务分离又能交互</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Eureka </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyFirstBlog</title>
      <link href="/2023/08/29/MyFirstBlog/"/>
      <url>/2023/08/29/MyFirstBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h2><p>2023年8月29日正式搭建属于我的博客，希望有一天我也能写出像hexo一样能被百万人使用的project</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
