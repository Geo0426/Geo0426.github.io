<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C#脚本学习日志</title>
      <link href="/2024/06/06/Csharp%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
      <url>/2024/06/06/Csharp%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/</url>
      
        <content type="html"><![CDATA[<h2 id="C-脚本生命周期"><a href="#C-脚本生命周期" class="headerlink" title="C#脚本生命周期"></a>C#脚本生命周期</h2><ul><li>Awake：初始化。</li><li>Enable：渲染启用时调用，初始化方法不能写在里面。</li><li>Start：第一次Enable后调用。</li><li>Update：每一帧调用一次。</li><li>LateUpdate：update执行完lateupdate就会执行。</li><li>FixedUpdate：类似定时器，定期执行，与机器性能帧数无关，仅和时间有关。默认0.02s。</li><li>UnDisable：非激活状态调用。</li><li>OnDestroy：销毁时调用。</li></ul><h2 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h2><p>上一帧到下一帧的游戏时间Time.deltaTime。</p><p>时间缩放值Time.timeScale。</p><h2 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h2><p>游戏数据文件夹路径（只读，加密压缩）Applicants.dataPath。</p><p>持久化文件夹路径（可写）Applicants.persistentDataPath。</p><p>StreamingAssets文件夹路径（只读，不加密）Application.streamingAssetsPath。</p><p>临时文件夹Application.temporaryCachePath。</p><p>后台运行Application.runInBackground。</p><p>打开url Application.OpenURL。</p><p>退出游戏Application.Quit()。</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>SceneManager.CreateScene()创建场景。</p><p>SceneManager.LoadScene(“场景名称（编号）”)加载场景；LoadSceneMode参数设置为Single时只加载当前场景，设置为Additive时叠加场景。</p><p>SceneManager.LoadSceneAsync()异步加载场景，当场景很大时加载速度较慢。</p><p>SceneManager.UnloadSceneAsync()卸载场景。</p><p>SceneManager.GetActiveScene()获取当前场景。</p><p>Scene.GetRootGameObjects()获取场景中的所有游戏物体。</p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>AsyncOperation作为异步加载场景SceneManager.LoadSceneAsync()的返回值，使用yield return返回一个协程IEnumerator，并使用StartCoroutine启动协程。</p><p>operation.progress可以查看加载进度，在UI制作时可以做进度条。</p><p>operation.allowSceneActivation可以控制场景是否跳转，设置为False不会自动跳转。</p><h2 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h2><p>transform.position是世界坐标系里的位置。</p><p>transform.localPosition是相对父物体的位置。</p><p>transform.LookAt(点坐标)看向某个点。</p><p>transform.Rotate(轴, 旋转度数)；transform.RotateAround(点，轴，旋转度数)。</p><p>transform.Translate()移动。</p><p>transform.parent.gameObject获取父物体。</p><p>transform.DetachChildren()解除所有子物体。</p><p>transform.GetChild(0)根据下标获取子物体；transform.Find(“子物体名称”)根据名称获得子物体。</p><p>SetParent()设置父物体。</p><h2 id="键鼠操作"><a href="#键鼠操作" class="headerlink" title="键鼠操作"></a>键鼠操作</h2><p>input.GetMouseButtonDown()按下鼠标；input.GetKeyDown(KeyCode)按下键盘。</p><p>input.GetMouseButton()按住鼠标；input.GetKey(KeyCode)按住键盘。</p><p>input.GetMouseButtonUP()松开鼠标；input.GetKeyUp(KeyCode)松开键盘。</p><h2 id="触摸操作"><a href="#触摸操作" class="headerlink" title="触摸操作"></a>触摸操作</h2><p>判断触摸点数目使用Input.touchCount。判断触摸阶段，类似键鼠操作中的抬起按下，基于touch.phase。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Input.touchCount == <span class="number">1</span>) &#123;</span><br><span class="line">    Touch touch = Input.touches[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">switch</span>(touch.phase) &#123;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Began:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Moved:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Stationary:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Ended:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Cancled:</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  开启多点触摸</span></span><br><span class="line">Input.multiTouchEnabled = True;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Input.touchCount == <span class="number">2</span>) &#123;</span><br><span class="line">    Touch touch0 = Input.touches[<span class="number">0</span>];</span><br><span class="line">    Touch touch1 = Input.touches[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚拟轴"><a href="#虚拟轴" class="headerlink" title="虚拟轴"></a>虚拟轴</h2><p>Input.GetAxis(“Horizontal”)表示水平虚拟轴，由ad或者左右控制，或者摇杆。</p><p>Input.GetAxis(“Vertical”)表示垂直虚拟轴，由ws或者前后控制，或者摇杆。</p><p>CharacterController.SimpleMove(向量)会朝着向量方向移动，向量dir设置为Vector3(horizontal, 0, vertical)，可以完成简单角色方向控制。</p><h2 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h2><p>OnCollisionEnter监听发生碰撞；OnCollisionStay监听碰撞持续中；OnCollisionExit监听碰撞结束。</p><p>Collision类里包含了碰撞的信息，可以用于查看碰撞物体名称等。</p><h2 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h2><p>OnTriggerEnter监听触发发生；OnCollisionStay监听触发持续中；OnCollisionExit监听触发结束。</p><p>勾选是触发器选项后，不一样的地方在于，它不受物理影响，可以直接穿透而不会有碰撞体积，但同时可以检测到碰撞。</p><hr><h2 id="2024-8-29"><a href="#2024-8-29" class="headerlink" title="2024.8.29"></a>2024.8.29</h2><p>很久没写，我决定重启我的blog，最近基本都在使用Unity和编写C#脚本，然后就是用Python搭模型调参数…</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DWA path planning algorithm</title>
      <link href="/2023/11/21/DWA-path-planning-algorithm/"/>
      <url>/2023/11/21/DWA-path-planning-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="以下内容来自我的本科毕设"><a href="#以下内容来自我的本科毕设" class="headerlink" title="以下内容来自我的本科毕设"></a>以下内容来自我的本科毕设</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>动态窗口算法(Dynamic Window Approaches, DWA)，核心思想是根据无人设备当前的位置状态和速度状态在速度空间 (v,ω) 中确定一个满足无人设备硬件约束的采样速度空间，然后计算无人设备在这些速度情况下移动一定时间内的轨迹，并通过评价函数对该轨迹进行评价，最后选出评价最优的轨迹所对应的速度作为无人设备运动速度，如此循环直至移动无人设备到达目标点。</p><p>系统设计过程中对动态窗口算法的实现主要从三个方面出发，速度采样、轨迹预测、轨迹评价。</p><h2 id="速度采样"><a href="#速度采样" class="headerlink" title="速度采样"></a>速度采样</h2><p>现实中不同型号的无人设备所具有的硬件和结构不同，在物理层面上存在一定的限制，例如马力和重量会导致其最大加速度和最大转向加速度受到限制，反映在运动上的限制是运行速度的改变和方向变换的及时性。</p><p>在系统的仿真模拟中，不同模型的无人船也会设置不同的加速度参数，动态窗口算法的速度采样空间<strong>V</strong>s会收到约束。</p><p>速度范围约束：由于真实环境中阻力等物理因素的存在，针对无人船进行建模时根据它的型号对线速度和角速度范围进行了限制，v∈[vmin ,vmax ]，ω∈[ωmin ,ωmax ]。在此条件下可采样的速度空间Vm的限定范围：</p>$${V}_m=\lbrace(v,ω)∣v∈[v_{min} ,v_{max} ],ω∈[ω_{min} ,ω_{max} ]\rbrace$$<p>加速度约束：针对某一时间点，忽略加速度变化所需时间，线加速度和角加速度的范围被约束在av∈[-avmax ,avmax]，aω∈[-aωmax ,aωmax]，假定vc、ωc 分别为无人船当前时刻的线速度和角速度，在极短的时间Δt内，可采样的速度空间<strong>V</strong>d也被限定：</p>$${V}_d=\lbrace(v,ω)∣v∈[v_c−a_{vmax}⋅Δt,v_c+a_{vmax}·Δt], ω∈[ω_c−a_{ωmax}·Δt,ω_c+a_{ωmax}·Δt]\rbrace$$<p>障碍物安全距离约束：当无人船与障碍物之间的距离缩小到达一定程度时，此时即使采用最大加速度进行减速，也无法避免的发生碰撞，基于此对速度采样空间也进行了限制：</p>$${V}_a=\lbrace(v,ω)∣v∈[v_{min} ,2·dist·a_{vmax} ],ω∈[ω_{min} ,2·dist·a_{ωmax} ]\rbrace$$<p>其中，dist表示当前无人设备的位置与障碍物的最近距离。综合以上三个速度空间的限制，通过取交集获取最终的速度采样空间，即：</p>$$V_s=V_m∩V_d∩V_a$$<h2 id="轨迹预测"><a href="#轨迹预测" class="headerlink" title="轨迹预测"></a>轨迹预测</h2><p>在完成了速度采样空间<strong>V</strong>s的确认之后，根据动态窗口算法设置的采样率来对采样空间进行拆分组合。分别用<strong>Ev</strong>和<strong>Ew</strong>表示表示线速度和角速度的采样频率，即每间隔<strong>Ev</strong>进行一次速度采样，根据排列组合能够组成的线速度与角速度组数：</p>$$n=[(v_{high}−v_{low})/E_v]⋅[(w_{high}−w_{low})/E_w]$$<p>每一组(v,ω)按照设置的无人船运动模型，计算其在设置的预测时间内运动轨迹并保存，系统采用的运动模型是差分驱动模型：</p>$$\left\{\begin{aligned}x_k & = x_{k−1}+v⋅\cos(θ_{k−1})Δt \\y_k & = y_{k−1}+v⋅\sin(θ_{k−1})Δt \\θ_k & = θ_{k-1}+ωΔt\end{aligned}\right.$$<p>其中，(x,y,θ)代表无人船的位置状态，k代表采样时刻，Δt代表采样间隔。</p><h2 id="轨迹评价"><a href="#轨迹评价" class="headerlink" title="轨迹评价"></a>轨迹评价</h2><p>经过轨迹预测后得到的n组轨迹，需要经过评价函数来选择最优的轨迹作为无人船接下来的运动轨迹。轨迹评价考虑三个方面：方位角评价，评估轨迹末端位置方向与目标点连线的夹角误差，引导无人船朝向目标；距离评价，计算当前速度下轨迹与障碍物之间的最近距离，避免无人船与障碍物发生碰撞；速度评价，表示当前的速度大小，鼓励无人船保持较高的速度以提高导航效率。</p><p>评价函数量化表现为：</p>$$G(v,ω)=σ(α⋅heading(v,ω)) + σ(β⋅dist(v,ω)) + σ(γ⋅velocity(v,ω))$$<p>其中，heading(v, ω)是方位角的评价函数，轨迹终点方向与目标终点的夹角为Δθ，用heading(v, ω) &#x3D; π – Δθ作为方位角的评价函数，则夹角越小评分越高。dist(v,ω)是距离的评价函数，表示当前状态下无人船与障碍物的最小距离，距离越远越安全，评分越高。velocity(v,ω)是速度评价函数，直接用当前线速度大小作为函数值，在当前方向上的速度越快意味着轨迹越优。</p><p>α、β 、γ均为评价函数的系数，当我们对哪一部分的评分更加看重时可以通过调节评价系数来调整对轨迹的选择。σ则是对评价函数的归一化处理：</p>$$\left\{\begin{aligned}σ⋅ heading(v,ω) &=normalize\_heading(i)= \frac{heading(i)}{\sum_{i=1}^nheading(i)}  \\σ⋅dist(v,ω) &= normalize\_dist (i)= \frac{dist (i)}{\sum_{i=1}^ndist (i)} \\σ⋅velocity(v,ω) &= normalize\_velocity (i)= \frac{velocity (i)}{\sum_{i=1}^nvelocity (i)}\end{aligned}\right.$$<p>其中，n是采样速度空间的组合数目即轨迹数目。</p><p>经过速度采样、轨迹预测、轨迹评价后，得到当前无人船的运动仿真轨迹，如下图所示:</p><p><img src="https://s2.loli.net/2024/08/29/TevJR5LUgKdczEO.gif" alt="image13.gif"></p><p>图中蓝色曲线是通过评价函数选定的最优（仅针对动态窗口算法的评价标准）路径，绿色区域是由n条待评价轨迹组合成的，表示无人船可能的轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 路径规划 </category>
          
          <category> 无人船仿真系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A* path planning algorithm</title>
      <link href="/2023/11/21/A-path-planning-algorithm/"/>
      <url>/2023/11/21/A-path-planning-algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="以下内容来自我的本科毕设"><a href="#以下内容来自我的本科毕设" class="headerlink" title="以下内容来自我的本科毕设"></a>以下内容来自我的本科毕设</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>G：起点A到网格中的指定点所花费的代价</p><p>H：指定点到终点所花费的代价</p><p>F：F &#x3D; G + H，起点到终点经过指定点的总代价</p><p>open_list：用来寻找最短的路径的中间点</p><p>closed_list：不会被考虑的点</p><p>结束条件：1. 终点出现在open_list；2. open_list为空</p><h2 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h2><ol><li>从起点S开始，把S作为一个等待检查的方格，放入到open_list中</li><li>寻找起点S周围可以到达的方格(最多八个) ，将它们放入到open_list，并设置它们的父方格为S</li><li>从open_list中删除起点S，并将放入到closed_list中(closed_list存放的是不再需要检查的方格)</li><li>计算每个周围方格的F值</li><li>从open_list中选择F值最低的方格，将它从open_list中移除，并且把它可达的方格（障碍和closed_list中的方格舍弃）加入到open_list</li><li>如果可达方格不在open_list中，则父方格设置为当前方格；如果可达方格已经在open_list中，已当前方格为中间点得到的G值比原来的更小，则更新父节点为当前节点，F &#x3D; G’ + H，否则不变</li><li>循环从open_list中找F值最小的点来更新，直到结束条件</li></ol><h2 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h2><p>关于最终代价的计算，首先需要将地图进行网格化如图所示，每个方格视作为一个节点，蓝色方格是障碍物，白色方格是可通过区域，绿色方格是起点，红色方格是终点。</p><p>​    <img src="https://s2.loli.net/2024/08/29/yaJpxu1tvNFEQjD.png#pic_center" alt="素材1.png">                           </p><p>其次需要添加一些约束，针对一个节点，可以选择朝其周围的8个方向移动一个方格，其中朝上、下、左、右移动的成本为 10，朝左上、右上、左下、右下移动的成本为 14（10√2 近似值），蓝色区域也就是障碍物区域表示不可移动。</p><p>实际代价的计算可以由待检查节点向八个方向出发并计算代价，而预计代价的计算则只考虑横纵向的移动，然后把总数乘以 10，通过实际代价与预计代价的叠加来进行启发，如下图的A*算法代价计算示例。<br><img src="https://s2.loli.net/2024/08/29/5vp8xhZaCeODyob.png#pic_center" alt="素材2.png"></p><p>每个方格都标上了综合代价，实际代价，预计代价的值，方格左上角表示综合代价，左下角即从起点到当前节点的实际代价，右下角即由当前节点到终点的预计代价 。最终通过A*算法得到的路径代价计算值为68，按照下图中的方式进行回溯得到路径。</p><p> <img src="https://s2.loli.net/2024/08/29/vc4kDKmgu187wYp.png#pic_center" alt="素材3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 路径规划 </category>
          
          <category> 无人船仿真系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>船舶局部路径规划算法</title>
      <link href="/2023/11/20/%E8%88%B9%E8%88%B6%E5%B1%80%E9%83%A8%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/20/%E8%88%B9%E8%88%B6%E5%B1%80%E9%83%A8%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>文章是一篇综述，从<strong>路径搜索</strong>和<strong>轨迹优化</strong>这两个层面来对目前的路径规划算法进行总结</p><h2 id="路径搜索"><a href="#路径搜索" class="headerlink" title="路径搜索"></a>路径搜索</h2><p><img src="https://s2.loli.net/2023/11/21/J6virsL3NZtRhn1.jpg" alt="img"></p><h3 id="Astar"><a href="#Astar" class="headerlink" title="Astar*"></a>Astar*</h3><p>文章提到了两种Astar的改进算法：一种稀疏Astar算法，对转角的最大增量做了限制，得到的曲线更加平滑；一种结合自适应替换缓存（ARC）策略与基于Astar算法的Theta star算法——<a href="https://www.sciencedirect.com/science/article/abs/pii/S0029801814001292?via=ihub">Angular rate-constrained path planning algorithm for unmanned surface vehicles</a>，考虑了角速度约束得到了更符合其运动特性的规划路径（我认为比较符合我们的需求）</p><p><img src="https://s2.loli.net/2023/11/21/xUPiMm4nuDg5HQo.jpg" alt="img"></p><p>另外除了海域内的障碍，还需要考虑到船只，以及船舶安全领域、国际海上避碰规则等真实因素限制。</p><h3 id="虚拟势场法"><a href="#虚拟势场法" class="headerlink" title="虚拟势场法"></a>虚拟势场法</h3><p>包含人工势场法和快速行进法</p><h4 id="人工势场法"><a href="#人工势场法" class="headerlink" title="人工势场法*"></a>人工势场法*</h4><p>人工势场APF借鉴了电势场的概念，目标点产生引力，而障碍物产生斥力，引力场与斥力场叠加形成包含引导USV到达目标点及避障信息的人工势场。传统APF针对动态避障效果较差，集群运动需要考虑到船舶之间的距离。</p><p><a href="https://www.sciencedirect.com/science/article/pii/S002980182100144X">The hybrid path planning algorithm based on improved A* and artificial potential field for unmanned surface vehicle formations</a>这篇论文中提出的改进APF方法，在结合Astar算法的前提下，对集群编队采用了优先策略，设置一个领队，一个跟随者，一个副跟随者。通过检测船舶之间的距离对速度进行控制来避免集群之间碰撞：跟随者与副跟随者距离靠近时，副跟随者减速，反之加速。形成队形后再按照Astar规划的路径前行。</p><p><img src="https://s2.loli.net/2023/11/21/K4IfGyRlWCZpvok.jpg" alt="img"></p><h4 id="快速进行法"><a href="#快速进行法" class="headerlink" title="快速进行法"></a>快速进行法</h4><p>|∇(T(s))|W(s)&#x3D;1</p><p>利用二值栅格法进行环境建模，将障碍物区域设为<em>W</em>(<em>i</em>, <em>j</em>)&#x3D;0，将可通行区域设为<em>W</em>(<em>i</em>, <em>j</em>)&#x3D;1。通过数值求解程函方程，得到地图中各网格点的<em>T</em>值，将其视为势场值，从而建立虚拟势场</p><p>与APF法相比，FMM法构建势场唯一的极小值点便是起点，不存在路径陷入局部极小值问题</p><p>（暂时不考虑）</p><h3 id="智能算法"><a href="#智能算法" class="headerlink" title="智能算法"></a>智能算法</h3><h4 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h4><p>GA算法的实时性较差，一般不用于实时规划，用于离线规划，暂不考虑</p><h4 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a>粒子群算法</h4><p>通过最优解的位置启发其它粒子朝着最优解方向前进，从而实现粒子群整体朝着最优解的方向收敛，本文中提到的算法年代久远了需要重新调研</p><p><img src="https://s2.loli.net/2023/11/13/yQ9gjscvZRGKYDr.png" alt="image-20231113111655572"></p><p><em>vi,d</em>为当前代数下粒子运动速度；<em>xi,d</em>为当前代数下粒子位置；<em>Pi,d</em>为当前代数下的最优解；<em>Pg,d</em>为历史（全局）最优解；ω为惯性权重；<em>c</em>1和<em>c</em>2为学习因子；<em>r</em>1和<em>r</em>2为[0 1]区间内的随机小数；<em>t</em>为当前迭代数。PSO算法首先初始化一群随机粒子，再通过上式进行迭代和进化，从而找到最优解</p><p><strong>TODO</strong> 这篇文章提到的智能算法感觉不是很满意，暂时跳过，后续调研寻找新的算法补充上来</p><h2 id="轨迹优化"><a href="#轨迹优化" class="headerlink" title="轨迹优化"></a>轨迹优化</h2><h3 id="Dubins"><a href="#Dubins" class="headerlink" title="Dubins"></a>Dubins</h3><p>直线与圆弧组合的曲线，简便易行、计算量小；曲率变化不连续，在直线段与圆弧段的交点处曲率发生突变</p><h3 id="Reeds-Shepp"><a href="#Reeds-Shepp" class="headerlink" title="Reeds-Shepp"></a>Reeds-Shepp</h3><p>针对可以倒退的模型可以规划出更短的路径</p><h3 id="三次样条曲线"><a href="#三次样条曲线" class="headerlink" title="三次样条曲线"></a>三次样条曲线</h3><p>把区间[a,b]分成n个区间，每个小区间的曲线是一个三次方程，路径连续平滑，适合用于优化折线路径</p><h3 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h3><p>由起点，终点，控制点组成，调整控制点，贝塞尔曲线的形状会发生变化。计算速度和曲线形状控制方面优于三次样条曲线</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>只是初步的调研，目标是寻找一个能够考虑到物理约束（最大角速度）的算法，或者对给出的路径进行较好的轨迹优化</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 路径规划 </category>
          
          <category> 无人船仿真系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
            <tag> 曲线优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酒店管理系统-总结</title>
      <link href="/2023/09/13/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%80%BB%E7%BB%93/"/>
      <url>/2023/09/13/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端可以说完全没做，除了flask用了一些别人写好的模板，用了一下bootstrap和jQuery，可以说是很简陋。如果有机会的话想学习一下React，之前有过Vue的入门经历，还是想对这些东西都有个初步的认识（最好都能看懂），为了在以后的前后端沟通中更加方便吧</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><p>通过这个项目自主学习和实践了一下SpringCloud的基本用法，包括Nacos，Eureka，GateWay，Feign等。也在实践中理解了一些新的概念，像是负载均衡，反向代理等。</p><p>美中不足的是没有做服务熔断降级这一块，原计划是再对Sentinel进行一下学习然后使用到这个项目中的；同时MQ和Redis也没有用到，除了使用JVM处理并发以外的其他方法也没有尝试，像用Zookeeper的锁，用乐观锁悲观锁这些都没有尝试，有机会希望都能把这些知识补上</p><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><p>通过这个项目也是把python开发实践了一下，之前只做过简单的爬虫，或者是小模型的训练，没有做过Web应用这方面的。Flask框架确实很方便，配合jinja2可以很快速的搭建一些简易的平台，在前端中直接使用Python语句确实很爽。但是现在主流还是前后端分离吧，专业的人干专业的事，前端还是掌握的太少了。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 项目 </category>
          
          <category> 酒店管理系统 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask</title>
      <link href="/2023/09/13/Flask/"/>
      <url>/2023/09/13/Flask/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flask是一个轻量级的web框架，支持前后端整合，并且可在前端中直接使用相关的python语句。支持ORM（Object Relational Mapping），很好的结合mvc模式进行开发</p><h2 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Flask依赖</span></span><br><span class="line">pip install Flask</span><br><span class="line"><span class="comment"># 与数据库交互</span></span><br><span class="line">pip install flask<span class="literal">-sqlalchemy</span></span><br><span class="line"><span class="comment"># 将已有数据库导入</span></span><br><span class="line">pip install sqlacodegen</span><br><span class="line"><span class="comment"># 注册发送邮件</span></span><br><span class="line">pip install flask<span class="literal">-mail</span></span><br><span class="line"><span class="comment"># 前端表单验证</span></span><br><span class="line">pip install wtforms</span><br></pre></td></tr></table></figure><h2 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h2><p>Jinja2是一个Python模板引擎，它提供一种将数据和模板结合在一起，以生成动态文本的方法。它能够生成具有清晰而简洁的结构、更易读取的网页代码</p><p>它的常用使用方法有：python变量、语句直接在模板中使用或执行</p><p>使用{ { } }来包含一个变量，在render_template中通过额外的参数传递变量至定位的模板中，在该模板中可以使用{ { var } }来使用传递的变量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> render_template(<span class="string">&quot;admin.html&quot;</span>, hotels=hotels, facilities=facilities)</span><br></pre></td></tr></table></figure><p>在admin.html中，可以使用来使用hotels变量</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-10&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;question-ul&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; left: 70px; top: 30px&quot;</span>&gt;</span></span><br><span class="line">                &#123;% for hotel in hotels %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hotel-main&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;question-title&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">                                &#123;&#123;hotel.name&#125;&#125;</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用{ % % }来使用python语句，例如上方的代码中想要使用python中的for循环，直接使用{ % for hotel in hotels % }即可</p><p>需要注意的是，jinja2中对于语句的使用，都需要有闭合。例如{ % if % }则需要在代码块结束之后以{ % endif % }结尾；{ % for % }则需要以{ % endfor% }结尾</p><p>更多的使用方法尚未学习🕊🕊🕊</p><h2 id="config"><a href="#config" class="headerlink" title="config"></a>config</h2><p>配置方面，和SpringBoot很相似，支持用一个config.py文件来进行数据库、发送邮件的smtp服务器以及密钥等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SECRET_KEY = <span class="string">&quot;Geo0426_xxxUniversity_xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机</span></span><br><span class="line">HOSTNAME = <span class="string">&quot;localhost&quot;</span></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line">PORT = <span class="number">3307</span></span><br><span class="line"><span class="comment"># 用户名</span></span><br><span class="line">USERNAME = <span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line">PASSWORD = <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment"># 数据库名称</span></span><br><span class="line">DATABASE = <span class="string">&quot;hms&quot;</span></span><br><span class="line"><span class="comment">#  uri</span></span><br><span class="line">DB_URI = <span class="string">f&quot;mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOSTNAME&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DATABASE&#125;</span>?charset=utf8mb4&quot;</span></span><br><span class="line"></span><br><span class="line">SQLALCHEMY_DATABASE_URI = DB_URI</span><br><span class="line"></span><br><span class="line"><span class="comment">#  邮箱服务</span></span><br><span class="line">MAIL_SERVER = <span class="string">&quot;smtp.163.com&quot;</span></span><br><span class="line">MAIL_USE_SSL = <span class="literal">True</span></span><br><span class="line">MAIL_PORT = <span class="number">465</span></span><br><span class="line">MAIL_USERNAME = <span class="string">&quot;xxx@163.com&quot;</span></span><br><span class="line">MAIL_PASSWORD = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">MAIL_DEFAULT_SENDER = <span class="string">&quot;xxx@163.com&quot;</span></span><br></pre></td></tr></table></figure><h2 id="app"><a href="#app" class="headerlink" title="app"></a>app</h2><p>Flask的核心（有点类似Vue的感觉），相当于一个主类，将相关的数据库、控制器（这里应该是blueprints）、配置进行管理，此外“钩子”函数（请求拦截器，上下文处理器）也定义在其中</p><h4 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h4><p>在每一个请求执行之前，都会先执行的函数。这里在请求发起之前先将浏览器中session的token取出来，如果存在token信息则表示完成了登录，可以给全局变量g.user设置信息；否则将其设置为空表示没有登录</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_before_request</span>():</span><br><span class="line">    user_id = session.get(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> user_id:</span><br><span class="line">        user = User.query.get(user_id)</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h4 id="上下文处理器"><a href="#上下文处理器" class="headerlink" title="上下文处理器"></a>上下文处理器</h4><p>用来处理一些所有页面都需要进行渲染的变量，比如登录信息，使用它就可以很好配合jinja2</p><p>例如我们将用户登录后的信息用一个user变量存储</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.context_processor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_context_processor</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user&quot;</span>: g.user&#125;</span><br></pre></td></tr></table></figure><p>它返回的是一个字典，接下里所有template中都可以使用这个键值来获取这个对象g.user</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if user %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span>&gt;</span>&#123;&#123; user.username &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;auth.logout&#x27;) &#125;&#125;&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br></pre></td></tr></table></figure><p>完整的代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, g</span><br><span class="line"><span class="keyword">from</span> ext <span class="keyword">import</span> db, mail</span><br><span class="line"><span class="keyword">from</span> blueprints.auth <span class="keyword">import</span> bp <span class="keyword">as</span> auth_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.users <span class="keyword">import</span> bp <span class="keyword">as</span> user_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.hotels <span class="keyword">import</span> bp <span class="keyword">as</span> hotel_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.rooms <span class="keyword">import</span> bp <span class="keyword">as</span> room_bp</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment">#  配置</span></span><br><span class="line">app.config.from_object(config)</span><br><span class="line"><span class="comment">#  解决循环引用的问题</span></span><br><span class="line">db.init_app(app)</span><br><span class="line"><span class="comment">#  注册蓝图</span></span><br><span class="line">app.register_blueprint(auth_bp)</span><br><span class="line">app.register_blueprint(user_bp)</span><br><span class="line">app.register_blueprint(hotel_bp)</span><br><span class="line">app.register_blueprint(room_bp)</span><br><span class="line">mail.init_app(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_before_request</span>():</span><br><span class="line">    user_id = session.get(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> user_id:</span><br><span class="line">        user = User.query.get(user_id)</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  上下文处理器，用来处理一些所有界面都需要用到的变量（可以用来对登录状态做一个保存）</span></span><br><span class="line"><span class="meta">@app.context_processor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_context_processor</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user&quot;</span>: g.user&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="models"><a href="#models" class="headerlink" title="models"></a>models</h2><p>models是Flask中ORM的核心部分，通过类定义的方式，与数据库中的表进行映射</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Facility</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;t_facility&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">255</span>, <span class="string">&#x27;utf8mb4_general_ci&#x27;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    created_at = Column(DateTime, nullable=<span class="literal">False</span>)</span><br><span class="line">    updated_at = Column(DateTime, nullable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>tablename设置为数据库中对映的表格名称，接着通过flask_sqlalchemy中的SQLAlchemy可以将models.py中定义完成的类，以表的形式在数据库中生成。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"><span class="comment"># 在完成了db.init_app(app)将app与db绑定后，执行create_all()生成数据库表</span></span><br><span class="line">db.create_all()</span><br></pre></td></tr></table></figure><p>如果想要对数据库中的表进行改动（增删字段等操作），也可以通过修改models.py中的模型，然后同步更新到数据库。</p><p>需要用到flask-migrate</p><p>安装依赖</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install flask<span class="literal">-migrate</span></span><br></pre></td></tr></table></figure><p>在app.py中引入Migrate</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">migrate = Migrate(app, db)</span><br></pre></td></tr></table></figure><p>大致可以分为三步：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  first step</span></span><br><span class="line">flask db init</span><br><span class="line"><span class="comment">#  second step</span></span><br><span class="line">flask db migrate</span><br><span class="line"><span class="comment">#  third step</span></span><br><span class="line">flask db upgrade</span><br></pre></td></tr></table></figure><p>在执行完第一步完成初始化之后，后续更新数据库的表只需要执行后两步即可，即flask db migrate和flask db upgrade</p><p>在Flask中不需要编写sql语句，可以通过db.session只通过对类进行操作来实现数据库的增删改查</p><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>大致步骤为创建一个实体类的对象对应数据库中表的一行数据；使用db.session添加并提交</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  创建Room对象</span></span><br><span class="line">room = Room(hotel_id=hotel_id, original_price=original_price, price=price, num=num, <span class="built_in">type</span>=room_type, created_at=now, updated_at=now)</span><br><span class="line"><span class="comment">#  将其在会话中插入</span></span><br><span class="line">db.session.add(room)</span><br><span class="line"><span class="comment">#  提交</span></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>查询一条数据，可以使用class.query.get()</p><p>根据条件查询数据集合，则需要用到filter进行过滤，可以得到一个集合</p><p>.all()可以获取全部的数据; .first()能够获得第一条数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  根据主键查询一行数据，并映射到实体类对象</span></span><br><span class="line">room = Room.query.get(room_id)</span><br><span class="line"><span class="comment">#  按照一定的条件查询（使用过滤器）</span></span><br><span class="line">hotel_facilities = HotelFacility.query.filter_by(hotel_id=hotel.<span class="built_in">id</span>).<span class="built_in">all</span>()</span><br><span class="line"><span class="comment">#  获取集合中第一个满足该条件的数据行</span></span><br><span class="line">user = User.query.filter_by(email=email).first()</span><br></pre></td></tr></table></figure><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>先在数据库中查询到对应的数据映射到一个对象中；修改对象的属性；使用db.session完成commit</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">room = Room.query.get(room_id)</span><br><span class="line">room.original_price = <span class="built_in">float</span>(form.original_price.data)</span><br><span class="line">room.price = <span class="built_in">float</span>(form.price.data)</span><br><span class="line">room.num = <span class="built_in">int</span>(form.num.data)</span><br><span class="line">room.room_type = form.room_type.data</span><br><span class="line">now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">room.updated_at = now</span><br><span class="line"><span class="comment"># 数据库更新</span></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p>删除需要先查询到该条记录，然后使用会话进行删除</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除设施记录  </span></span><br><span class="line">facility = Facility.query.get(<span class="number">1</span>)  </span><br><span class="line">db.session.delete(facility)  </span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h2 id="blueprints"><a href="#blueprints" class="headerlink" title="blueprints"></a>blueprints</h2><p>blueprints（蓝图）能够降低app.py中代码的复杂度，同时可以将功能模块进行拆解，便于维护，类似spring中的controller</p><p>只需要在app.py中注册该蓝图，然后在蓝图中编写请求url对应的前缀，路由以及请求方法等即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint, request, g, redirect, render_template, url_for</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Hotel</span><br><span class="line"><span class="keyword">from</span> ext <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> .form <span class="keyword">import</span> HotelForm</span><br><span class="line"></span><br><span class="line">bp = Blueprint(<span class="string">&quot;hotels&quot;</span>, __name__, url_prefix=<span class="string">&quot;/hotels&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加酒店</span></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&quot;/addHotel&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_hotel</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;add_hotel.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        form = HotelForm(request.form)</span><br><span class="line">        <span class="keyword">if</span> form.validate():</span><br><span class="line">            name = form.name.data</span><br><span class="line">            address = form.address.data</span><br><span class="line">            introduction = form.introduction.data</span><br><span class="line">            phone = form.phone.data</span><br><span class="line">            stars = form.stars.data</span><br><span class="line">            brand = form.brand.data</span><br><span class="line">            business_district = form.business_district.data</span><br><span class="line">            now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">            hotel = Hotel(name=name, address=address, introduction=introduction, phone=phone, stars=stars, brand=brand, business_district=business_district, created_at=now, updated_at=now)</span><br><span class="line">            db.session.add(hotel)</span><br><span class="line">            db.session.commit()</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;auth.index&#x27;</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(form.errors)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;添加酒店失败，检查填写信息是否正确&quot;</span></span><br></pre></td></tr></table></figure><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>希望有机会还能用到Flask😂😂😂</p><hr><p>2024.3.13更新</p><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>Flask通过app.run(threaded&#x3D;True)开启的多线程处理，并不是指同一路由开启多个线程处理，而是不同路由使用多个线程处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(threaded=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>简单来说，threaded为True ，同时访问 &#x2F;t1 和 &#x2F;t2 路由 ，5秒后&#x2F;t1 和 &#x2F;t2 一起返回结果<br>threaded为False ，同时访问 &#x2F;t1 和 &#x2F;t2 路由 ，5秒后&#x2F;t1返回结果，10秒后&#x2F;t2返回结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/t1&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">t1</span>():</span><br><span class="line">   sleep(<span class="number">5</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;Hello World t1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/t2&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">t2</span>():</span><br><span class="line">   sleep(<span class="number">5</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;Hello World t2&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酒店管理系统-订单模块</title>
      <link href="/2023/09/09/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/09/09/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h2><p>下单功能的设计和代码编写过程中都遭遇不少困难。</p><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3><p>首先是对于库存进行加锁来避免多线程下出现库存负数的情况，在设计方面目前考虑到单服务器部署下使用jvm的synchronized来解决。</p><p>其次是异步方面的设计，要求是“将耗时的操作放到后台，而界面可以显示提示信息，并且响应等的不耐烦的用户的取消操作。”</p><p>前端设计应该需要用到异步和回调，在响应到达之前进入一个正在下单的界面，并且可以选择取消，响应到达则关闭这个界面。针对此，后端需要设计的只是取消这个功能，所以我在数据库设计方面对订单状态增加了一个下单中的状态OrderStatus.CREATING，订单在插入数据库时默认是这个状态。在用户发送取消的请求后，取消服务的实现方面，我首先会对订单的状态进行查询，因为并不确认此时的下单业务是否完成，订单状态可能处于下单中，下单失败，待支付三种状态。如果处于下单中的状态，将其修改为取消状态，是有问题的，因为代表着下单服务中的检查库存、修改订单状态还没有发生，即使将其设置为取消状态，后续也会被覆盖。</p><p>因此我认为比较合理的设计是多次询问订单状态，直至变化为下单失败或待支付，如果多次询问仍为下单中，则抛出取消失败的异常返回给前端。</p><h3 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h3><p>在Feign的使用上，之前学习并没有学到参数传递方面的知识点，现在已经弄清楚了。结合上一篇酒店模块中的进行一个整理</p><h4 id="路径中的参数"><a href="#路径中的参数" class="headerlink" title="路径中的参数"></a>路径中的参数</h4><p>当请求路径中代有参数，并且想要将其提取出来，需要使用@PathVariable注解，同时参数名和类型与Controller中保持一致</p><p>FeignClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rooms/&#123;id&#125;&quot;)</span></span><br><span class="line">Room <span class="title function_">findRoomById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Room <span class="title function_">findRoomById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> roomService.findRoomById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法中的参数"><a href="#方法中的参数" class="headerlink" title="方法中的参数"></a>方法中的参数</h4><p>当接口方法中有参数时，使用@RequestParam注解，同时参数名和类型与Controller中保持一致，Controller中不需要@RequestParam注解</p><p>FeignClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rooms/roomsOfHotel&quot;)</span></span><br><span class="line">ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(<span class="meta">@RequestParam(&quot;hotelId&quot;)</span> Integer hotelId)</span>;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;roomsOfHotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(Integer hotelId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> roomService.findRoomByHotel(hotelId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法中自定义类"><a href="#方法中自定义类" class="headerlink" title="方法中自定义类"></a>方法中自定义类</h4><p>当接口方法中想要传递可序列化类时，使用@RequestBody注解，同时参数名和类型与Controller中保持一致，Controller中<strong>需要@RequestBody注解</strong>，很重要，一定要加</p><p>FeignClient</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rooms/updateRoom&quot;)</span></span><br><span class="line">JsonResult <span class="title function_">updateRoom</span><span class="params">(<span class="meta">@RequestBody</span> Room room)</span>;</span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;updateRoom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">updateRoom</span><span class="params">(<span class="meta">@RequestBody</span> Room room)</span> &#123;</span><br><span class="line">  roomService.updateRoom(room);</span><br><span class="line">  <span class="type">JsonResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(OK);</span><br><span class="line">  result.setMessage(<span class="string">&quot;更新房间信息成功&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="OrderService"><a href="#OrderService" class="headerlink" title="OrderService"></a>OrderService</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">  <span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> order.getCheckInDate();</span><br><span class="line">  <span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> order.getCheckOutDate();</span><br><span class="line">  <span class="type">long</span> <span class="variable">days</span> <span class="operator">=</span> ChronoUnit.DAYS.between(start, end);</span><br><span class="line">  <span class="comment">//  对预定日期合理性做检查</span></span><br><span class="line">  <span class="keyword">if</span>(days &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderDateException</span>(<span class="string">&quot;预定日期错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  计算价格</span></span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomClient.findRoomById(order.getRoomId());</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">roomNum</span> <span class="operator">=</span> order.getRoomNum();</span><br><span class="line">  <span class="type">Double</span> <span class="variable">price</span> <span class="operator">=</span> roomNum * days * room.getPrice();</span><br><span class="line">  order.setPrice(price);</span><br><span class="line">  <span class="comment">//  将订单状态设置为下单中并插入数据库</span></span><br><span class="line">  <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  order.setCreatedAt(date);</span><br><span class="line">  order.setUpdatedAt(date);</span><br><span class="line">  order.setStatus(OrderStatus.CREATING.ordinal());</span><br><span class="line">  <span class="comment">//  操作数据库</span></span><br><span class="line">  <span class="keyword">if</span>(orderMapper.insert(order) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AddOrderException</span>(<span class="string">&quot;创建订单失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  String result;</span><br><span class="line">  <span class="comment">//  对库存进行核验，如果库存满足则可以下单</span></span><br><span class="line">  <span class="keyword">if</span>(checkStorage(room.getId(), roomNum)) &#123;</span><br><span class="line">    <span class="comment">//  下单成功</span></span><br><span class="line">    order.setStatus(OrderStatus.UNPAID.ordinal());</span><br><span class="line">    result = <span class="string">&quot;订单待支付&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//  库存不满足,订单状态设置为失败</span></span><br><span class="line">    order.setStatus(OrderStatus.FAIL.ordinal());</span><br><span class="line">    result = <span class="string">&quot;下单失败，库存不足&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  对状态进行更新</span></span><br><span class="line">  <span class="keyword">if</span>(orderMapper.update(order) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UpdateOrderException</span>(<span class="string">&quot;更新订单状态失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">  <span class="comment">//  对订单状态进行检查</span></span><br><span class="line">  <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectById(id);</span><br><span class="line">  <span class="comment">//  仍处在下单中的无法进行取消，必须等待状态变为失败或未支付</span></span><br><span class="line">  <span class="keyword">while</span>(order.getStatus() == OrderStatus.CREATING.ordinal()) &#123;</span><br><span class="line">    order = orderMapper.selectById(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  跳出循环则订单状态理论上变为失败和未支付</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  下单成功处于未支付状态，取消订单需要还原库存</span></span><br><span class="line">  <span class="keyword">if</span>(order.getStatus() != OrderStatus.FAIL.ordinal()) &#123;</span><br><span class="line">    <span class="comment">//  不是失败也不是未支付，状态错误</span></span><br><span class="line">    <span class="keyword">if</span>(order.getStatus() != OrderStatus.UNPAID.ordinal()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderStatusException</span>(<span class="string">&quot;订单状态错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  未支付房间库存还原(这里应该使用事务)</span></span><br><span class="line">    <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomClient.findRoomById(order.getRoomId());</span><br><span class="line">    room.setNum(room.getNum() + order.getRoomNum());</span><br><span class="line">    roomClient.updateRoom(room);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  下单失败无需还原房间库存，状态设置为取消下单即可</span></span><br><span class="line">  order.setStatus(OrderStatus.CANCEL.ordinal());</span><br><span class="line">  <span class="keyword">if</span>(orderMapper.update(order) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UpdateOrderException</span>(<span class="string">&quot;取消订单失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Boolean <span class="title function_">checkStorage</span><span class="params">(Integer roomId, Integer roomNum)</span> &#123;</span><br><span class="line">  <span class="comment">//  绝对的低效率</span></span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomClient.findRoomById(roomId);</span><br><span class="line">  <span class="keyword">if</span>(room.getNum() &gt;= roomNum) &#123;</span><br><span class="line">    room.setNum(room.getNum() - roomNum);</span><br><span class="line">    <span class="type">JsonResult</span> <span class="variable">result</span> <span class="operator">=</span> roomClient.updateRoom(room);</span><br><span class="line">    <span class="comment">//  库存充足</span></span><br><span class="line">    <span class="keyword">return</span> result.getCode() == <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  库存不足</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能说都能达到想要的效果，但是效率都不够高，多次的访问数据库进行查询就意味着效率的低下。另外就是cancel中询问订单状态应该设置一定的重试次数，使用while循环是有死循环的风险的（我这里图省事了hhh）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 项目 </category>
          
          <category> 酒店管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Feign </tag>
            
            <tag> SpringCloudGateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酒店管理系统-酒店模块</title>
      <link href="/2023/09/06/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E9%85%92%E5%BA%97%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/09/06/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E9%85%92%E5%BA%97%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>这两天几乎遇到的所有难题都和Feign有关，可以说被Feign狠狠拷打了…</p><h3 id="错误一"><a href="#错误一" class="headerlink" title="错误一"></a>错误一</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">feign.codec.DecodeException: Error <span class="keyword">while</span> extracting response <span class="keyword">for</span> <span class="built_in">type</span> [java.util.ArrayList&lt;com.magus.api.entity.Room&gt;] and content <span class="built_in">type</span> [application/json];</span><br></pre></td></tr></table></figure><p>这两天见到的最多的就是这句话，然而造成这个错误的原因是多种多样的。</p><p>我第一次遭遇这个错误是返回值不匹配造成的，起因是我在网上看到了和我同样的操作，在Controller中返回自定义的Json类，他说他在修改为Java自封装类型List之后就解决了（其实自定义类完全是可以的，但是需要创建无参构造函数）。因此我进行了尝试，以至于后面改的太乱了，有的地方是JsonResult，有的地方是User，不匹配造成了这个错误。</p><p>然后还有一个原因则是我的Feign中缺少一个配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.magus.base.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.http.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * feign的http客户端配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *No qualifying bean of type ‘org.springframework.boot.autoconfigure.http.HttpMessage</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> HttpMessageConverters <span class="title function_">messageConverters</span><span class="params">(ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpMessageConverters</span>(converters.orderedStream().collect(Collectors.toList()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HttpMessageConverters在一些版本中无法被装配，因此我们添加一个Feign的配置类对他进行@Bean装配</p><h3 id="错误二"><a href="#错误二" class="headerlink" title="错误二"></a>错误二</h3><p>这个错误又难找又逆天，网上也搜罗不到相关的信息，我只能一点点的推测来判断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;roomProvider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RoomClient</span> &#123;</span><br><span class="line">  <span class="comment">//  根据id获取room</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/rooms/&#123;id&#125;&quot;)</span></span><br><span class="line">  Room <span class="title function_">findRoomById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  获取所有room</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/rooms&quot;)</span></span><br><span class="line">  ArrayList&lt;Room&gt; <span class="title function_">findAllRooms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  根据酒店id获取room</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/rooms/roomsOfHotel&quot;)</span></span><br><span class="line">  ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(<span class="meta">@RequestParam(&quot;hotelId&quot;)</span> Integer hotelId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果FeignClient中定义的接口需要带参数的话，而且参数本身不是在url上，那么一定要添加注解@RequestParam，不然是无法识别到对应的controller接口的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;roomsOfHotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(Integer hotelId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> roomService.findRoomByHotel(hotelId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我的controller接口名称，返回值，参数名，一切都是吻合的，但是依然要加@RequestParam注解，不然收获一小时调试hhh</p><h3 id="查询酒店详细信息"><a href="#查询酒店详细信息" class="headerlink" title="查询酒店详细信息"></a>查询酒店详细信息</h3><p>这个函数的实现很好的使用了Feign来跨服务调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HotelDetail <span class="title function_">getDetail</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">  <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> hotelMapper.selectById(id);</span><br><span class="line">  <span class="comment">//  酒店id</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">hotelId</span> <span class="operator">=</span> hotel.getId();</span><br><span class="line">  <span class="type">HotelDetail</span> <span class="variable">detail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDetail</span>(hotel);</span><br><span class="line">  <span class="comment">//  设置房间列表</span></span><br><span class="line">  ArrayList&lt;Room&gt; rooms = roomClient.roomsOfHotel(hotelId);</span><br><span class="line">  detail.setRooms(rooms);</span><br><span class="line">  <span class="comment">//  设置设施列表</span></span><br><span class="line">  ArrayList&lt;Facility&gt; facilities = facilityClient.facilitiesOfHotel(hotelId);</span><br><span class="line">  detail.setFacilities(facilities);</span><br><span class="line">  <span class="keyword">return</span> detail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计了一个dto来展示酒店详细信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDetail</span> &#123;</span><br><span class="line">  <span class="comment">//  酒店地址</span></span><br><span class="line">  <span class="keyword">private</span> String address;</span><br><span class="line">  <span class="comment">//  品牌</span></span><br><span class="line">  <span class="keyword">private</span> String brand;</span><br><span class="line">  <span class="comment">//  商圈</span></span><br><span class="line">  <span class="keyword">private</span> String businessDistrict;</span><br><span class="line">  <span class="comment">//  酒店id</span></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="comment">//  酒店简介</span></span><br><span class="line">  <span class="keyword">private</span> String introduction;</span><br><span class="line">  <span class="comment">//  酒店名称</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">//  联系方式</span></span><br><span class="line">  <span class="keyword">private</span> String phone;</span><br><span class="line">  <span class="comment">//  星级</span></span><br><span class="line">  <span class="keyword">private</span> Integer stars;</span><br><span class="line">  <span class="comment">//  设施</span></span><br><span class="line">  ArrayList&lt;Facility&gt; facilities;</span><br><span class="line">  <span class="comment">//  房间列表</span></span><br><span class="line">  ArrayList&lt;Room&gt; rooms;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HotelDetail</span><span class="params">(Hotel hotel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stars = hotel.getStars();</span><br><span class="line">    <span class="built_in">this</span>.phone = hotel.getPhone();</span><br><span class="line">    <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">    <span class="built_in">this</span>.introduction = hotel.getIntroduction();</span><br><span class="line">    <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">    <span class="built_in">this</span>.businessDistrict = hotel.getBusinessDistrict();</span><br><span class="line">    <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">    <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 项目 </category>
          
          <category> 酒店管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Feign </tag>
            
            <tag> SpringCloudGateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酒店管理系统-用户模块</title>
      <link href="/2023/09/05/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/"/>
      <url>/2023/09/05/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h2 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h2><p>以前写项目的时候根本没有怎么考虑过权限问题，很简单的做了一个token验证就结束了，现在自己开始考虑到这些问题发现自己根本想不到什么好的解决方案。</p><p>首先担心的是同角色之间资源的相互访问问题，也许可以通过验证用户的角色身份来解决一部分问题，但是如果同角色试图访问其他用户的资源，不对token中的用户id进行解析是没法解决的。这样的话我在Gateway的微服务中还需要添加与数据库的连接，我不知道是不是必须如此…我主观上是这么想的，确实想不到更优雅的办法，但是感觉这样子会很笨。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取请求头</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">    <span class="comment">//  请求路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line">    <span class="comment">//  判断是否需要核验token</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要token</span></span><br><span class="line">    <span class="keyword">if</span>(tokenShouldCheck(requestPath)) &#123;</span><br><span class="line">      <span class="comment">//  不包含token</span></span><br><span class="line">      <span class="keyword">if</span>(!headers.containsKey(<span class="string">&quot;Authorization&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  核验token是否有效,以及用户权限能否获取资源</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> headers.getFirst(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.getClaimsByToken(token);</span><br><span class="line">      <span class="comment">//  过期</span></span><br><span class="line">      <span class="keyword">if</span>(claims.getExpiration().getTime() &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().getTime()) &#123;</span><br><span class="line">        <span class="comment">//  token过期，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  没有过期，对权限进行验证  </span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  传递给下一个过滤器</span></span><br><span class="line">    <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">tokenShouldCheck</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !path.equals(<span class="string">&quot;/users/login&quot;</span>) &amp;&amp; !path.equals(<span class="string">&quot;/users/register&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整段代码我只能说，和优雅是完全不沾边，感觉过滤器只学到了皮毛…</p><hr></hr><h3 id="2023-09-06"><a href="#2023-09-06" class="headerlink" title="2023&#x2F;09&#x2F;06"></a>2023&#x2F;09&#x2F;06</h3><p>在昨晚写下博客之后又自己捣鼓了好久，发现我确实学的不精…</p><p>我最开始的思路是用feign来获取用户信息，但是我居然认为feign的远程调用要经过http，所以我放弃了这个想法。如果真是这样的话，那微服务中使用feign调用其他微服务来实现功能都没法成立了，毕竟你在实现中哪来的token（如果要做token验证）</p><p>于是使用feign解决了，但是确实不算优雅</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  UserClient userClient;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取请求头</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">    <span class="comment">//  从请求中获取参数</span></span><br><span class="line"><span class="comment">//    MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span></span><br><span class="line">    <span class="comment">//  请求路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要token</span></span><br><span class="line">    <span class="keyword">if</span>(tokenShouldCheck(requestPath)) &#123;</span><br><span class="line">      <span class="comment">//  不包含token</span></span><br><span class="line">      <span class="keyword">if</span>(!headers.containsKey(<span class="string">&quot;Authorization&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  核验token是否有效,以及用户权限能否获取资源</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> headers.getFirst(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      <span class="comment">//  空token</span></span><br><span class="line">      <span class="keyword">if</span>(token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.getClaimsByToken(token);</span><br><span class="line">      <span class="comment">//  过期</span></span><br><span class="line">      <span class="keyword">if</span>(claims.getExpiration().getTime() &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().getTime()) &#123;</span><br><span class="line">        <span class="comment">//  token过期，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  没有过期</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> Integer.valueOf(claims.getSubject());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.findUserById(id);</span><br><span class="line">        <span class="comment">//  权限不足</span></span><br><span class="line">        <span class="keyword">if</span>(!hasAuthority(user, requestPath)) &#123;</span><br><span class="line">          <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">          <span class="comment">//  403权限不足</span></span><br><span class="line">          response.setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">          <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  传递给下一个过滤器</span></span><br><span class="line">    <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">tokenShouldCheck</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !path.equals(<span class="string">&quot;/users/login&quot;</span>) &amp;&amp; !path.equals(<span class="string">&quot;/users/register&quot;</span>) &amp;&amp; !path.equals(<span class="string">&quot;/users/sendVerifyCode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否有权限访问当前url下的资源</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> user 用户</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> requestPath 请求路径</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否有权限</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">hasAuthority</span><span class="params">(User user, String requestPath)</span> &#123;</span><br><span class="line">    <span class="comment">//  判断管理员权限</span></span><br><span class="line">    <span class="keyword">if</span>(requestPath.equals(<span class="string">&quot;/users&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> user.getIdentity() == Identity.Admin.ordinal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  已/users/为开头</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (requestPath.startsWith(<span class="string">&quot;/users/&quot;</span>)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">paramId</span> <span class="operator">=</span> requestPath.split(<span class="string">&quot;/&quot;</span>)[<span class="number">2</span>];</span><br><span class="line">      <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> String.valueOf(user.getId());</span><br><span class="line">      <span class="comment">//  id正确</span></span><br><span class="line">      <span class="keyword">if</span>(paramId.equals(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  id错误，判断是否有管理权限</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getIdentity() == Identity.Admin.ordinal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  其他url</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他功能以前都写烂了，没什么好说的感觉，不能很好的完成权限认证是我认为这项目开局的败笔😡</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 项目 </category>
          
          <category> 酒店管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Feign </tag>
            
            <tag> SpringCloudGateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>酒店管理系统-设计规划</title>
      <link href="/2023/09/02/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%92/"/>
      <url>/2023/09/02/%E9%85%92%E5%BA%97%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F-%E8%AE%BE%E8%AE%A1%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>经过对SpringCloud的基础知识学习后，希望将它应用到酒店管理系统这个项目中去。我的规划如下：</p><ul><li>在功能需求已知的情况下，分析并将业务拆解成多个模块实现微服务架构</li><li>进行初步的实体类设计，数据库设计</li><li>优先使用已掌握技能完成基础功能模块，如处理秒杀库存暂时不考虑使用分布式锁，目前计划使用synchronized解决</li></ul><p>当前阻力：</p><ul><li>前端设计</li><li>用户权限控制管理这块没有系统的学习，只能基础的使用JWT进行token解析</li><li>Flask框架并没有实际上手写过，也并没有使用Python进行过与数据库交互的项目开发，没有编写过脚本</li><li>消息中间件没有过多实际编码经验，尚无法确认能否顺利投入到项目使用中</li></ul><p>理想状态：</p><ul><li><input checked="" disabled="" type="checkbox"> 能够熟练的使用SpringCloud对项目各个服务模块进行开发</li><li><input disabled="" type="checkbox"> 引入消息中间件来实现对高并发的支持，引入redis缓存来提高秒杀效率</li><li><input disabled="" type="checkbox"> 补充SpringSecurity知识，对权限认证进行完善</li></ul><h4 id="2023-09-13"><a href="#2023-09-13" class="headerlink" title="2023.09.13"></a>2023.09.13</h4><p>redis和SpringSecurity在后续学习的时候再用于这个项目</p><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>仅针对Java部分的SpringCloud微服务设计</p><ol><li>用户管理模块：负责处理用户的注册、登录、基本信息维护等功能。</li><li>酒店信息管理模块：负责处理酒店列表、基本信息、细节信息的维护等功能。</li><li>订单管理模块：负责处理用户预定的订单，包括浏览订单等功能。</li><li>管理员客户管理模块：负责帮助客户重置密码，生成新的随机密码，删除用户</li></ol><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>针对酒店管理系统的业务进行数据库设计和类图的设计</p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><h4 id="t-user"><a href="#t-user" class="headerlink" title="t_user"></a>t_user</h4><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">用户id</td></tr><tr><td align="center">username</td><td align="center">varchar</td><td align="center">255</td><td align="center">用户名</td></tr><tr><td align="center">password</td><td align="center">varchar</td><td align="center">255</td><td align="center">密码</td></tr><tr><td align="center">salt</td><td align="center">varchar</td><td align="center">255</td><td align="center">盐值</td></tr><tr><td align="center">sex</td><td align="center">int</td><td align="center"></td><td align="center">性别(女0，男1)</td></tr><tr><td align="center">type</td><td align="center">int</td><td align="center"></td><td align="center">类型(0未成年人，1成年人)</td></tr><tr><td align="center">identity</td><td align="center">int</td><td align="center"></td><td align="center">身份(0为普通用户，1为用户管理员，2为酒店管理人员，3为酒店管理员)</td></tr><tr><td align="center">idcn</td><td align="center">char</td><td align="center">18</td><td align="center">身份证号码</td></tr><tr><td align="center">real_name</td><td align="center">varchar</td><td align="center">255</td><td align="center">真实姓名</td></tr><tr><td align="center">phone</td><td align="center">varchar</td><td align="center">255</td><td align="center">电话号码</td></tr><tr><td align="center">email</td><td align="center">varchar</td><td align="center">255</td><td align="center">邮箱</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><h4 id="t-hotel"><a href="#t-hotel" class="headerlink" title="t_hotel"></a>t_hotel</h4><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">用户id</td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center">255</td><td align="center">酒店名称</td></tr><tr><td align="center">address</td><td align="center">varchar</td><td align="center">255</td><td align="center">酒店地址</td></tr><tr><td align="center">introduction</td><td align="center">varchar</td><td align="center">255</td><td align="center">酒店介绍</td></tr><tr><td align="center">phone</td><td align="center">varchar</td><td align="center"></td><td align="center">联系方式</td></tr><tr><td align="center">stars</td><td align="center">int</td><td align="center"></td><td align="center">星级</td></tr><tr><td align="center">brand</td><td align="center">varchar</td><td align="center">255</td><td align="center">品牌</td></tr><tr><td align="center">business_district</td><td align="center">varchar</td><td align="center">255</td><td align="center">所属商圈</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><h4 id="t-order"><a href="#t-order" class="headerlink" title="t_order"></a>t_order</h4><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">订单id</td></tr><tr><td align="center">user_id</td><td align="center">int</td><td align="center">255</td><td align="center">用户id</td></tr><tr><td align="center">room_id</td><td align="center">int</td><td align="center">255</td><td align="center">房间id</td></tr><tr><td align="center">check_in_date</td><td align="center">datetime</td><td align="center">255</td><td align="center">入住日期</td></tr><tr><td align="center">check_out_date</td><td align="center">datetime</td><td align="center"></td><td align="center">退房日期</td></tr><tr><td align="center">room_num</td><td align="center">int</td><td align="center"></td><td align="center">房间数量</td></tr><tr><td align="center">expected_guest_num</td><td align="center">int</td><td align="center"></td><td align="center">预期入住人数</td></tr><tr><td align="center">has_children</td><td align="center">int</td><td align="center">18</td><td align="center">是否有儿童（0无1有）</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">255</td><td align="center">订单状态（0未支付，1已支付，2已取消）</td></tr><tr><td align="center">price</td><td align="center">decimal</td><td align="center">255</td><td align="center">订单价格</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><h4 id="t-room"><a href="#t-room" class="headerlink" title="t_room"></a>t_room</h4><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">房间id</td></tr><tr><td align="center">hotel_id</td><td align="center">int</td><td align="center"></td><td align="center">所属酒店id</td></tr><tr><td align="center">num</td><td align="center">int</td><td align="center"></td><td align="center">剩余数量</td></tr><tr><td align="center">type</td><td align="center">varchar</td><td align="center">255</td><td align="center">房间类型（0单人间，1双床房，2大床房）</td></tr><tr><td align="center">original_price</td><td align="center">decimal</td><td align="center"></td><td align="center">原价</td></tr><tr><td align="center">price</td><td align="center">decimal</td><td align="center"></td><td align="center">当前价格</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><h4 id="t-facilities"><a href="#t-facilities" class="headerlink" title="t_facilities"></a>t_facilities</h4><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">设施id</td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center">255</td><td align="center">设施名称</td></tr><tr><td align="center">is_free</td><td align="center">int</td><td align="center"></td><td align="center">是否免费(0付费，1免费)</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><h4 id="t-hotel-facilities"><a href="#t-hotel-facilities" class="headerlink" title="t_hotel_facilities"></a>t_hotel_facilities</h4><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">hotel_id</td><td align="center">int</td><td align="center"></td><td align="center">酒店id</td></tr><tr><td align="center">facilities_id</td><td align="center">int</td><td align="center"></td><td align="center">设施id</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><h4 id="2023-09-13-1"><a href="#2023-09-13-1" class="headerlink" title="2023.09.13"></a>2023.09.13</h4><p>t_facilities设计有问题，is_free字段应该放在t_hotel_facilities中而不是t_facilities中；其次为用户增加了一个hotel_id的字段，提供给酒店管理人员标识其管理的酒店</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>有机会再补吧，先🕊了</p><h4 id="2023-09-13-2"><a href="#2023-09-13-2" class="headerlink" title="2023.09.13"></a>2023.09.13</h4><p>不会再补了，彻底🕊了</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 项目 </category>
          
          <category> 酒店管理系统 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> UML </tag>
            
            <tag> 数据库设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-GateWay</title>
      <link href="/2023/09/02/SpringCloud-GateWay/"/>
      <url>/2023/09/02/SpringCloud-GateWay/</url>
      
        <content type="html"><![CDATA[<h2 id="网关功能"><a href="#网关功能" class="headerlink" title="网关功能"></a>网关功能</h2><ol><li>身份认证，权限认证</li><li>服务路由，负载均衡</li><li>请求限流</li></ol><h2 id="搭建网关"><a href="#搭建网关" class="headerlink" title="搭建网关"></a>搭建网关</h2><ol><li>添加依赖，nacos服务发现以及网关的依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--网关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写路由配置以及nacos的地址</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由的id，自定义，唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址，lb是负载均衡的意思，后面跟着服务的名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路由断言，请求匹配规则，只要以user开头的就匹配</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着向网关所在端口发送请求信息，如<a href="http://localhost:10010/user/1%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0userService%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E3%80%82">http://localhost:10010/user/1，就可以得到userService服务的返回。</a></p><p>服务流程：</p><p><img src="https://s2.loli.net/2023/09/02/oTYa7EjHKGSqIVC.png" alt="image-20230902161302541"></p><h2 id="路由断言工厂"><a href="#路由断言工厂" class="headerlink" title="路由断言工厂"></a>路由断言工厂</h2><p>Spring提供了多种断言工厂，除了Path用来限制路径以外，还可以限制ip，限制时间等</p><p><img src="https://s2.loli.net/2023/09/02/z782hbNTxtBpIZS.png" alt="image-20230902162312852"></p><p>详情实例见SpringCloudGateway文档<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">路由断言工厂</a></p><h2 id="路由过滤器"><a href="#路由过滤器" class="headerlink" title="路由过滤器"></a>路由过滤器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>对请求或者响应做加工处理，比如添加请求头</p><h3 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h3><p>客户端向网关发起请求，请求经过多层过滤器到达服务端，服务端的响应也会经过过滤器再返回给客户端</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>假如想要给请求头添加一个token</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由的id，自定义，唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 路由的目标地址，lb是负载均衡的意思，后面跟着服务的名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路由断言，请求匹配规则，只要以user开头的就匹配</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=token,</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=token,</span> <span class="string">xxx</span> <span class="comment"># 默认过滤器，会对所有请求都生效的过滤器</span></span><br></pre></td></tr></table></figure><p>SpringCloud官网提供了31种过滤器，详细可以参考<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">过滤器工厂</a></p><h3 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h3><p>定义一个类并且实现GlobalFilter接口，并且重写函数filter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取参数</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span><br><span class="line">    <span class="comment">//  获取具体参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">    <span class="comment">//  判断身份信息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(authorization)) &#123;</span><br><span class="line">      <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">    <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">    <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">    response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response.setComplete();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Order(-1)注解是过滤器的执行顺序（或者说优先级），值越小优先级越高</p><p>@Component注解将过滤器注册为一个Bean</p><p><strong>总结步骤：</strong></p><ol><li>实现GlobalFilter接口</li><li>添加@Order和@Component注解至类</li><li>编写过滤处理逻辑</li></ol><h3 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h3><p>每个过滤器都有一个order值，根据order值进行排序</p><p>GlobalFilter是由我们自定义order的值的</p><p>路由过滤器与默认过滤器的order值由spring决定，spring默认按照声明顺序从1开始递增</p><p>当order值一样时，会按照默认过滤器&gt;路由过滤器&gt;全局过滤器的顺序执行</p><h2 id="跨域处理"><a href="#跨域处理" class="headerlink" title="跨域处理"></a>跨域处理</h2><p>只需要通过spring的配置就可以对网关的跨域进行处理</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">globalcors:</span></span><br><span class="line">    <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line"><span class="attr">corsConfigurations:</span></span><br><span class="line">  <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">    <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求，spring boot2.4以前的配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;http://localhost&quot;</span></span><br><span class="line"><span class="comment"># allowedOriginPatterns: &quot;*&quot; # spring boot2.4以后的配置  </span></span><br><span class="line"><span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#  是否允许带cookie</span></span><br><span class="line"><span class="attr">allowedMethods:</span> <span class="comment"># 跨域方法设置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">OPTIONS</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许携带的请求头信息</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">36000</span> <span class="comment"># 跨域检测的有效期,单位s</span></span><br></pre></td></tr></table></figure><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>接SpringCloud-Feign的题外话，果然有时候无法理解某个知识的时候，不妨继续学下去看看，后继拉动前驱了属于是</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> GateWay </tag>
            
            <tag> 权限认证 </tag>
            
            <tag> 服务路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Feign</title>
      <link href="/2023/09/02/SpringCloud-Feign/"/>
      <url>/2023/09/02/SpringCloud-Feign/</url>
      
        <content type="html"><![CDATA[<h2 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h2><p>由于微服务架构，无法直接请求其他服务的service，需要远程调用，因此会用到RestTemplate来做远程调用。同时我们使用Ribbon结合RestTemplate来实现使用服务名称代替ip和端口以及负载均衡。Feign则是一种更加优雅的方式，不会需要像RestTemplate一样出现url</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>首先添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后主启动类上加上@EnableFeignClients注解，就像@EnableEurekaServer注解一样</p><p>在Service接口上添加@FeignClient注解，并且指定服务的名称（注册到服务注册中心的名称），因此这里就可以实现跨服务调用，只需要实现注册其他服务的名称的接口。使用起来的整体感觉像controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Feign配置"><a href="#Feign配置" class="headerlink" title="Feign配置"></a>Feign配置</h2><p><strong>方式一：</strong>通过修改yml文件对feign进行配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  OrderService</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span></span><br></pre></td></tr></table></figure><p><strong>方式二：</strong>通过配置类和注解</p><p>创建一个configuration类，配置Logger.Level这个Bean，加在指定服务的@FeignClient(value &#x3D; “userservice”)注解中，或者加在启动类的@EnableFeignClients( defaultConfiguration &#x3D; xxxconfiguration.class )注解中。</p><h2 id="Feign性能优化"><a href="#Feign性能优化" class="headerlink" title="Feign性能优化"></a>Feign性能优化</h2><p>Feign底层默认使用的URLConnection，不支持连接池，可以通过使用Apache HttpClient来支持连接池（减少连接的创建与释放）</p><h3 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h3><p>添加HttpClient依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置连接池</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 支持HttpClient的开关</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 单个路径的最大连接数</span></span><br></pre></td></tr></table></figure><h2 id="Feign-Api"><a href="#Feign-Api" class="headerlink" title="Feign-Api"></a>Feign-Api</h2><p>controller和FeignClient的重合度较高，可以通过采用定义接口，让二者都去继承这个接口，利用这种方式提供便捷。</p><p>存在的问题：紧耦合</p><p>我更偏向的方法是将FeignClient、POJO、Feign的默认配置封装到一个模块中，通过引入模块来供其他消费者使用。这样做也可以避免每个服务都要去实现一样的FeignClient，创建实体类等。</p><p>存在的问题：有的服务可能仅仅需要部分实体类和功能，有所冗余</p><h3 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h3><p>在其他服务的pom文件中引入该feign-api的依赖，这样就可以引入本模块中未创建的实体类，实现复用</p><p>在使用过程中会出现一个问题：对FeignClient的自动装配，@Autowired只能装配项目所在包目录下的Bean，因此需要在@EnableFeignClients注解上添加clients参数。</p><p>@EnableFeignClients( clients &#x3D; {UserClient.class, OrderClent.class}, defaultConfiguration &#x3D; xxxconfiguration.class ) clients参数可以是数组</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>流程梳理：</p><ol><li>服务模块不需要实现FeignClient来实现跨服务，不需要创建其他的实体</li><li>通过创建feign-api来对服务进行封装，为其他服务的跨服务调用提供接口，同时减少了实体类重复写的情况</li></ol><p>开发流程：</p><p>provider的服务相关内容按照springboot一样照常写，然后在provider-api中提供对服务controller的访问，其他服务需要跨服务调用时通过provider-api来从其它服务的controller中获取</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>昨晚一直在思考前端到底是如何调用有多个实例的后端服务，为此去了解了一下nginx的负载均衡和反向代理。</p><p>我的纠结点在于，我目前学到的springcloud内部的负载均衡都是服务之间的调用，可以通过其他服务的名称向注册中心进行请求，然后再根据返回的服务实例列表负载均衡。那如果这个服务本身我从前端向他发起请求，又应该怎么做才能不访问固定的端口号呢？</p><p>最初想到的方法是将对这台主机的http请求，全部向nacos寻找服务名称的这种方式，当然只是我的猜想。今天查资料，貌似是通过向网关发出请求，再由网关进行路由到具体服务。就我个人而言，从设计的角度感觉非常合理，前端的请求可以通过nginx的负载均衡向不同网关实例发送，网关又可以根据url的路径向具体的服务请求，服务则又被注册到了nacos，若存在多个实例也会在openfeign中实现负载均衡。</p><p>莫名其妙就串联起来了，学完网关再看看</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Feign </tag>
            
            <tag> RestTemplate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Nacos</title>
      <link href="/2023/09/01/SpringCloud-Nacos/"/>
      <url>/2023/09/01/SpringCloud-Nacos/</url>
      
        <content type="html"><![CDATA[<h2 id="Nacos服务注册"><a href="#Nacos服务注册" class="headerlink" title="Nacos服务注册"></a>Nacos服务注册</h2><p>首先父模块的依赖控制处需要添加spring cloud alibaba</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringCloudAlibaba有关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着在服务模块的pom中添加spring-cloud-starter-alibaba-nacos-discovery依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更改配置，nacos是在springcloud配置中的</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><p>注：EnableDiscoveryClient注解现在是可选项了，只要依赖了以spring-cloud-starter-netflix为前缀的库(例如spring-cloud-starter-netflix-eureka-client)，就启用了<strong>服务注册发现</strong>功能；</p><h2 id="服务分层架构"><a href="#服务分层架构" class="headerlink" title="服务分层架构"></a>服务分层架构</h2><p>Nacos的服务按照服务-&gt;集群-&gt;实例来分层，优先调用本地集群内的实例，本地集群中实例不可用再调用其他集群的实例</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span> </span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HangZhou</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>如果想要配置优先调用本地集群内的实例，需要修改nacos的配置，例如订单服务想要优先调用本地用户服务的实例，需要使用nacos的负载均衡策略</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 规则类的名称</span></span><br></pre></td></tr></table></figure><p>NacosRule优先选择本地集群，集群内部随机选择；当本地集群健康服务数为0时，选择跨集群访问并警告</p><h3 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h3><p>控制台可以修改实例的权重，权重越高，用户请求更多的向该实例迁移。在服务升级中，可以通过将权重比例调为0然后进行升级，之后再调成小权重进行一段时间测试，稳定后恢复权重</p><h2 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h2><p>环境隔离，对相似的服务可以进行分组，如果不同组的服务也无法相互访问。每个namespace有唯一的id，需要在配置文件中修改它的值来设置环境</p><h2 id="Nacos和Eureka的区别"><a href="#Nacos和Eureka的区别" class="headerlink" title="Nacos和Eureka的区别"></a>Nacos和Eureka的区别</h2><h3 id="健康监测"><a href="#健康监测" class="headerlink" title="健康监测"></a>健康监测</h3><p>对于服务提供者的健康状态监测，nacos将服务实例分为临时实例和非临时实例</p><p>临时实例：</p><p>和Eureka一样，使用心跳检测，如果不在服务就会主动剔除（默认情况下如果不配置，实例都是临时的）</p><p>非临时实例：</p><p>非临时实例则会由nacos主动发起询问服务实例的健康状态，并且不会将不健康的服务实例清楚，会等待恢复</p><p>创建非临时实例只需要修改discovery的值</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span> </span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HangZhou</span> <span class="comment"># 集群名称</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 是否为临时实例</span></span><br></pre></td></tr></table></figure><h3 id="服务列表"><a href="#服务列表" class="headerlink" title="服务列表"></a>服务列表</h3><p>Eureka和Nacos都会定时拉取服务列表加到缓存中，提高效率。但是Nacos还采取了消息推送的形式，当服务发生变更，会主动推送消息给消费者</p><h2 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h2><h3 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h3><p>命名规则是 服务名-运行环境.yaml如userservice-dev.yaml</p><p>配置内容只设置有热更新需求的配置项，例如日期格式等；像数据库地址这种可以不放上去</p><h3 id="配置拉取"><a href="#配置拉取" class="headerlink" title="配置拉取"></a>配置拉取</h3><p>配置读取步骤：</p><p><img src="https://s2.loli.net/2023/09/01/iCF7szOZ6HVGjlS.png" alt="image-20230901202139446.png"></p><p>bootstap.yml配置的优先级较高，可以读取到nacos的地址，再读取nacos的配置文件，最后读取application.yml的配置文件</p><p>首先在<strong>微服务</strong>引入nacos-config依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos config依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着创建bootstrap.yml文件，引导配置文件，优先级高于application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 开发环境</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>三者结合发现就是在控制台创建的配置id即userservice-dev.yaml</p><p>同时，之前的application.yml中的重复配置可以删除了，如服务名称和nacos地址</p><p>注：nacos配置管理是按服务分的，因此写在<strong>微服务</strong>模块中</p><h3 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h3><p>前置知识：</p><p>使用@Value(“${pattern.dateformat}”)注解可以获取配置项（改成NacosValue）</p><p>@ConfigurationProperties(prefix &#x3D; “xxx”) 约定大于配置，只要prefix前缀xxx与变量名进行拼接与配置一致，就可以注入</p><p>方法一：在Value注解所在类上加一个注解@RefreshScope，可以实现配置热更新，无需重启服务</p><p>方法二：使用@ConfigurationProperties(prefix &#x3D; “xxx”)注解</p><h2 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h2><p>浪费了近一个小时时间在处理依赖和配置的问题上。这里属于是对dependencymanagement不熟悉了。</p><p>使用dependencyManagement可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。</p><p>误解：以为在父模块中定义dependencyManagement之后，子模块就可以继承下来，但是在maven中发现子模块中并没有继承下来依赖。实际上是子模块中依然需要添加相关依赖但是不用加版本号。</p><p>解决方法：想要实现我的需求只需要将父模块的依赖标签dependencyManagement删除，仅使用dependencies即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mysql --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--web起步依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Ribbon</title>
      <link href="/2023/08/30/SpringCloud-Ribbon/"/>
      <url>/2023/08/30/SpringCloud-Ribbon/</url>
      
        <content type="html"><![CDATA[<h2 id="Ribbon负载均衡流程"><a href="#Ribbon负载均衡流程" class="headerlink" title="Ribbon负载均衡流程"></a>Ribbon负载均衡流程</h2><p>像这样的url：<a href="http://userservice/user/1">http://userservice/user/1</a> 是没有办法通过http访问的，因为实际上不存在这么一个网站，因此Ribbon起到一个请求拦截处理的作用</p><ol><li><p>收到请求后，向Eureka拉取服务</p></li><li><p>返回服务列表，进行负载均衡，轮询获取具体服务端口</p></li></ol><p>具体操作需要在xxx-service模块中的xxxServiceApplication中将RestTemplate注入spring容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ribbon底层"><a href="#Ribbon底层" class="headerlink" title="Ribbon底层"></a>Ribbon底层</h2><ol><li>LoadBalancerInterceptor拦截http请求，将请求解析得到服务名称</li><li>将服务名称交给RibbonLoadBalancerClient</li><li>RibbonLoadBalancerClient通过DynamicServerListLoadBalancer向eureka拉取服务列表</li><li>DynamicServerListLoadBalancer通过负载均衡策略IRule从服务列表中进行选择，提交给RibbonLoadBalancerClient</li><li>RibbonLoadBalancerClient对url进行修改，发起请求</li></ol><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p><img src="https://s2.loli.net/2023/08/30/Vc82tw4vB5gkmPi.png" alt="image-20230830184232870.png"></p><h3 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h3><ol><li>通过在相关服务中将IRule注入spring容器实现对负载均衡策略的修改，例如xxx-service模块中的xxxServiceApplication中（本身也算是配置类）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件的方式，在xxx-service模块中的yml配置中添加</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.magus.config.RandomRule</span> <span class="comment"># 规则类的名称</span></span><br></pre></td></tr></table></figure><h2 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h2><p>Ribbon默认是懒加载，第一次访问才会创建LoadBalancerClient，请求时间较长。使用饥饿加载可以在服务启动时就创建，减少请求时间</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment"># 单个服务</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="comment"># 多个服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">userservice</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orderservice</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud-Eureka</title>
      <link href="/2023/08/30/SpringCloud-Eureka/"/>
      <url>/2023/08/30/SpringCloud-Eureka/</url>
      
        <content type="html"><![CDATA[<h2 id="Eureka角色"><a href="#Eureka角色" class="headerlink" title="Eureka角色"></a>Eureka角色</h2><p>服务端：EurekaServer，服务端，注册中心。负责心跳监控，记录服务信息</p><p>客户端：EurekaClient，分为消费者和提供者。</p><h2 id="Eureka的作用"><a href="#Eureka的作用" class="headerlink" title="Eureka的作用"></a>Eureka的作用</h2><p>eureka服务类似注册中心：</p><ol><li>服务消费者和提供者将服务信息注册到注册中心</li><li>消费者向注册中心拉取提供者的新消息</li><li>通过负载均衡进行选择</li><li>实现远程调用</li></ol><p>注册中心使用心跳续约，随时监控服务状态</p><h2 id="Eureka搭建"><a href="#Eureka搭建" class="headerlink" title="Eureka搭建"></a>Eureka搭建</h2><p>搭建服务步骤如下：</p><ol><li>创建模块，引入spring-cloud-starter-netflix-eureka-server依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka服务端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果父工程中已经选好了springcloud的版本以及相关依赖，这里不需要填写版本号</p><ol start="2"><li>编写启动类，并添加@EnableEurekaServer注解</li><li>编写yml配置文件，服务端口、服务名称、地址信息（用于eureka集群通信）</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tomcat</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9099</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 应用名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hms_eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">sevice-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:$&#123;server.port&#125;/eureka</span></span><br><span class="line">    <span class="comment"># 这里选择不将自己注册 </span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h2><p>在依赖中引入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时在application.yml中配置eureka相关信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9099/eureka</span></span><br></pre></td></tr></table></figure><p>注：启动类上要加上@EnableEurekaServer注解</p><p>一直遇到一个问题，日志内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023-08-30 16:57:34.306  INFO 1076 --- [           main] com.magus.UserServiceApplication         : No active profile <span class="built_in">set</span>, falling back to default profiles: default</span><br><span class="line">2023-08-30 16:57:34.580  INFO 1076 --- [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory <span class="built_in">id</span>=24ae86d6-4a71-3421-838c-868a60323ef7</span><br><span class="line">2023-08-30 16:57:34.621  INFO 1076 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">&#x27;org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration&#x27;</span> of <span class="built_in">type</span> [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$9adaa148</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2023-08-30 16:57:34.632  INFO 1076 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">&#x27;org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration&#x27;</span> of <span class="built_in">type</span> [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$b6f4a445</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2023-08-30 16:57:34.644  WARN 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span><br><span class="line">2023-08-30 16:57:34.644  INFO 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : To <span class="built_in">enable</span> URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span><br><span class="line">2023-08-30 16:57:34.649  WARN 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span><br><span class="line">2023-08-30 16:57:34.649  INFO 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : To <span class="built_in">enable</span> URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span><br><span class="line">2023-08-30 16:57:36.516  INFO 1076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine <span class="built_in">local</span> hostname</span><br><span class="line">2023-08-30 16:57:38.145  INFO 1076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine <span class="built_in">local</span> hostname</span><br><span class="line">2023-08-30 16:57:38.203  INFO 1076 --- [           main] o.s.c.n.eureka.InstanceInfoFactory       : Setting initial instance status as: STARTING</span><br><span class="line">2023-08-30 16:57:38.224  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Initializing Eureka <span class="keyword">in</span> region us-east-1</span><br><span class="line">2023-08-30 16:57:38.855  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON encoding codec LegacyJacksonJson</span><br><span class="line">2023-08-30 16:57:38.855  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON decoding codec LegacyJacksonJson</span><br><span class="line">2023-08-30 16:57:38.928  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML encoding codec XStreamXml</span><br><span class="line">2023-08-30 16:57:38.929  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML decoding codec XStreamXml</span><br><span class="line">2023-08-30 16:57:39.042  INFO 1076 --- [           main] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2023-08-30 16:57:39.460  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Disable delta property : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null</span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application is null : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : <span class="literal">true</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application version is -1: <span class="literal">true</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server</span><br><span class="line">2023-08-30 16:57:39.535  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : The response status is 200</span><br><span class="line">2023-08-30 16:57:39.536  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 30</span><br><span class="line">2023-08-30 16:57:39.538  INFO 1076 --- [           main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4</span><br><span class="line">2023-08-30 16:57:39.541  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1693385859540 with initial instances count: 0</span><br><span class="line">2023-08-30 16:57:39.542  INFO 1076 --- [           main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application USER-SERVICE with eureka with status UP</span><br><span class="line">2023-08-30 16:57:39.543  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Saw <span class="built_in">local</span> status change event StatusChangeEvent [timestamp=1693385859543, current=UP, previous=STARTING]</span><br><span class="line">2023-08-30 16:57:39.544  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999: registering service...</span><br><span class="line">2023-08-30 16:57:39.554  INFO 1076 --- [           main] com.magus.UserServiceApplication         : Started UserServiceApplication <span class="keyword">in</span> 9.058 seconds (JVM running <span class="keyword">for</span> 10.165)</span><br><span class="line">2023-08-30 16:57:39.556  INFO 1076 --- [       Thread-5] o.s.c.n.e.s.EurekaServiceRegistry        : Unregistering application USER-SERVICE with eureka with status DOWN</span><br><span class="line">2023-08-30 16:57:39.557  WARN 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Saw <span class="built_in">local</span> status change event StatusChangeEvent [timestamp=1693385859557, current=DOWN, previous=UP]</span><br><span class="line">2023-08-30 16:57:39.561  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Shutting down DiscoveryClient ...</span><br><span class="line">2023-08-30 16:57:39.602  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - registration status: 204</span><br><span class="line">2023-08-30 16:57:39.603  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999: registering service...</span><br><span class="line">2023-08-30 16:57:39.614  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - registration status: 204</span><br><span class="line">2023-08-30 16:57:39.615  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Unregistering ...</span><br><span class="line">2023-08-30 16:57:39.630  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - deregister  status: 200</span><br><span class="line">2023-08-30 16:57:39.637  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Completed shut down of DiscoveryClient</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> Eureka客户端（服务提供者&#x2F;消费者）没有成功引入web的starter（头疼了半小时）。</p><h3 id="注册多个实例"><a href="#注册多个实例" class="headerlink" title="注册多个实例"></a>注册多个实例</h3><p>可以对服务的配置进行复制然后在VM设置中添加参数-Dserver.port&#x3D;xxxx</p><h2 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h2><ol><li>同注册，引入依赖，配置eureka地址。</li><li>给ResTemplate添加@LoadBanlanced注解（负载均衡）</li><li>用服务提供者的注册服务名称代替url中的一部分进行远程调用，例如 <a href="http://userservice/user/1">http://userservice/user/1</a> (restful)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Eureka起到为服务之间提供远程调用的作用，来实现将服务分离又能交互</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Eureka </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyFirstBlog</title>
      <link href="/2023/08/29/MyFirstBlog/"/>
      <url>/2023/08/29/MyFirstBlog/</url>
      
        <content type="html"><![CDATA[<h2 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h2><p>2023年8月29日正式搭建属于我的博客，希望有一天我也能写出像hexo一样能被百万人使用的project</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
