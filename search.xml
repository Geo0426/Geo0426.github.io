<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见聚类方法与朴素贝叶斯</title>
      <link href="/2025/01/04/cc49a10a70da/"/>
      <url>/2025/01/04/cc49a10a70da/</url>
      
        <content type="html"><![CDATA[<p>本文整理了最近学习（来自NJUSE的数据仓库课程）的一些常见聚类方法，包括K-Means、凝聚层次、DBSCAN方法，以及概率统计中的朴素贝叶斯方法（贝叶斯公式的拓展）和拉普拉斯修正。</p><h1 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h1><p>K - Means算法是一种划分式聚类算法，目标是将数据集划分为 K 个不同的聚类。它的基本思想是通过不断地迭代，使得同一聚类中的数据点尽可能相似（距离较近），不同聚类中的数据点尽可能不同（距离较远）。</p><p><strong>举例说明：</strong></p><ul><li><p>假设我们有一群学生，他们的考试成绩包括语文、数学和英语三门科目，我们想根据成绩把学生分成 3 个小组（这里的 K &#x3D; 3）。</p></li><li><p>第一步：选择初始聚类中心</p><ul><li>随机挑选 3 名学生的成绩作为初始的聚类中心。比如学生 A（语文 80，数学 70，英语 75）、学生 B（语文 60，数学 80，英语 65）、学生 C（语文 90，数学 90，英语 80）。这三个点就代表了三个初始的聚类中心。</li></ul></li><li><p>第二步：分配数据点到聚类</p><ul><li><p>计算其他每个学生的成绩与这三个聚类中心的距离。距离的计算可以使用欧几里得距离公式，比如对于学生 D（语文 70，数学 75，英语 70），与学生 A 的距离是：<br>$$<br>d_{AD}&#x3D;\sqrt{(70 - 80)^2+(75 - 70)^2+(70 - 75)^2}&#x3D;\sqrt{100 + 25+ 25}&#x3D;\sqrt{150}<br>$$</p></li><li><p>同样地，计算与学生 B 和学生 C 的距离。假设经过计算，学生 D 离学生 A 的距离最近，那么就把学生 D 分配到以学生 A 为中心的聚类中。</p></li><li><p>对所有学生都进行这样的操作，这样所有学生就被分配到了三个聚类中的一个。</p></li></ul></li><li><p>第三步：更新聚类中心</p><ul><li>对于每个聚类，重新计算聚类中心。比如在以学生 A 为中心的聚类中，把所有分配到这个聚类中的学生成绩相加，然后除以这个聚类中的学生数量，得到新的聚类中心。</li><li>假设在这个聚类中有 5 个学生，他们的语文成绩总和是 380，数学成绩总和是 360，英语成绩总和是 370。那么新的聚类中心（语文成绩）就是 $380\div5&#x3D;76$，数学成绩是$ 360\div5 &#x3D; 72$，英语成绩是$370\div5 &#x3D; 74$。</li></ul></li><li><p>第四步：重复第二步和第三步，直到收敛</p><ul><li>不断重复分配数据点和更新聚类中心的步骤，直到聚类中心不再发生明显变化（收敛）。例如，经过多次迭代后，发现聚类中心的位置变化很小，比如每次更新后，语文、数学和英语成绩的变化都在一个很小的范围内（比如小于 0.1），此时就认为算法收敛，聚类完成。</li></ul></li></ul><p>在实际应用中，K - 均值算法可以用于客户细分。例如，一家电商公司可以根据客户的购买频率、购买金额和购买商品的类别等属性，将客户分成不同的群体，以便更好地制定营销策略。</p><p>#凝聚层次</p><p>凝聚式层次聚类是一种自底向上的聚类方法。它最初将每个数据点看作是一个单独的聚类，然后在每一步中，合并最相似（距离最近）的两个聚类，直到满足某个停止条件，比如达到预定的聚类数量或者所有聚类之间的距离超过某个阈值。</p><p><strong>举例说明：</strong></p><ul><li>假设我们要对一些动物进行聚类，这些动物包括猫、狗、马、牛、鸡、鸭。</li><li>初始状态<ul><li>开始时，我们把每一种动物都看作是一个单独的聚类。所以有 6 个聚类：{猫}、{狗}、{马}、{牛}、{鸡}、{鸭}。</li></ul></li><li>计算相似度（距离）并合并聚类<ul><li>我们可以通过一些特征来衡量动物之间的相似度，比如生活习性、体型等。假设我们以生活习性为主要衡量标准。</li><li>我们发现猫和狗都是宠物，它们的生活习性比较相似，比如都生活在人类的住所周围，所以我们把 {猫} 和 {狗} 合并成一个新的聚类 {猫，狗}。现在还剩下 5 个聚类：{猫，狗}、{马}、{牛}、{鸡}、{鸭}。</li></ul></li><li>继续合并<ul><li>接着我们发现马和牛都是大型家畜，它们的生活习性也比较相似，比如都在牧场生活，所以我们把 {马} 和 {牛} 合并成一个聚类 {马，牛}。现在有 4 个聚类：{猫，狗}、{马，牛}、{鸡}、{鸭}。</li></ul></li><li>进一步合并<ul><li>再看鸡和鸭，它们都是家禽，生活习性类似，都在农场的禽类养殖区域生活，于是我们把 {鸡} 和 {鸭} 合并成 {鸡，鸭}。现在剩下 3 个聚类：{猫，狗}、{马，牛}、{鸡，鸭}。</li></ul></li><li>停止条件<ul><li>如果我们设定聚类数量为 3 个就停止，那么此时聚类过程就结束了。如果没有设定这样的停止条件，聚类过程会继续，比如再考虑 {猫，狗} 和 {马，牛} 的相似度，看是否要合并它们等，直到所有聚类之间的距离超过一个我们设定的阈值。</li></ul></li></ul><p>在实际应用中，凝聚式层次算法可以用于文档聚类。例如，将许多新闻文章进行聚类，最初每篇文章是一个聚类，然后根据文章内容的相似性（如主题、关键词等）逐步合并聚类，最后得到不同主题的新闻文章聚类，帮助用户快速了解新闻的主题分布情况。</p><h1 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h1><p>DBSCAN（Density - Based Spatial Clustering of Applications with Noise）是一种基于密度的空间聚类算法。它将数据点分为三类：核心点、边界点和噪声点。核心点是在其邻域内包含足够多的数据点的点；边界点是在核心点的邻域内但自身邻域内数据点数量不足的点；噪声点是既不是核心点也不是边界点的点。</p><p><strong>核心概念：</strong></p><ul><li><strong>$\epsilon$-邻域</strong>：对于样本集中的样本$x_j$，其$\epsilon$-邻域包含样本集中与$x_j$的距离小于等于$\epsilon$的样本，即$N_{\epsilon}(x_j)&#x3D;{x_i\in D|d(x_i,x_j)\leq\epsilon}$，其中$D$是数据集，$d$是距离度量（如欧几里得距离）。     </li><li><strong>核心点</strong>：若样本$x_j$的$\epsilon$-邻域内至少包含$MinPts$个样本（包括$x_j$本身），则$x_j$是核心点，即$|N_{\epsilon}(x_j)|\geq MinPts$。     </li><li><strong>边界点</strong>：若样本$x_i$不是核心点，但它在某个核心点的$\epsilon$-邻域内，则$x_i$是边界点。     </li><li><strong>噪声点</strong>：既不是核心点也不是边界点的样本是噪声点。</li></ul><p><strong>举例说明：</strong></p><ul><li>假设我们有一群人分布在一个操场上，这些人就是我们的数据点。</li><li>确定$\epsilon$-邻域和密度阈值$MinPts$<ul><li>我们先定义一个距离（比如 2 米）作为邻域范围，密度阈值（比如 3 个人）。也就是说，如果一个人周围 2 米范围内有至少 3 个人，那么这个人就是一个核心点。</li></ul></li><li>寻找核心点<ul><li>比如有一群人在操场的一个角落聊天，他们彼此之间的距离都小于 2 米，人数超过 3 个。那么这个小群体中的每个人都是核心点。</li></ul></li><li>确定边界点和噪声点<ul><li>现在有一个人，他距离这个聊天群体比较近，大概在 2 米左右的位置，但是他周围（2 米范围内）没有达到 3 个人，那这个人就是边界点。因为他靠近一个密集的群体，但自己所在的小区域密度不够。</li><li>而在操场的另一个很远的地方，有一个人孤零零地站着，他周围 2 米范围内根本没有其他人，那这个人就是噪声点。</li></ul></li><li>形成聚类<ul><li>所有的核心点以及和它们邻域内的边界点就构成了一个聚类。在这个例子中，聊天的那群人以及旁边的边界点就形成了一个聚类，表示操场上的一个人群聚集区域。</li></ul></li></ul><p>在实际应用中，DBSCAN 算法常用于分析空间数据、客户细分等场景，例如分析城市中店铺的分布，找出店铺聚集的商圈（聚类）以及孤立的店铺（噪声）。</p><p><strong>计算方法：</strong></p><p>这里我们定义$MinPts$为2，相似度阈值为0.8（$\epsilon$-邻域距离计算时取距离小于阈值的点，相似度计算时取相似度大于阈值的点，本质方法一样）。表格表示点P1到P5之间的相似度。</p><table><thead><tr><th align="center"></th><th align="center">P1</th><th align="center">P2</th><th align="center">P3</th><th align="center">P4</th><th align="center">P5</th></tr></thead><tbody><tr><td align="center"><strong>P1</strong></td><td align="center">1</td><td align="center">0.1</td><td align="center">0.41</td><td align="center">0.55</td><td align="center">0.35</td></tr><tr><td align="center"><strong>P2</strong></td><td align="center">0.10</td><td align="center">1</td><td align="center">0.64</td><td align="center">0.47</td><td align="center">0.98</td></tr><tr><td align="center"><strong>P3</strong></td><td align="center">0.41</td><td align="center">0.64</td><td align="center">1</td><td align="center">0.44</td><td align="center">0.85</td></tr><tr><td align="center"><strong>P4</strong></td><td align="center">0.55</td><td align="center">0.47</td><td align="center">0.44</td><td align="center">1</td><td align="center">0.76</td></tr><tr><td align="center"><strong>P5</strong></td><td align="center">0.35</td><td align="center">0.98</td><td align="center">0.85</td><td align="center">0.76</td><td align="center">1</td></tr></tbody></table><p>根据表格，P2与P5的相似度为0.98＞0.8，P3与P5的相似度为0.85＞0.8，因此可以判定P2，P3，P5为一类，其中P5是<strong>核心点</strong>，P2和P3是<strong>边界点</strong>，P1和P4是<strong>噪点</strong>。</p><h1 id="朴素贝叶斯方法"><a href="#朴素贝叶斯方法" class="headerlink" title="朴素贝叶斯方法"></a>朴素贝叶斯方法</h1><p> <strong>朴素贝叶斯</strong>是一种基于贝叶斯定理的分类算法。<strong>贝叶斯定理</strong>公式为：<br>$$<br>P(A|B)&#x3D;\frac{P(B|A)P(A)}{P(B)}<br>$$<br>在分类问题中，假设我们要分类的类别是$C$（比如是垃圾邮件或者不是垃圾邮件），特征向量是$X &#x3D; (x_1,x_2,\cdots,x_n)$（比如邮件中的单词、短语等特征）。我们的目标是计算$P(C|X)$，即给定特征向量$X$，属于类别$C$的概率。</p><p>根据贝叶斯定理，$P(C|X)&#x3D;\frac{P(X|C)P(C)}{P(X)}$，由于$P(X)$对于所有类别来说是相同的，所以我们主要关注$P(X|C)P(C)$。</p><p>朴素贝叶斯假设特征之间相互独立，所以有<br>$$<br>P(X|C)&#x3D;P(x_1|C)P(x_2|C)\cdots P(x_n|C)<br>$$<br>即X包含的子事件X1，X2 … Xn都是独立发生的。</p><p><strong>举例说明：</strong></p><p>假设我们要判断一封邮件是否是垃圾邮件。类别$C$有两种情况：$C_1$表示是垃圾邮件，$C_2$表示不是垃圾邮件。特征向量$X$是邮件中出现的单词，假设只考虑两个单词“赚钱”和“优惠”。   </p><ul><li><p>我们先统计一些数据来计算概率。假设我们有100封邮件，其中60封是垃圾邮件（$P(C_1) &#x3D; 0.6$），40封不是垃圾邮件（$P(C_2)&#x3D;0.4$）</p></li><li><p>在60封垃圾邮件中，“赚钱”这个单词出现了30次，所以$P(x_1 &#x3D;“赚钱”|C_1)&#x3D;\frac{30}{60}&#x3D;0.5$；“优惠”这个单词在垃圾邮件中出现了20次，所以$P(x_2 &#x3D;“优惠”|C_1)&#x3D;\frac{20}{60}&#x3D;\frac{1}{3}$</p></li><li><p>在40封非垃圾邮件中，“赚钱”这个单词出现了10次，所以$P(x_1 &#x3D;“赚钱”|C_2)&#x3D;\frac{10}{40}&#x3D;0.25$；“优惠”这个单词在非垃圾邮件中出现了20次，所以$P(x_2 &#x3D;“优惠”|C_2)&#x3D;\frac{20}{40}&#x3D;0.5$。</p></li></ul><p>现在有一封新邮件，里面出现了“赚钱”和“优惠”这两个单词。我们来计算它是垃圾邮件的概率$P(C_1|X)$</p><p>$$<br>P(X|C_1)&#x3D;P(x_1 &#x3D;“赚钱”|C_1)P(x_2 &#x3D;“优惠”|C_1)&#x3D;0.5\times\frac{1}{3}&#x3D;\frac{1}{6}<br>$$</p><p>$$<br>P(X|C_2)&#x3D;P(x_1 &#x3D;“赚钱”|C_2)P(x_2 &#x3D;“优惠”|C_2)&#x3D;0.25\times0.5&#x3D;\frac{1}{8}<br>$$</p><p>$$<br>P(C_1|X)&#x3D;\frac{P(X|C_1)P(C_1)}{P(X|C_1)P(C_1)+P(X|C_2)P(C_2)}&#x3D;\frac{\frac{1}{6}\times0.6}{\frac{1}{6}\times0.6+\frac{1}{8}\times0.4}&#x3D;\frac{\frac{1}{10}}{\frac{1}{10}+\frac{1}{20}}&#x3D;\frac{\frac{1}{10}}{\frac{3}{20}}&#x3D;\frac{2}{3}<br>$$</p><p>所以这封邮件有$\frac{2}{3}$的概率是垃圾邮件。</p><h1 id="拉普拉斯修正"><a href="#拉普拉斯修正" class="headerlink" title="拉普拉斯修正"></a>拉普拉斯修正</h1><p>在朴素贝叶斯算法中，可能会出现某个特征在某个类别下概率为0的情况。比如在判断邮件是否为垃圾邮件时，如果在非垃圾邮件中从未出现过“抽奖”这个单词，那么$P(x &#x3D;“抽奖”|C_2)&#x3D;0$，这会导致整个$P(X|C_2)$为0，进而影响分类结果。拉普拉斯修正就是为了解决这个问题。   </p><p>拉普拉斯修正公式为：<br>$$<br>P(x_i|C_j)&#x3D;\frac{N_{x_i,C_j}+1}{N_{C_j}+|V|}<br>$$<br>其中$N_{x_i,C_j}$是特征$x_i$在类别$C_j$中出现的次数，$N_{C_j}$是类别$C_j$的总数，$|V|$是特征空间的大小（也就是所有可能特征的数量）。 </p><p><strong>举例说明：</strong></p><ul><li><p>假设我们还是判断邮件是否是垃圾邮件，特征向量还是考虑“赚钱”和“优惠”两个单词，现在新增一个单词“抽奖”。我们还是有100封邮件，60封垃圾邮件，40封非垃圾邮件。</p></li><li><p>在垃圾邮件中，“赚钱”出现30次，“优惠”出现20次，“抽奖”出现0次。在非垃圾邮件中，“赚钱”出现10次，“优惠”出现20次，“抽奖”出现0次。   - 假设特征空间大小$|V| &#x3D; 3$（就是“赚钱”“优惠”“抽奖”这3个单词）。</p></li><li><p>对于垃圾邮件类别，根据拉普拉斯修正：</p><p>$P(x_1 &#x3D;“赚钱”|C_1)&#x3D;\frac{30 + 1}{60+3}&#x3D;\frac{31}{63}$，$P(x_2 &#x3D;“优惠”|C_1)&#x3D;\frac{20 + 1}{60+3}&#x3D;\frac{21}{63}$，$P(x_3 &#x3D;“抽奖”|C_1)&#x3D;\frac{0 + 1}{60+3}&#x3D;\frac{1}{63}$</p></li><li><p>对于非垃圾邮件类别，根据拉普拉斯修正：</p><p>$P(x_1 &#x3D;“赚钱”|C_2)&#x3D;\frac{10 + 1}{40+3}&#x3D;\frac{11}{43}$ ，$P(x_2 &#x3D;“优惠”|C_2)&#x3D;\frac{20 + 1}{40+3}&#x3D;\frac{21}{43}$ ，$P(x_3 &#x3D;“抽奖”|C_2)&#x3D;\frac{0 + 1}{40+3}&#x3D;\frac{1}{43}$</p></li></ul><p>现在有一封新邮件，里面出现了“抽奖”这个单词，我们来计算它是垃圾邮件的概率$P(C_1|X)$<br>$$<br>P(X|C_1)&#x3D;P(x_1 &#x3D;“抽奖”|C_1)&#x3D;\frac{1}{63}<br>$$</p><p>$$<br>P(X|C_2)&#x3D;P(x_1 &#x3D;“抽奖”|C_2)&#x3D;\frac{1}{43}<br>$$</p><p>$$<br>P(C_1|X)&#x3D;\frac{P(X|C_1)P(C_1)}{P(X|C_1)P(C_1)+P(X|C_2)P(C_2)}&#x3D;\frac{\frac{1}{63}\times0.6}{\frac{1}{63}\times0.6+\frac{1}{43}\times0.4}&#x3D;\frac{\frac{1}{105}}{\frac{1}{105}+\frac{2}{215}}&#x3D;\frac{43}{86}<br>$$</p><p>可以看到拉普拉斯修正避免了因为某个特征概率为0而导致的不合理结果。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>感谢泰姆埃洛斯，伟大，无需多言</p><p><a href="https://zhuanlan.zhihu.com/p/677631759">[1] 南京大学软件学院-2023-数据仓库（研究生）期末复习参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基础语法与C++11特性</title>
      <link href="/2024/11/19/d5d029fa1dbc/"/>
      <url>/2024/11/19/d5d029fa1dbc/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基础语法与概念"><a href="#C-基础语法与概念" class="headerlink" title="C++基础语法与概念"></a>C++基础语法与概念</h1><h2 id="编译内存段"><a href="#编译内存段" class="headerlink" title="编译内存段"></a>编译内存段</h2><p>C++程序编译后的内存布局可分为 <strong>静态内存段（可执行文件中预设的段）</strong> 和 <strong>运行时动态分配的内存段</strong>。</p><p><strong>静态内存段（在编译时确定，存储在可执行文件中）</strong>：</p><ul><li><strong>代码段（.text 段）</strong> 存储程序的 <strong>可执行指令（机器码）</strong>，如函数体的二进制代码。该段是只读的，确保程序运行时的稳定性</li><li><strong>数据段（.data 段）</strong> 存储 <strong>已初始化的全局变量和静态变量</strong>（包括 <code>static</code> 修饰的局部变量）。</li><li><strong>BSS 段（.bss 段）</strong> 存储 <strong>未初始化的全局变量和静态变量</strong>，默认初始化为零值。</li><li><strong>常量区（.rodata 段）</strong> 存储 <strong>只读数据</strong>，如字符串常量和 <code>const</code> 修饰的全局常量。</li></ul><p><strong>动态内存段（运行时动态分配）</strong>：</p><ul><li><strong>堆（Heap）</strong> 由程序员通过 <code>new</code>&#x2F;<code>malloc</code> 动态分配内存，需手动释放（<code>delete</code>&#x2F;<code>free</code>）。</li><li><strong>栈（Stack）</strong> 存储 <strong>函数调用的上下文</strong>，包括局部变量、参数、返回地址等。</li></ul><p><img src="https://img-blog.csdnimg.cn/aaec8bc5c5704d539f3073b07e9538b9.png" alt="C语言的内存分配{静态内存&amp;动态内存&amp;堆栈}_c语言内存-CSDN博客"></p><h2 id="静态链接与动态链接"><a href="#静态链接与动态链接" class="headerlink" title="静态链接与动态链接"></a>静态链接与动态链接</h2><h4 id="静态链接（Static-Linking）"><a href="#静态链接（Static-Linking）" class="headerlink" title="静态链接（Static Linking）"></a>静态链接（Static Linking）</h4><p>在静态链接中，所有用到的库代码在<strong>编译时</strong>被直接打包到最终的可执行文件中。生成的可执行文件是独立的，不依赖外部的库文件。</p><ul><li><strong>文件格式</strong>：静态库通常以 <code>.a</code>（Unix&#x2F;Linux）或 <code>.lib</code>（Windows）为后缀。</li><li>特点：<ul><li>可执行文件较大，因为它包含了所有依赖的库代码。</li><li>运行时不需要外部的库文件。</li><li>部署简单，适合小型项目或独立程序。</li></ul></li></ul><h4 id="动态链接（Dynamic-Linking）"><a href="#动态链接（Dynamic-Linking）" class="headerlink" title="动态链接（Dynamic Linking）"></a>动态链接（Dynamic Linking）</h4><p>在动态链接中，库代码在<strong>运行时</strong>被加载到内存中，而不是在编译时打包到可执行文件中。可执行文件仅包含对库的引用。</p><ul><li><strong>文件格式</strong>：动态库通常以 <code>.so</code>（Unix&#x2F;Linux）或 <code>.dll</code>（Windows）为后缀。</li><li>特点：<ul><li>可执行文件较小，因为它不包含库代码。</li><li>运行时需要外部的库文件。</li><li>适合大型项目或需要共享库的场景</li></ul></li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><table><thead><tr><th>特性</th><th>静态链接</th><th>动态链接</th></tr></thead><tbody><tr><td><strong>可执行文件大小</strong></td><td>较大，包含所有库代码</td><td>较小，仅包含对库的引用</td></tr><tr><td><strong>运行时依赖</strong></td><td>无需外部库文件</td><td>需要外部的动态库文件</td></tr><tr><td><strong>内存占用</strong></td><td>较高，每个程序都包含库代码</td><td>较低，多个程序共享同一份库代码</td></tr><tr><td><strong>部署复杂性</strong></td><td>简单，可执行文件独立</td><td>复杂，需确保动态库存在且版本匹配</td></tr><tr><td><strong>更新库代码</strong></td><td><strong>需重新编译整个程序</strong></td><td><strong>只需替换动态库文件</strong></td></tr><tr><td><strong>启动速度</strong></td><td>较快，无需加载外部库</td><td>较慢，需加载动态库</td></tr></tbody></table><h2 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><ul><li><p>虚函数的实现原理基于两个核心概念：<strong>虚函数表（virtual function table, vtbl）</strong>和<strong>虚函数表指针（virtual table pointer, vptr</strong>）。</p></li><li><p>每个含有虚函数的类都会有一个虚函数表，这个表中存放着该类所有虚函数的地址。编译器会为每个对象添加一个隐藏成员，即虚表指针，它指向对应的虚函数表。当调用一个虚函数时，程序会通过对象中的虚表指针找到虚函数表，再根据虚函数在表中的偏移量找到并执行正确的函数。</p></li></ul><h3 id="虚函数表属于C-编译程序的哪个段？"><a href="#虚函数表属于C-编译程序的哪个段？" class="headerlink" title="虚函数表属于C++编译程序的哪个段？"></a>虚函数表属于C++编译程序的哪个段？</h3><p>常量区&#x2F;只读数据段（.rodata段），因为其内容在编译时确定且不可修改</p><h3 id="虚函数表与虚函数表指针"><a href="#虚函数表与虚函数表指针" class="headerlink" title="虚函数表与虚函数表指针"></a>虚函数表与虚函数表指针</h3><ol><li><strong>虚函数表</strong>：当类中包含至少一个虚函数时，编译器会为该类生成一个虚函数表。虚函数表是一个静态数组，存储了类的虚函数指针（即虚函数的地址）。<ul><li><strong>虚函数表</strong> 在<strong>编译时生成</strong>（编译时遇到虚函数），是类级别的静态数据。</li></ul></li><li><strong>虚函数表指针</strong>：虚函数表指针指向类的虚函数表，类的不同对象通常共用一个虚函数表指针。<ul><li><strong>虚函数表指针</strong> 在对象构造时初始化（<strong>构造函数</strong>），指向所属类的虚函数表。因此<strong>构造函数不能定义为虚函数</strong>，构造时创建虚函数表指针。</li></ul></li></ol><h3 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a>虚析构</h3><p>如果不将析构函数定义为虚函数，当基类指针指向子类对象时，调用析构函数会执行基类的析构函数而不是子类的（静态绑定）；如果定义为虚函数则会先调用子类的析构函数，再调用基类的析构函数。因此<strong>多态场景必须使用虚析构</strong>。</p><ul><li>虚析构函数的主要作用是<strong>避免内存泄漏</strong>。当基类指针指向子类对象时，如果基类的析构函数不是虚函数，那么在删除基类指针时，只会调用基类的析构函数，而不会调用子类的析构函数。这会导致子类的资源没有被正确释放，从而造成内存泄漏。</li><li>虚析构函数的原理是通过<strong>虚函数表</strong>（vtable）实现的。当一个类包含虚函数时，编译器会为该类生成一个虚函数表，表中存储了虚函数的指针。当通过基类指针调用虚函数时，会根据虚函数表找到实际要调用的函数。</li></ul><h3 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h3><p>纯虚函数是一种特殊的虚函数，它在基类中声明但不提供实现，通常<strong>用于定义接口规范</strong>。纯虚函数的声明方式是在函数声明的末尾添加<code>= 0</code>。包含纯虚函数的类被称为抽象类，这意味着它<strong>不能被实例化</strong>，而是要求派生类必须实现这些纯虚函数。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="全局变量（Global-Variables）"><a href="#全局变量（Global-Variables）" class="headerlink" title="全局变量（Global Variables）"></a>全局变量（Global Variables）</h3><h4 id="定义位置"><a href="#定义位置" class="headerlink" title="定义位置"></a>定义位置</h4><p>在所有函数和类外部声明。</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><ul><li><p>从声明位置开始，到整个程序结束（整个文件内有效）。</p></li><li><p>可通过<code>extern</code>关键字在其他文件中访问。</p></li></ul><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>程序启动时分配内存，程序结束时释放（整个程序运行期间存在）。</p><h4 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h4><p>静态存储区（全局&#x2F;静态区）。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><ul><li>若未显式初始化，默认初始化为<code>0</code>（或对应类型的零值）。</li><li>只能使用常量表达式初始化（不能依赖运行时数据）。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; globalVar;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="非静态局部变量（Local-Variables）"><a href="#非静态局部变量（Local-Variables）" class="headerlink" title="非静态局部变量（Local Variables）"></a>非静态局部变量（Local Variables）</h3><h4 id="定义位置-1"><a href="#定义位置-1" class="headerlink" title="定义位置"></a>定义位置</h4><p>在函数、代码块（如<code>&#123;&#125;</code>）或类成员函数内部声明。</p><h4 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域"></a>作用域</h4><p>仅在定义的函数或代码块内部有效。</p><h4 id="生命周期-1"><a href="#生命周期-1" class="headerlink" title="生命周期"></a>生命周期</h4><p>进入作用域时创建，离开作用域时销毁（栈内存自动释放）。</p><h4 id="存储位置-1"><a href="#存储位置-1" class="headerlink" title="存储位置"></a>存储位置</h4><p>栈内存。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><ul><li>若未显式初始化，值为随机垃圾数据（未定义行为）。</li><li>可用运行时数据初始化。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">20</span>;  <span class="comment">// 局部变量</span></span><br><span class="line">    cout &lt;&lt; localVar;   <span class="comment">// 输出 20</span></span><br><span class="line">&#125; <span class="comment">// 函数结束，localVar 被销毁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">// cout &lt;&lt; localVar; // 错误！作用域外无法访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态局部变量（Static-Local-Variables）"><a href="#静态局部变量（Static-Local-Variables）" class="headerlink" title="静态局部变量（Static Local Variables）"></a>静态局部变量（Static Local Variables）</h3><h4 id="定义位置-2"><a href="#定义位置-2" class="headerlink" title="定义位置"></a>定义位置</h4><p>在函数内部用<code>static</code>关键字声明。</p><h4 id="作用域-2"><a href="#作用域-2" class="headerlink" title="作用域"></a>作用域</h4><p>仅在函数内部有效（与局部变量相同）。</p><h4 id="生命周期-2"><a href="#生命周期-2" class="headerlink" title="生命周期"></a>生命周期</h4><p>程序启动时分配内存，程序结束时释放（与全局变量相同）。</p><h4 id="存储位置-2"><a href="#存储位置-2" class="headerlink" title="存储位置"></a>存储位置</h4><p>静态存储区。</p><h4 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h4><ul><li>仅在第一次进入作用域时初始化一次。</li><li>若未显式初始化，默认初始化为<code>0</code>。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 静态局部变量</span></span><br><span class="line">    count++;</span><br><span class="line">    cout &lt;&lt; count &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">counter</span>();  <span class="comment">// 输出 1</span></span><br><span class="line">    <span class="built_in">counter</span>();  <span class="comment">// 输出 2（保留上次的值）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>常用于保留函数调用间的状态（如计数器、单例模式）。</li></ul><h3 id="静态成员变量（Static-Member-Variables）"><a href="#静态成员变量（Static-Member-Variables）" class="headerlink" title="静态成员变量（Static Member Variables）"></a>静态成员变量（Static Member Variables）</h3><h4 id="定义位置-3"><a href="#定义位置-3" class="headerlink" title="定义位置"></a>定义位置</h4><p>在类内部用<code>static</code>关键字声明，但需在类外定义和初始化（C++17后支持类内初始化）。</p><h4 id="作用域-3"><a href="#作用域-3" class="headerlink" title="作用域"></a>作用域</h4><ul><li>属于类，所有类的对象共享同一个静态成员变量。</li><li>可通过类名直接访问（无需对象实例）。</li></ul><h4 id="生命周期-3"><a href="#生命周期-3" class="headerlink" title="生命周期"></a>生命周期</h4><p>程序启动时分配内存，程序结束时释放。</p><h4 id="存储位置-3"><a href="#存储位置-3" class="headerlink" title="存储位置"></a>存储位置</h4><p>静态存储区。</p><h4 id="初始化-3"><a href="#初始化-3" class="headerlink" title="初始化"></a>初始化</h4><ul><li>必须在类外显式初始化（除非是<code>const static</code>整型或枚举类型）。这是因为静态成员变量<strong>属于整个类而不是某个对象</strong>。如果在类内初始化，每个对象都会包含一个静态成员的副本，这与静态成员的设计初衷相悖。</li><li>初始化时不加<code>static</code>关键字。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar;  <span class="comment">// 声明静态成员变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::staticVar = <span class="number">30</span>;  <span class="comment">// 类外定义并初始化，不需要static关键字</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1, obj2;</span><br><span class="line">    obj1.staticVar = <span class="number">40</span>;</span><br><span class="line">    cout &lt;&lt; obj2.staticVar;  <span class="comment">// 输出 40（所有对象共享）</span></span><br><span class="line">    cout &lt;&lt; MyClass::staticVar; <span class="comment">// 直接通过类名访问</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>静态成员变量不占用对象的内存空间（属于类级别）。</li></ul><h3 id="对比总结"><a href="#对比总结" class="headerlink" title="对比总结"></a>对比总结</h3><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left">全局变量</th><th align="left">局部变量</th><th align="left">静态局部变量</th><th align="left">静态成员变量</th></tr></thead><tbody><tr><td align="left"><strong>作用域</strong></td><td align="left">全局</td><td align="left">函数&#x2F;代码块内</td><td align="left">函数内部</td><td align="left">类作用域</td></tr><tr><td align="left"><strong>生命周期</strong></td><td align="left">程序运行期</td><td align="left">函数执行期间</td><td align="left">程序运行期</td><td align="left">程序运行期</td></tr><tr><td align="left"><strong>存储位置</strong></td><td align="left">静态存储区</td><td align="left">栈内存</td><td align="left">静态存储区</td><td align="left">静态存储区</td></tr><tr><td align="left"><strong>初始化</strong></td><td align="left">默认零值</td><td align="left">未初始化随机值</td><td align="left">第一次进入作用域初始化</td><td align="left">类外显式初始化</td></tr><tr><td align="left"><strong>访问方式</strong></td><td align="left">直接或<code>extern</code></td><td align="left">函数内部</td><td align="left">函数内部</td><td align="left">类名或对象</td></tr><tr><td align="left"><strong>共享性</strong></td><td align="left">全局共享</td><td align="left">每次调用独立</td><td align="left">函数内共享</td><td align="left">所有对象共享</td></tr></tbody></table><h4 id="选择优先级"><a href="#选择优先级" class="headerlink" title="选择优先级"></a>选择优先级</h4><ol><li><strong>避免全局变量</strong>：优先使用局部变量或封装为类的静态成员。</li><li><strong>静态局部变量</strong>：用于保留函数调用间的状态（如单例模式）。</li><li><strong>静态成员变量</strong>：表示类的全局属性（如统计对象数量）。</li><li><strong>局部变量</strong>：默认选择，限制作用域以提高安全性。</li></ol><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">1</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticMember; <span class="comment">// 静态成员变量声明</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> MyClass::staticMember = <span class="number">4</span>; <span class="comment">// 类外初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">2</span>;         <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticLocal = <span class="number">3</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;local: &quot;</span> &lt;&lt; localVar </span><br><span class="line">         &lt;&lt; <span class="string">&quot;, staticLocal: &quot;</span> &lt;&lt; staticLocal </span><br><span class="line">         &lt;&lt; <span class="string">&quot;, global: &quot;</span> &lt;&lt; globalVar </span><br><span class="line">         &lt;&lt; <span class="string">&quot;, staticMember: &quot;</span> &lt;&lt; MyClass::staticMember &lt;&lt; endl;</span><br><span class="line">    localVar++;</span><br><span class="line">    staticLocal++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 输出: local: 2, staticLocal: 3, global: 1, staticMember: 4</span></span><br><span class="line">    <span class="built_in">func</span>();  <span class="comment">// 输出: local: 2, staticLocal: 4, global: 1, staticMember: 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>指针本质也是一个变量，但是它存储的是另一个变量的地址，需要通过*符号来获取地址存储的值</p><p>因此指针作为参数传递时，与普通变量一样也会拷贝一份，当指针作为参数传递给函数时，<strong>传递的是指针的值（即地址）的副本</strong>。这意味着：</p><ul><li>函数内部会创建一个新的指针变量（副本），它的值和传入的指针相同（即指向同一个地址）。</li><li>函数内对指针副本的修改（如改变指向）不会影响主函数的指针。</li><li>函数内通过指针副本<strong>修改目标变量的值会影响</strong>主函数的目标变量。</li></ul><h3 id="alloca函数"><a href="#alloca函数" class="headerlink" title="alloca函数"></a>alloca函数</h3><p><code>alloca</code> 是一个在 C 和 C++ 中可用的函数，用于在栈上动态分配内存空间。它类似于 <code>malloc</code> 函数，但是分配的内存空间在函数返回后会自动释放，无需显式调用 <code>free</code> 函数。</p><p>返回类型是void *，函数本身只负责分配空间，使用时需要进行类型转换，例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;alloca.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dynamicStackAllocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>* dynamicArray;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    dynamicArray = (<span class="type">int</span>*)<span class="built_in">alloca</span>(size * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用动态分配的栈空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        dynamicArray[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印动态分配的栈空间</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dynamicArray[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dynamicStackAllocation</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量指针与指针常量"><a href="#常量指针与指针常量" class="headerlink" title="常量指针与指针常量"></a>常量指针与指针常量</h3><ul><li>常量指针是<strong>不能改变</strong>指向的指针，指针本身是个常量；</li><li>指针常量是指向一个常量的指针，<strong>可以改变</strong>指向；</li></ul><h3 id="野指针和悬空指针"><a href="#野指针和悬空指针" class="headerlink" title="野指针和悬空指针"></a>野指针和悬空指针</h3><ul><li>野指针是<strong>没被初始化的指针</strong></li><li>悬空指针是指向<strong>被释放了的内存的指针</strong></li></ul><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>指向全局函数或静态成员函数的指针。作用域是全局或命名空间作用域，无需依赖类的实例。</p><h4 id="函数指针与成员函数指针对比"><a href="#函数指针与成员函数指针对比" class="headerlink" title="函数指针与成员函数指针对比"></a>函数指针与成员函数指针对比</h4><ul><li>函数指针的赋值可直接<strong>赋值函数名</strong>或<strong>显式取地址</strong>。</li><li>成员函数指针的赋值必须<strong>显式使用取地址</strong>运算符，不能隐式转换。</li></ul><p><strong>代码示例</strong>：</p><p><strong>赋值定义</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="comment">// 定义时与函数名无关，仅与返回类型和参数类型有关</span></span><br><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">int</span>, <span class="type">int</span>) = &amp;add; <span class="comment">// 指向全局函数</span></span><br><span class="line"><span class="built_in">int</span> (*pf)(<span class="type">int</span>, <span class="type">int</span>) = add; <span class="comment">// 隐式转换</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数指针</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (A::*pmf)(<span class="type">int</span>, <span class="type">int</span>) = &amp;A::add; <span class="comment">// 指向类成员函数</span></span><br><span class="line"><span class="built_in">int</span> (A::*pmf)(<span class="type">int</span>, <span class="type">int</span>) = A::add; <span class="comment">// 隐式转换，错误❌</span></span><br></pre></td></tr></table></figure><p><strong>调用方式</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数指针</span></span><br><span class="line">pf = add;       <span class="comment">// 隐式转换</span></span><br><span class="line">pf = &amp;add;      <span class="comment">// 显式取地址</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> result = (*pf)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 传统方式</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">pf</span>(<span class="number">2</span>, <span class="number">3</span>);    <span class="comment">// 简化调用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数指针</span></span><br><span class="line">pmf = &amp;A::add; <span class="comment">// 正确</span></span><br><span class="line">pmf = A::add;  <span class="comment">// 错误，无法隐式转换</span></span><br><span class="line"></span><br><span class="line">A a;</span><br><span class="line">(a.*pmf)(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 对象实例调用</span></span><br><span class="line">A* ptr = &amp;a;</span><br><span class="line">(ptr-&gt;*pmf)(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 对象指针调用</span></span><br></pre></td></tr></table></figure><p><strong>特性对比</strong></p><table><thead><tr><th align="center"><strong>特性</strong></th><th><strong>函数指针</strong></th><th><strong>成员函数指针</strong></th></tr></thead><tbody><tr><td align="center"><strong>作用域</strong></td><td>全局或静态作用域</td><td>类作用域，依赖对象实例</td></tr><tr><td align="center"><strong>声明语法</strong></td><td><code>int (*pf)(int, int);</code></td><td><code>int (A::*pmf)(int, int);</code></td></tr><tr><td align="center"><strong>调用方式</strong></td><td>直接调用 <code>pf(2, 3)</code></td><td>通过对象 <code>(a.*pmf)(2, 3)</code></td></tr><tr><td align="center"><strong>内存占用</strong></td><td>普通指针大小（4&#x2F;8 字节）</td><td>可能为双倍或三倍指针大小（8-16 字节）</td></tr><tr><td align="center"><strong>典型应用</strong></td><td>回调函数、函数表</td><td>类策略模式、消息处理</td></tr><tr><td align="center"><strong>赋值限制</strong></td><td>可隐式转换函数名</td><td>必须显式取地址 <code>&amp;A::add</code></td></tr></tbody></table><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><strong>定义</strong></p><ul><li><p><strong>指针</strong>是一个变量，存储另一个对象的内存地址。指针可以为空（<code>nullptr</code>），也可以重新指向其他对象。</p></li><li><p><strong>引用</strong>是一个对象的别名，必须在初始化时绑定到一个对象，且不能重新绑定到其他对象。引用不能为空。</p></li></ul><p><strong>指针与引用的区别</strong></p><ul><li>引用必须初始化；指针不必初始化</li><li>引用无法重新绑定其他对象；指针可以更改指向</li><li>引用不能为空；指针可以指向空值</li><li>引用本质是别名，通常不占用额外内存；指针是变量，需要分配内存</li></ul><h2 id="union（共同体-联合体）"><a href="#union（共同体-联合体）" class="headerlink" title="union（共同体&#x2F;联合体）"></a>union（共同体&#x2F;联合体）</h2><p><strong>共同体</strong>的所有成员共享同一块内存空间，<strong>同一时间只能存储一个成员的值</strong>。共同体的大小等于最大成员的大小。</p><p><strong>代码示例</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义共同体</span></span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> &#123;</span><br><span class="line">    <span class="type">int</span> num;      <span class="comment">// 4字节</span></span><br><span class="line">    <span class="type">char</span> ch;      <span class="comment">// 1字节</span></span><br><span class="line">    <span class="type">double</span> value; <span class="comment">// 8字节（最大成员）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Data d;</span><br><span class="line">    d.num = <span class="number">42</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; d.num &lt;&lt; endl; <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    d.ch = <span class="string">&#x27;Z&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ch: &quot;</span> &lt;&lt; d.ch &lt;&lt; endl;   <span class="comment">// 输出 Z</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; d.num &lt;&lt; endl; <span class="comment">// 输出垃圾值（内存被覆盖）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共同体大小 = 最大成员的大小 = 8 字节</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Size of union Data: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(Data) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">num: <span class="number">42</span></span><br><span class="line">ch: Z</span><br><span class="line">num: <span class="number">90</span>  <span class="comment">// 具体值取决于内存覆盖后的结果</span></span><br><span class="line">Size of <span class="keyword">union</span> <span class="title class_">Data</span>: <span class="number">8</span></span><br></pre></td></tr></table></figure><p><strong>特点</strong>：</p><ul><li>成员共享内存，修改一个成员会影响其他成员。</li><li>适用场景：节省内存，同一时间只使用一个成员（如网络协议解析）。</li></ul><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>结构体（Struct）</strong></th><th align="left"><strong>共同体（Union）</strong></th></tr></thead><tbody><tr><td align="left"><strong>内存分配</strong></td><td align="left">成员占用独立内存，总大小为各成员之和（含对齐）</td><td align="left">成员共享内存，总大小为最大成员的大小</td></tr><tr><td align="left"><strong>成员访问</strong></td><td align="left">所有成员可同时访问</td><td align="left">同一时间只能使用一个成员</td></tr><tr><td align="left"><strong>内存效率</strong></td><td align="left">内存占用较高</td><td align="left">内存占用较低（仅用最大成员的空间）</td></tr><tr><td align="left"><strong>典型应用场景</strong></td><td align="left">存储多个相关数据（如坐标、学生信息）</td><td align="left">节省内存，类型转换（如协议解析）</td></tr></tbody></table><h3 id="如何判断当前系统是大端（Big-Endian）还是小端（Little-Endian）？"><a href="#如何判断当前系统是大端（Big-Endian）还是小端（Little-Endian）？" class="headerlink" title="如何判断当前系统是大端（Big-Endian）还是小端（Little-Endian）？"></a>如何判断当前系统是大端（Big-Endian）还是小端（Little-Endian）？</h3><p><strong>方法一</strong>：使用union定义一个int类型成员变量和一个char类型成员变量，利用共享内存的性质读取低地址存放值判断大小端</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLittleEndian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="type">int</span> num;</span><br><span class="line">        <span class="type">char</span> byte;</span><br><span class="line">    &#125; test;</span><br><span class="line">    test.num = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (test.byte == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLittleEndian</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;系统是小端（Little-Endian）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;系统是大端（Big-Endian）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：定义一个值为1多字节整数例如<code>int</code>，将它的地址从<code>int*</code>类型使用<code>reinterpret_cast&lt;char&gt;</code>转换到<code>char*</code>类型，从低地址读取第一个字节的值，如果结果是1则是小端，是0则是大端。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isLittleEndian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">1</span>; <span class="comment">// 多字节整数，值为 1</span></span><br><span class="line">    <span class="type">char</span>* bytePtr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;num); <span class="comment">// 获取第一个字节的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果第一个字节是 1，则是小端；否则是大端</span></span><br><span class="line">    <span class="keyword">return</span> (*bytePtr == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isLittleEndian</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;系统是小端（Little-Endian）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;系统是大端（Big-Endian）&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变量声明与定义"><a href="#变量声明与定义" class="headerlink" title="变量声明与定义"></a>变量声明与定义</h2><ul><li>变量可以多次声明（使用 <code>extern</code>），但只能定义一次。</li><li>声明通常放在头文件中，定义放在源文件中。</li></ul><p>变量的声明是告诉编译器变量的存在及其类型，但<strong>不分配内存</strong>。在头文件中声明变量，以便多个源文件可以共享该变量。如果在头文件中定义变量，同时多个源文件包含了该头文件则会出现错误。</p><h3 id="多次定义示例"><a href="#多次定义示例" class="headerlink" title="多次定义示例"></a>多次定义示例</h3><p>**头文件 <code>example.h</code>**：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义变量（错误用法）</span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">42</span>; <span class="comment">// 在头文件中定义变量</span></span><br></pre></td></tr></table></figure><p>**源文件 <code>example1.cpp</code>**：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;globalVar in func1: %d\n&quot;</span>, globalVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**源文件 <code>example2.cpp</code>**：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;globalVar in func2: %d\n&quot;</span>, globalVar);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**主文件 <code>main.cpp</code>**：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;example.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func1</span>();</span><br><span class="line">    <span class="built_in">func2</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>编译错误</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">multiple definition of <span class="string">&#x27;globalVar&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ul><li>在 <code>example.h</code> 中，<code>int globalVar = 42;</code> 是变量的定义。</li><li>当 <code>example.h</code> 被多个源文件（<code>example1.cpp</code> 和 <code>example2.cpp</code>）包含时，<code>globalVar</code> 会被多次定义。</li><li>这违反了 <strong>“一次定义规则”</strong>（One Definition Rule, ODR），导致链接错误。</li></ul><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3><p>在构造函数中，编译器会在用户代码之前依次插入：</p><ol><li><p>按各虚基类的声明顺序（从左到右）调用构造函数。此步骤<strong>只有在继承链最底层（most-derived）的类会执行</strong>，而继承链中间的只需共享最底层构建的即可。</p></li><li><p>按各非虚基类的声明顺序(从左到右）调用构造函数</p></li><li><p>设置本类的<code>vptr</code>指向本类的<code>vtable</code></p></li><li><p>按各成员的声明顺序（从上到下）调用构造函数</p></li></ol><p>以上工作做完之后才开始真正执行用户写的构造函数代码。</p><h4 id="为什么虚函数表指针在成员构造之前，基类构造之后进行初始化？"><a href="#为什么虚函数表指针在成员构造之前，基类构造之后进行初始化？" class="headerlink" title="为什么虚函数表指针在成员构造之前，基类构造之后进行初始化？"></a>为什么虚函数表指针在成员构造之前，基类构造之后进行初始化？</h4><ul><li><code>vptr</code>的设置位置，在成员的构造之前，因为这样才能保证成员构造时以及用户代码中调用的虚函数是本类的版本。</li><li>同时其在各种基类的构造之后，这样才能保证基类构造时使用基类自己的虚函数版本，基类是在其自己的构造函数中设置的<code>vptr</code>的。</li><li><code>vptr</code>在构造过程中经过了多次的改变，从指向基类的<code>vtable</code>一直沿继承链向下到最终派生类的<code>vtable</code>。</li></ul><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><ul><li>如果类显式定义了拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，编译器不会自动生成默认的移动构造函数和移动赋值运算符。</li><li>如果定义了拷贝赋值运算符，仍然会生成默认的拷贝构造函数；如果定义了拷贝构造函数，仍然会生成默认的拷贝赋值运算符；</li></ul><table><thead><tr><th><strong>函数</strong></th><th><strong>生成默认版本的条件</strong></th><th>C++标准</th></tr></thead><tbody><tr><td>默认构造函数</td><td>用户未定义任何构造函数</td><td>C++03</td></tr><tr><td>析构函数</td><td>用户未定义析构函数</td><td>C++03</td></tr><tr><td>拷贝构造函数</td><td>用户未定义拷贝构造函数、移动构造函数、移动赋值运算符或析构函数</td><td>C++03</td></tr><tr><td>拷贝赋值运算符</td><td>用户未定义拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数</td><td>C++03</td></tr><tr><td>移动构造函数</td><td>用户未定义拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数</td><td>C++11</td></tr><tr><td>移动赋值运算符</td><td>用户未定义拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数</td><td>C++11</td></tr></tbody></table><h3 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h3><h4 id="浅拷贝（Shallow-Copy）"><a href="#浅拷贝（Shallow-Copy）" class="headerlink" title="浅拷贝（Shallow Copy）"></a>浅拷贝（Shallow Copy）</h4><ul><li><strong>行为</strong>：直接复制对象的成员值（包括指针的地址），但<strong>不复制指针指向的实际内存</strong>。</li><li><strong>结果</strong>：两个对象的指针成员指向<strong>同一块内存地址</strong>，修改其中一个对象会影响另一个对象，且可能导致重复释放内存（崩溃）。</li><li><strong>默认生成的拷贝操作</strong>：如果类未显式定义拷贝构造函数或拷贝赋值运算符，编译器会生成浅拷贝版本。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shallow</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="built_in">Shallow</span>(<span class="type">int</span> val) &#123; data = <span class="keyword">new</span> <span class="built_in">int</span>(val); &#125;</span><br><span class="line">    <span class="comment">// 默认拷贝构造函数和拷贝赋值运算符是浅拷贝</span></span><br><span class="line">    ~<span class="built_in">Shallow</span>() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Shallow <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    Shallow obj2 = obj1; <span class="comment">// 浅拷贝：obj2.data 指向 obj1.data 的地址</span></span><br><span class="line">    *obj1.data = <span class="number">20</span>;     <span class="comment">// 修改 obj1.data 会影响 obj2.data</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;            <span class="comment">// 析构时，同一块内存被 delete 两次 → 崩溃！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="深拷贝（Deep-Copy）"><a href="#深拷贝（Deep-Copy）" class="headerlink" title="深拷贝（Deep Copy）"></a>深拷贝（Deep Copy）</h4><ul><li><strong>行为</strong>：不仅复制对象的成员值，还为指针成员<strong>重新分配内存</strong>，并复制指针指向的完整内容。</li><li><strong>结果</strong>：两个对象的指针成员指向<strong>不同的内存地址</strong>，彼此独立，修改互不影响。</li><li><strong>必须显式实现</strong>：如果类中有动态分配的资源，需手动定义拷贝构造函数和拷贝赋值运算符。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Deep</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span>* data;</span><br><span class="line">    <span class="built_in">Deep</span>(<span class="type">int</span> val) &#123; data = <span class="keyword">new</span> <span class="built_in">int</span>(val); &#125;</span><br><span class="line">    <span class="comment">// 显式定义深拷贝构造函数</span></span><br><span class="line">    <span class="built_in">Deep</span>(<span class="type">const</span> Deep&amp; other) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 重新分配内存并复制值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 显式定义深拷贝赋值运算符</span></span><br><span class="line">    Deep&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Deep&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span> data;             <span class="comment">// 释放原有内存</span></span><br><span class="line">            data = <span class="keyword">new</span> <span class="built_in">int</span>(*other.data); <span class="comment">// 重新分配并复制</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Deep</span>() &#123; <span class="keyword">delete</span> data; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Deep <span class="title">obj1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    Deep obj2 = obj1; <span class="comment">// 深拷贝：obj2.data 指向新内存</span></span><br><span class="line">    *obj1.data = <span class="number">20</span>;  <span class="comment">// obj2.data 的值仍为 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;         <span class="comment">// 析构时各自释放自己的内存 → 无问题</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>默认拷贝构造是浅拷贝，只进行值的复制，包括指针值，并不重新分配内存，只适用于不含动态资源的类</li><li>深拷贝不仅进行值得复制，还会进行动态资源内存的重新分配，不会出现同一内存重复释放。</li></ul><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><ul><li>const常量在定义时必须初始化，之后无法更改</li><li>const形参可以接受const和非const类型的实参</li><li>const成员变量只能在构造函数初始化列表进行初始化，不能在类声明时初始化因为不同对象的const成员值可以不同</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="comment">// 通过构造函数初始化列表初始化 const 成员变量</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>const对象只能调用const成员函数，另外const成员函数只能修改<strong>mutable</strong>修饰的变量</li><li><code>int const</code> 和 <code>const int</code>两种写法是等价的（推荐写法是<code>const int</code>），都表示一个常量整型，因此书写<strong>指针常量</strong>时可以有两种写法<code>int const* p</code> 或者 <code>const int* p</code></li><li><strong>指向常量的常量指针</strong>：<code>int const* const p</code> 和 <code>const int* const p</code></li></ul><h3 id="顶层const和底层const"><a href="#顶层const和底层const" class="headerlink" title="顶层const和底层const"></a>顶层const和底层const</h3><ul><li>顶层const修饰的变量本身是一个常量，例如常量指针；</li><li>底层const指修饰的变量所指对象是一个常量，例如指针常量；</li></ul><h3 id="const函数"><a href="#const函数" class="headerlink" title="const函数"></a>const函数</h3><ul><li><p>在C++中，<strong>成员函数const</strong>是指在成员函数声明的末尾添加<code>const</code>关键字，这表明该成员函数不会修改对象的任何成员变量（mutable除外）。这种函数通常被称为“只读”函数，因为它们不会改变对象的状态。成员函数const的使用不仅提高了代码的可读性，还增强了程序的可靠性，因为编译器会阻止这些函数修改任何成员变量。</p></li><li><p>const成员函数与对象的交互</p><ul><li><p><strong>const对象</strong>只能调用const成员函数，因为非const成员函数可能会修改对象的状态，这与const对象的定义相矛盾。</p></li><li><p><strong>非const对象</strong>可以调用任何成员函数，无论它是否是const。这是因为非const对象没有限制，它们可以被修改。</p></li></ul></li></ul><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><ul><li><p>在普通成员函数中，this是一个指向<strong>非const对象的const指针</strong>（类型为<code>Base</code>，那么this就是<code>Base* const</code>类型的指针）;</p></li><li><p>在const成员函数中，this指针是一个<strong>指向const对象的const指针</strong>（类型为<code>Base</code>，那么this就是<code>const Base* const</code>类型的指针)</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span> arg1)</span></span>;</span><br><span class="line">    <span class="comment">// 相当于 void func(Base *this, float arg1);</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">float</span> arg1)</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 相当于 void func(const Base *this, float arg1);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="struct"><a href="#struct" class="headerlink" title="struct"></a>struct</h2><ul><li>在C++中视为一种特殊的类，默认成员是public，默认继承也是public；</li><li>在C语言中是没有权限控制的，C++中有权限控制；</li><li>C语言中声明了一个结构体之后无法直接使用普通类型的语法创建该结构体，需要添加struct关键字。C++中可以使用普通类型的创建方式创建对象。</li></ul><h3 id="如何计算成员内存偏移量？"><a href="#如何计算成员内存偏移量？" class="headerlink" title="如何计算成员内存偏移量？"></a>如何计算成员内存偏移量？</h3><p><strong>方法一</strong>：成员地址减去结构体对象地址得到内存偏移量</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyStruct s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结构体对象的地址</span></span><br><span class="line">    <span class="type">uintptr_t</span> structAddress = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取结构体成员的地址</span></span><br><span class="line">    <span class="type">uintptr_t</span> memberAddress = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;s.b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算偏移量</span></span><br><span class="line">    <span class="type">uintptr_t</span> offset = memberAddress - structAddress;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Offset of b in MyStruct: &quot;</span> &lt;&lt; offset &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：C++标准库提供了 <code>offsetof</code> 宏，专门用于计算结构体成员的偏移量，无需创建结构体实例。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstddef&gt;</span>  <span class="comment">// for offsetof</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyStruct</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="type">size_t</span> offset = <span class="built_in">offsetof</span>(MyStruct, b);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Offset of b in MyStruct: &quot;</span> &lt;&lt; offset &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数传递结构体名称与参数名称会返回偏移量</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><table><thead><tr><th align="left"><strong>用法</strong></th><th align="left"><strong>作用</strong></th></tr></thead><tbody><tr><td align="left">静态局部变量</td><td align="left">生命周期延长到程序结束，作用域限于函数内部。</td></tr><tr><td align="left">静态全局变量</td><td align="left">作用域限于当前文件，其他文件无法访问。</td></tr><tr><td align="left">静态成员变量</td><td align="left">属于类本身，所有实例共享同一个变量。</td></tr><tr><td align="left">静态成员函数</td><td align="left">属于类本身，只能访问静态成员变量和静态成员函数，可以被非静态成员函数访问。</td></tr></tbody></table><h3 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h3><ul><li>静态成员函数<strong>不隐含this指针参数</strong>，这是它与非静态成员函数的关键区别，没有this指针因此<strong>无法访问成员变量</strong>，只能直接访问静态成员变量和其他静态成员函数。虽然可以通过对象调用静态成员函数，但这只是语法上的便利，实际上<strong>静态成员函数并不属于任何对象</strong>。</li><li>静态成员函数不能被修饰为const函数，因为关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。但是静态成员函数并不单独属于任何一个对象，属于类本身。</li><li>静态成员函数不能被修饰为virtual函数，因为虚函数的调用关系是<strong>this指针-&gt;vptr(4字节）-&gt;vtable -&gt;virtual虚函数</strong>，但是静态成员函数没有this指针</li></ul><h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p><strong>宏定义</strong>是 C&#x2F;C++ 中的一种预处理指令，用于在编译之前对代码进行文本替换。宏定义通过 <code>#define</code> 指令实现，可以用来定义常量、简化代码、实现条件编译等功能。宏定义的本质是<strong>文本替换</strong>，它在编译之前由预处理器处理。</p><h3 id="与const的区别"><a href="#与const的区别" class="headerlink" title="与const的区别"></a>与const的区别</h3><table><thead><tr><th align="left"><strong>特性</strong></th><th align="left"><strong>宏定义</strong></th><th align="left"><strong>常量</strong></th></tr></thead><tbody><tr><td align="left"><strong>类型检查</strong></td><td align="left">无类型检查，纯文本替换。</td><td align="left">有类型检查，类型安全。</td></tr><tr><td align="left"><strong>内存分配</strong></td><td align="left">无内存分配，仅替换</td><td align="left">有内存分配，值无法更改</td></tr><tr><td align="left"><strong>作用域</strong></td><td align="left">无作用域，全局有效（除非 <code>#undef</code>）。</td><td align="left">有作用域，遵循变量作用域规则。</td></tr><tr><td align="left"><strong>调试</strong></td><td align="left">无法直接查看宏的展开结果。</td><td align="left">可以直接查看常量的值。</td></tr><tr><td align="left"><strong>生效阶段</strong></td><td align="left">编译前预处理阶段生效</td><td align="left">编译时生效</td></tr><tr><td align="left"><strong>灵活性</strong></td><td align="left">可以定义带参数的宏。</td><td align="left">只能是固定值。</td></tr></tbody></table><h3 id="与inline区别"><a href="#与inline区别" class="headerlink" title="与inline区别"></a>与inline区别</h3><p><strong>内联函数</strong>是一种常用于提高程序运行效率的函数，其基本思想是在编译阶段将函数调用处用函数体替换，减少函数调用开销</p><table><thead><tr><th><strong>特性</strong></th><th><code>inline</code> 函数</th><th>宏定义（<code>#define</code>）</th></tr></thead><tbody><tr><td><strong>处理阶段</strong></td><td>编译器处理（语法检查、类型安全）</td><td>预处理器处理（文本替换，无语法检查）</td></tr><tr><td><strong>类型检查</strong></td><td>支持参数和返回值的类型检查</td><td>无类型检查（可能引发隐式错误）</td></tr><tr><td><strong>调试</strong></td><td>可调试（有函数符号）</td><td>无法调试（替换后代码不可见）</td></tr><tr><td><strong>作用域</strong></td><td>遵守作用域和命名空间</td><td>全局替换（可能引发命名冲突）</td></tr><tr><td><strong>安全性</strong></td><td>无副作用（参数只计算一次）</td><td>可能因多次展开导致副作用</td></tr><tr><td><strong>适用场景</strong></td><td>替代简单函数，避免调用开销</td><td>条件编译、代码片段复用</td></tr></tbody></table><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p><strong>封装</strong>是将对象的属性和方法隐藏起来，只通过公开的接口与外界进行交互。这样可以保护数据的安全性，防止外部直接访问和修改对象的内部状态。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li><strong>提高代码的可维护性</strong>：内部实现细节对外部隐藏，修改内部实现不会影响外部代码。</li><li><strong>增强数据安全性</strong>：可以通过设置私有属性和方法，控制数据的访问权限</li><li><strong>简化接口</strong>：对外提供简洁的接口，方便使用</li></ul><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><strong>继承</strong>是指一个类（子类）继承另一个类（父类）的属性和方法，从而实现代码的复用。</p><h3 id="好处-1"><a href="#好处-1" class="headerlink" title="好处"></a>好处</h3><ul><li><strong>代码复用</strong>：子类可以复用父类的代码，减少重复代码。</li><li><strong>逻辑层次化</strong>：通过“is-a”关系（如“狗是动物”）组织类结构，使代码更符合现实逻辑。</li><li><strong>支持多态</strong>：为多态的实现提供基础。</li></ul><h3 id="public-protected-private"><a href="#public-protected-private" class="headerlink" title="public &#x2F; protected &#x2F; private"></a>public &#x2F; protected &#x2F; private</h3><p>在 C++ 中，类的继承方式有三种：<strong>public 继承</strong>、<strong>protected 继承</strong> 和 <strong>private 继承</strong>。它们的核心区别在于基类（父类）成员在派生类（子类）中的访问权限变化。</p><p>假设基类 <code>Base</code> 包含三种访问权限的成员：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> publicVar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">publicMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base public method&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> protectedVar = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">protectedMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base protected method&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> privateVar = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">privateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base private method&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三种继承方式的区别"><a href="#三种继承方式的区别" class="headerlink" title="三种继承方式的区别"></a>三种继承方式的区别</h3><h4 id="1-public-继承"><a href="#1-public-继承" class="headerlink" title="(1) public 继承"></a>(1) public 继承</h4><ul><li><strong>语法</strong>：<code>class Derived : public Base &#123; ... &#125;;</code></li><li><strong>规则</strong>：<ul><li>基类的 <code>public</code> 成员 → 在派生类中保持 <code>public</code>。</li><li>基类的 <code>protected</code> 成员 → 在派生类中保持 <code>protected</code>。</li><li>基类的 <code>private</code> 成员 → <strong>不可访问</strong>。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PublicDerived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicVar = <span class="number">10</span>;       <span class="comment">// ✅ 允许访问（public）</span></span><br><span class="line">        protectedVar = <span class="number">20</span>;    <span class="comment">// ✅ 允许访问（protected）</span></span><br><span class="line">        <span class="comment">// privateVar = 30;   // ❌ 不可访问（private）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PublicDerived obj;</span><br><span class="line">    obj.publicVar = <span class="number">100</span>;      <span class="comment">// ✅ 允许访问（public）</span></span><br><span class="line">    <span class="comment">// obj.protectedVar = 200; // ❌ 外部不可访问（protected）</span></span><br><span class="line">    <span class="comment">// obj.privateVar = 300;  // ❌ 不可访问（private）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-protected-继承"><a href="#2-protected-继承" class="headerlink" title="(2) protected 继承"></a>(2) protected 继承</h4><ul><li><strong>语法</strong>：<code>class Derived : protected Base &#123; ... &#125;;</code></li><li><strong>规则</strong>：<ul><li>基类的 <code>public</code> 成员 → 在派生类中变为 <code>protected</code>。</li><li>基类的 <code>protected</code> 成员 → 在派生类中保持 <code>protected</code>。</li><li>基类的 <code>private</code> 成员 → <strong>不可访问</strong>。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ProtectedDerived</span> : <span class="keyword">protected</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicVar = <span class="number">10</span>;       <span class="comment">// ✅ 允许访问（protected）</span></span><br><span class="line">        protectedVar = <span class="number">20</span>;    <span class="comment">// ✅ 允许访问（protected）</span></span><br><span class="line">        <span class="comment">// privateVar = 30;   // ❌ 不可访问（private）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ProtectedDerived obj;</span><br><span class="line">    <span class="comment">// obj.publicVar = 100;   // ❌ 外部不可访问（protected）</span></span><br><span class="line">    <span class="comment">// obj.protectedVar = 200;// ❌ 外部不可访问（protected）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-private-继承"><a href="#3-private-继承" class="headerlink" title="(3) private 继承"></a>(3) private 继承</h4><ul><li><strong>语法</strong>：<code>class Derived : private Base &#123; ... &#125;;</code></li><li><strong>规则</strong>：<ul><li>基类的 <code>public</code> 成员 → 在派生类中变为 <code>private</code>。</li><li>基类的 <code>protected</code> 成员 → 在派生类中变为 <code>private</code>。</li><li>基类的 <code>private</code> 成员 → <strong>不可访问</strong>。</li></ul></li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PrivateDerived</span> : <span class="keyword">private</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">accessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        publicVar = <span class="number">10</span>;       <span class="comment">// ✅ 允许访问（private）</span></span><br><span class="line">        protectedVar = <span class="number">20</span>;    <span class="comment">// ✅ 允许访问（private）</span></span><br><span class="line">        <span class="comment">// privateVar = 30;   // ❌ 不可访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PrivateDerived obj;</span><br><span class="line">    <span class="comment">// obj.publicVar = 100;   // ❌ 外部不可访问（private）</span></span><br><span class="line">    <span class="comment">// obj.protectedVar = 200;// ❌ 外部不可访问（private）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结对比"><a href="#总结对比" class="headerlink" title="总结对比"></a>总结对比</h3><table><thead><tr><th align="left"><strong>继承方式</strong></th><th align="left">基类 <code>public</code> 成员在子类中的权限</th><th align="left">基类 <code>protected</code> 成员在子类中的权限</th><th align="left">基类 <code>private</code> 成员在子类中的权限</th></tr></thead><tbody><tr><td align="left"><strong>public</strong></td><td align="left"><code>public</code></td><td align="left"><code>protected</code></td><td align="left">不可访问</td></tr><tr><td align="left"><strong>protected</strong></td><td align="left"><code>protected</code></td><td align="left"><code>protected</code></td><td align="left">不可访问</td></tr><tr><td align="left"><strong>private</strong></td><td align="left"><code>private</code></td><td align="left"><code>private</code></td><td align="left">不可访问</td></tr></tbody></table><h3 id="关键注意事项"><a href="#关键注意事项" class="headerlink" title="关键注意事项"></a>关键注意事项</h3><ol><li><strong>基类的 <code>private</code> 成员无论何种继承都不可访问</strong>。</li><li><strong>protected 继承和 private 继承会降低基类成员的访问权限</strong>：<ul><li>一般建议使用 <code>public 继承</code>（体现 “is-a” 关系）。</li><li><code>protected/private 继承</code> 通常用于实现细节（类似组合关系）。</li></ul></li><li><strong>实际开发中</strong>：<ul><li>若需要隐藏基类接口，优先使用组合（对象成员）而非 <code>private 继承</code>。</li></ul></li></ol><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><p>某个类不希望被继承或者某个虚函数不希望被重写，可以使用final关键字，无法进行override或者继承</p><h3 id="override"><a href="#override" class="headerlink" title="override"></a>override</h3><p>对父类某个虚函数进行重写时用override修饰，函数名写错时会报错提示</p><p>如果不添加 <code>override</code>，代码仍然可以正常运行，但会失去以下好处：</p><ol><li><strong>可读性</strong>：其他开发者可能不清楚 <code>Derived::show()</code> 是否是重写父类的函数。</li><li><strong>安全性</strong>：如果父类的函数签名发生变化（例如参数类型改变），子类的函数不会报错，可能导致未定义行为。</li></ol><h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多重继承的语法很简单，只需在类定义中用逗号分隔多个基类即可。例如，如果有基类A、B和C，可以这样声明派生类D：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> A, <span class="keyword">private</span> B, <span class="keyword">protected</span> C &#123;</span><br><span class="line"><span class="comment">// 类D新增加的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，D类以公有方式继承A类，以私有方式继承B类，以保护方式继承C类。这意味着D类可以访问A类的公有成员，但不能访问B类和C类的私有成员。</p><h4 id="菱形继承问题及解决方法"><a href="#菱形继承问题及解决方法" class="headerlink" title="菱形继承问题及解决方法"></a>菱形继承问题及解决方法</h4><p>菱形继承是多重继承中的一个特殊情况，其中两个派生类继承自同一个基类，然后又有一个类同时继承这两个派生类。这会导致基类的数据和方法在最终派生类中出现多次，造成资源浪费和潜在的错误。为了解决这个问题，C++提供了虚继承的概念。通过将基类声明为虚基类，可以确保在继承层次结构中只有一个基类实例。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="comment">// 基类A的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="comment">// 派生类B的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="comment">// 派生类C的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;</span><br><span class="line"><span class="comment">// 最终派生类D的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，B和C都虚继承自A，这样在D中就只有一个A的实例。</p><h4 id="虚继承和虚基类"><a href="#虚继承和虚基类" class="headerlink" title="虚继承和虚基类"></a>虚继承和虚基类</h4><ul><li><strong>抽象类是指有纯虚函数的类，而虚基类是指被虚继承的类。</strong>编译器检查，如果发生了菱形继承，但同时两个子类都是虚继承同一个父类，则在最终的子类D中只会保留一份A对象。</li><li><code>D</code>对象的内存布局：<code>B</code>的<code>vbptr</code> + <code>B</code>的成员 + <code>C</code>的<code>vbptr</code> + <code>C</code>的成员 + <code>D</code>的成员 + <strong>唯一的<code>A</code>成员</strong> </li><li>B和C的虚基类表指针指向虚基类表，记录了 <strong>虚基类 <code>A</code> 相对于当前类实例的偏移量</strong>，B和C通过这种方式访问A</li><li>在构造 <code>D</code> 时，<code>A</code> 的构造函数由 <code>D</code> 直接调用（而非通过 <code>B</code> 或 <code>C</code>），确保 <code>A</code> 只初始化一次</li></ul><p>虚继承的主要影响体现在<strong>继承子类的类（D）</strong> 上，而不是直接体现在 <code>B</code> 或 <code>C</code> 上。</p><p>单独的B或C实例，采用与普通继承一样的方式去访问A的成员和函数。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>多态就是允许不同类的对象对同一消息或同一接口做出响应，根据对象的不同而采用不同的行为方式。</p><h3 id="好处-2"><a href="#好处-2" class="headerlink" title="好处"></a>好处</h3><ul><li><strong>接口统一</strong>：用父类指针或引用调用方法，实际执行子类重写的方法。（最重要的）</li><li><strong>灵活扩展</strong>：新增子类时，无需修改使用父类接口的代码。</li><li><strong>解耦设计</strong>：调用方只需依赖抽象接口，而非具体实现，降低模块间耦合度。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src="https://i-blog.csdnimg.cn/blog_migrate/4e0648f1ecdfc6d09ef77ba2f57adf80.png#pic_center" alt="继承和成员对象"></p><ul><li><p>子类<code>Derive</code>的内存实际就是在其父类的后面再添加上自己的内容,需要注意的是编译器在构造<code>Derive</code>对象时会将<code>vptr</code>指向<code>Derive</code>类的<code>vtable</code>而不是基类<code>Base</code>的，该<code>vtable</code>中存储的是<code>Derive</code>的虚函数，包括重写父类的虚函数，也包括此类新添加的虚函数（如<code>unc3</code>)</p></li><li><p>继承并不会添加新的<code>vptr</code>项，而是复用父类的<code>vptr</code>。但如果父类没有虚函数（即没有<code>vptr</code>）则会在该有虚函数的子类后面加<code>vptr</code>项。</p></li><li><p>注意到的基类<code>Base</code>和子类<code>Derive</code>的初始地址相同，这也是为什么可以使用基类指针指向子类。</p></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Derive d;</span><br><span class="line"></span><br><span class="line">Base *p_b = &amp;d;</span><br><span class="line">p_b-&gt;<span class="built_in">func2</span>(<span class="number">1.0</span>); <span class="comment">// 编译器将其转为 (*p_b-&gt;vptr[1])(p_b, 1.0);</span></span><br></pre></td></tr></table></figure><ul><li><p>此例中将<code>Derive</code>对象<code>d</code>赋值给<code>Base</code>类指针<code>p_b</code>，编译器使用该指针时就当作其是一个<code>Base</code>对象，只能访问<code>Base</code>的成员。这没关系，因为<code>Derive</code>对象的内存中前面本来就是一个完整<code>Base</code>对象，各种偏移也和真正的<code>Base</code>对象保持一样，因此这样访问是没问题的。只是无法访问<code>Derive</code>特有的成员而已。（注意到这里只适用于单继承，多继承时编译器还需要调整指针位置来保证此特性）</p></li><li><p>虽然编译器是很无脑的看到<code>Base</code>指针就认为是<code>Base</code>对象，但这里却可以实现多态特性，即调用虚函数时会调用<code>Derive</code>类的版本。前面说到在构造<code>Derive</code>对象时，会将其<code>vptr</code>指向<code>Derive</code>的<code>vtable</code>，现在虽然改为使用<code>Base</code>指针来访问了，但是其<code>vptr</code>依然存的时<code>Derive</code>的<code>vtable</code>的地址。当调用<code>func2</code>时，编译器还是无脑的转换成<code>(*p_b-&gt;vptr[1])(p_b, 1.0)</code>，这里从<code>vptr</code>便会取出<code>Derive</code>的虚函数版本。</p></li><li><p>这就是C++多态的实现原理。归根结底是虽然改变了指针的类型为基类指针，改变了对这块内存的解释方式，但是并没有改变这块内存的内容，而因此<code>vptr</code>的得以保留其子类的<code>vtable</code>地址进而调用子类的函数。</p></li></ul><h3 id="virtual"><a href="#virtual" class="headerlink" title="virtual"></a>virtual</h3><ul><li>在子类中，重写的函数<strong>不需要</strong>再加 <code>virtual</code> 关键字，父类的 <code>virtual</code> 属性会自动继承。即使子类不加 <code>virtual</code>，函数仍然是虚函数。</li><li><code>virtual</code> 关键字的作用：</li></ul><h4 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  <span class="comment">// 使用 virtual 关键字</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;  <span class="comment">// 重写父类的 show() 函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class show()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 基类指针指向子类对象</span></span><br><span class="line">    basePtr-&gt;<span class="built_in">show</span>();  <span class="comment">// 调用子类的 show() 函数</span></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Derived class show()&quot;</span><br></pre></td></tr></table></figure><h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ul><li><code>virtual</code> 关键字使得 <code>show()</code> 函数成为 <strong>虚函数</strong>。</li><li>当基类指针指向子类对象时，调用 <code>show()</code> 会执行子类的实现（动态绑定）。</li><li>如果没有 <code>virtual</code>，<code>basePtr-&gt;show()</code> 会调用基类的 <code>show()</code> 函数（<strong>静态绑定</strong>）。</li></ul><h2 id="初始化与赋值"><a href="#初始化与赋值" class="headerlink" title="初始化与赋值"></a>初始化与赋值</h2><ul><li>如果等号 <code>=</code> 出现在对象<strong>声明</strong>中，则是初始化，调用<strong>拷贝构造函数</strong>（不是拷贝赋值运算符）。</li><li>如果等号 <code>=</code> 出现在对象<strong>已经声明</strong>后的语句中，则是赋值操作，调用赋值运算符函数。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>英文翻译是不稳定的，易变的。<code>volatile</code> 关键字用于告诉编译器，某个变量的值可能会在程序之外被修改（例如硬件寄存器或多线程共享变量），因此编译器不应优化对该变量的访问。系统总是重新从该变量所在的内存中读取它，而不是读取某个寄存器中对这个变量的备份。</p><h2 id="explicit"><a href="#explicit" class="headerlink" title="explicit"></a>explicit</h2><p>只用于修饰类的构造函数，被修饰过的类不能进行隐式的类型转换</p><h2 id="emplace和push"><a href="#emplace和push" class="headerlink" title="emplace和push"></a>emplace和push</h2><ul><li><code>push</code>方法需要先构造好一个对象，然后将这个对象复制或移动到容器中。</li><li><code>emplace</code>方法则是直接在容器内部构造对象，避免了不必要的复制或移动操作。</li></ul><h3 id="i和i"><a href="#i和i" class="headerlink" title="++i和i++"></a>++i和i++</h3><ul><li><p>++i的效率更高，因为i++需要创建临时对象，原对象的值进行修改后，返回临时对象的值；++i直接修改原对象的值并返回引用</p></li><li><p>i++需要调用两次拷贝构造函数与析构函数（将原对象赋给临时对象调用一次，临时对象以值传递方式返回调用一次）</p></li><li><p>++i可以作为左值，i++不能作为左值</p></li></ul><h2 id="new-delete和malloc-free"><a href="#new-delete和malloc-free" class="headerlink" title="new&#x2F;delete和malloc&#x2F;free"></a>new&#x2F;delete和malloc&#x2F;free</h2><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p><code>new</code>操作符的底层行为分为两个阶段：</p><ul><li><strong>调用<code>operator new</code>分配内存，内存大小通过sizeof获取</strong></li><li><strong>调用构造函数初始化对象</strong></li></ul><p><code>operator new</code>核心功能包括内存分配和异常处理，内存分配基于<code>malloc</code>实现</p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><p><code>delete</code>操作符的执行流程与<code>new</code>相反：</p><ul><li><strong>调用析构函数清理资源</strong>：</li><li><strong>调用<code>operator delete</code>释放内存</strong></li></ul><p><code>operator delete</code>核心功能包括内存释放和异常处理，内存释放基于<code>free</code>实现</p><p><strong><code>operator new</code>与<code>operator delete</code>的可重载性</strong>：可以全局重载，也可以类专属重载</p><h3 id="差异与共同点"><a href="#差异与共同点" class="headerlink" title="差异与共同点"></a>差异与共同点</h3><p><strong>类型安全</strong></p><ul><li><code>new</code> 返回与对象类型匹配的指针（如 <code>int*</code>），无需类型转换；</li><li><code>malloc</code> 返回 <code>void*</code>，需强制类型转换，可能导致类型错误</li></ul><p><strong>初始化和析构</strong></p><ul><li><code>new</code> 在分配内存后<strong>自动调用构造函数</strong>，<code>delete</code> 在释放内存前<strong>调用析构函数</strong>；</li><li><code>malloc/free</code> 仅分配和释放内存，不涉及对象的构造与析构</li></ul><p><strong>内存大小计算</strong></p><ul><li><code>new/delete</code> 根据类型自动计算所需内存（如 <code>new int</code> 分配 <code>sizeof(int)</code>）；</li><li><code>malloc/free</code> 需手动指定字节数（如 <code>malloc(sizeof(int))</code>）</li></ul><p><strong>分配失败行为</strong></p><ul><li><code>new</code> 失败时抛出 <code>std::bad_alloc</code> 异常，需通过 <code>try-catch</code> 处理；</li><li><code>malloc</code> 失败时返回 <code>NULL</code>，需显式检查返回值</li></ul><h3 id="delete和delete"><a href="#delete和delete" class="headerlink" title="delete和delete[ ]"></a>delete和delete[ ]</h3><ul><li><code>delete</code>用于释放通过 <code>new</code>分配的<strong>单个对象</strong>的内存。</li><li><code>delete[]</code>用于释放通过 <code>new[]</code> 分配的<strong>对象数组</strong>的内存。</li><li><code>delete[]</code> 会调用数组中 <strong>每个元素的析构函数</strong>，而 <code>delete</code> 只会调用 <strong>第一个元素的析构函数</strong>，导致其他对象的资源泄漏。</li></ul><h2 id="三种new"><a href="#三种new" class="headerlink" title="三种new"></a>三种new</h2><ol><li><p><code>plain new</code>即普通的new</p></li><li><p><code>nothrow new</code>，空间分配失败时不抛出异常而返回空指针的new</p></li><li><p><code>placement new</code>，在已分配的指定内存上重新构造对象或者对象数组</p><p><code>placement new</code>不能简单使用delete进行销毁，因为指定的内存空间可能比构造对象更大</p></li></ol><h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><p><code>vector</code>的底层实现是一个动态数组，它通过连续的内存块存储元素。当元素数量超过当前容量时，<code>vector</code>会自动分配更大的内存块，并将原有元素复制到新内存中</p><h3 id="扩容策略"><a href="#扩容策略" class="headerlink" title="扩容策略"></a>扩容策略</h3><p>当前容量不足以容纳新元素时，<code>vector</code>会申请一块大小为当前容量两倍的新内存，然后将原有元素复制到新内存中，最后释放旧内存 。</p><p><strong>为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用。</strong></p><h3 id="与list的区别"><a href="#与list的区别" class="headerlink" title="与list的区别"></a>与list的区别</h3><ul><li><code>vector</code>是基于数组的动态数组，支持快速随机访问，但在中间插入或删除元素时效率较低O(n)，因为需要移动后续元素。内存连续，缓存友好，动态扩容。</li><li><code>list</code>是基于双向链表的容器，插入和删除效率高，但随机访问效率低O(n)，因为需要遍历链表。内存不连续，缓存不友好，自行控制扩容。</li></ul><h3 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h3><p>当<code>vector</code>进行扩容或插入&#x2F;删除操作时，原有的迭代器可能会失效，因为它们指向的内存可能已经被重新分配或移动</p><h3 id="reserve和resize"><a href="#reserve和resize" class="headerlink" title="reserve和resize"></a>reserve和resize</h3><ul><li><code>reserve</code>只改变<code>vector</code>的容量（<code>capacity</code>），不改变其大小（<code>size</code>）。<code>reserve</code>的空间大小比原空间小不做任何操作。</li><li><code>resize</code>会改变<code>vector</code>的大小（<code>size</code>），并可能初始化新元素。<code>resize</code>的空间大小比原空间小会释放空间。</li></ul><h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><p><code>deque</code>是一种双向开口的连续线性空间，允许在头部和尾部进行<code>O(1)</code>复杂度的插入和删除操作。<code>deque</code>的存储空间由多段等长的连续空间（称为缓冲区）组成，这些缓冲区在内存中并不一定是连续的。为了管理这些缓冲区，<code>deque</code>使用一个称为<code>map</code>的中央控制器。<code>map</code>是一小块连续空间，其中每个元素都是指针，指向一个缓冲区 。结构如图所示：</p><p><img src="http://oss.interviewguide.cn/img/202205220021322.png" alt="img"></p><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p><code>deque</code>的迭代器设计复杂，主要任务是维护“整体连续”的假象，并支持随机访问。迭代器包含以下四个指针：</p><ul><li>**<code>cur</code>**：指向当前元素。</li><li>**<code>first</code>**：指向当前缓冲区的首地址。</li><li>**<code>last</code>**：指向当前缓冲区的尾地址。</li><li>**<code>node</code>**：指向<code>map</code>中当前缓冲区的位置。</li></ul><p><strong>随机访问</strong>：<code>deque</code>通过计算元素在<code>map</code>中的位置和缓冲区中的偏移量来实现随机访问。例如，查找第<code>n</code>个元素时，首先确定它在<code>map</code>中的第几个节点，然后确定在缓冲区中的具体位置</p><h4 id="插入-删除"><a href="#插入-删除" class="headerlink" title="插入&#x2F;删除"></a>插入&#x2F;删除</h4><p>在头部或尾部插入元素时，<code>deque</code>会检查当前缓冲区是否有足够空间。如果空间不足，会申请新的缓冲区并链接到<code>map</code>中。</p><ul><li><p><strong>头部插入</strong>：<code>deque</code>会在头部缓冲区的当前位置（即<code>cur</code>指针指向的位置）插入新元素，并将<code>cur</code>指针向<code>first</code>指针移动&#x2F;靠近。如果头部缓冲区已满，会先申请新的缓冲区，再在新缓冲区的末尾位置插入元素。</p></li><li><p><strong>尾部插入</strong>：<code>deque</code>会在尾部缓冲区的末尾位置（即<code>cur</code>指针指向的位置）插入新元素，并将<code>cur</code>指针向<code>last</code>指针移动&#x2F;靠近。如果头部缓冲区已满，会先申请新的缓冲区，再在新缓冲区的起始位置插入元素。</p></li></ul><blockquote><p>[!Note]</p><p>初始化<code>deque</code>的第一块缓冲区时， <code>_M_start</code> 迭代器与<code>_M_finish</code>迭代器均指向这一块缓冲区，迭代器的<code>cur</code>指向缓冲区的中间位置，执行<code>push_front</code>时在<code>_M_start</code>迭代器的<code>cur</code>位置插入元素并将<code>cur</code>向<code>_M_start</code>迭代器的<code>first</code>靠近；执行<code>push_back</code>时在<code>_M_finish</code>迭代器的<code>cur</code>位置插入元素并将<code>cur</code>向<code>_M_finish</code>迭代器的<code>last</code>靠近</p></blockquote><h2 id="queue-stack"><a href="#queue-stack" class="headerlink" title="queue&#x2F;stack"></a>queue&#x2F;stack</h2><p>准确来说不是容器，是适配器（参考适配器模式）。源码封装了一个<code>_Sequence</code>，是一个模板参数，表示底层容器类型，默认是<code>deque</code></p><ul><li><strong>queue</strong>：<code>push()</code>封装了<code>push_back()</code>，<code>pop()</code>封装了<code>pop_front()</code></li><li><strong>stack</strong>：<code>push()</code>封装了<code>push_back()</code>，<code>pop()</code>封装了<code>pop_back()</code></li></ul><h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>迭代器是C++标准模板库（STL）中用于<strong>统一访问容器元素</strong>的抽象机制。它通过重载指针操作（如<code>++</code>、<code>*</code>、<code>-&gt;</code>等），为不同容器（如<code>vector</code>、<code>list</code>、<code>map</code>）提供一致的遍历接口，同时将算法（如<code>sort</code>、<code>find</code>）与容器实现解耦。</p><h3 id="作用-好处"><a href="#作用-好处" class="headerlink" title="作用 &#x2F; 好处"></a>作用 &#x2F; 好处</h3><ul><li><strong>统一访问方式</strong>：无论容器是数组（<code>vector</code>）还是链表（<code>list</code>），迭代器隐藏底层数据结构差异，提供<code>begin()</code>和<code>end()</code>接口</li><li><strong>算法与容器解耦</strong>：例如<code>std::find</code>可通过迭代器操作任意容器，无需关心其内部实现</li><li><strong>支持泛型编程</strong>：迭代器是模板编程的核心，允许编写与容器无关的代码</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ol><li><strong>输入迭代器（Input Iterator）</strong>：只读且单向遍历（如<code>istream_iterator</code>），支持<code>++</code>和<code>*</code>操作</li><li><strong>输出迭代器（Output Iterator）</strong>：只写且单向遍历（如<code>ostream_iterator</code>），支持<code>++</code>和赋值操作</li><li><strong>前向迭代器（Forward Iterator）</strong>：可读写且单向遍历（如单向链表的迭代器），支持重复访问</li><li><strong>双向迭代器（Bidirectional Iterator）</strong>：可双向移动（如<code>list</code>、<code>map</code>的迭代器），支持<code>++</code>和<code>--</code></li><li><strong>随机访问迭代器（Random Access Iterator）</strong>：支持任意步长跳跃（如<code>vector</code>、<code>deque</code>的迭代器），允许<code>+n</code>、<code>-n</code>及下标访问<code>[index]</code></li></ol><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>迭代器本质是<strong>类模板</strong>，内部封装了指向容器元素的指针或句柄，并通过重载运算符实现类似指针的行为：</p><ul><li><strong>操作符重载</strong>：如<code>operator*()</code>返回元素引用，<code>operator++()</code>移动指针</li><li><strong>类型别名</strong>：STL迭代器通过<code>typedef</code>定义<code>value_type</code>、<code>iterator_category</code>等类型，供算法识别其特性。迭代器本身在容器类内部实现，通常是私有的，使用public别名<code>iterator</code>提供给外部访问</li></ul><h3 id="元素删除-迭代器失效"><a href="#元素删除-迭代器失效" class="headerlink" title="元素删除&#x2F;迭代器失效"></a>元素删除&#x2F;迭代器失效</h3><ul><li><strong>顺序容器</strong>删除了一个迭代器，该迭代器以及之后的所有迭代器均失效，因此不能使用erase(it++)的方式进行迭代器删除，但是erase(it)会返回下一个有效的迭代器，可以基于此进行遍历元素删除。</li><li><strong>关联容器</strong>删除迭代器只有被删除的迭代器会失效，返回值是void，可以采用erase(it++)的方式进行迭代器删除</li></ul><h1 id="C-11新特性"><a href="#C-11新特性" class="headerlink" title="C++11新特性"></a>C++11新特性</h1><h2 id="智能指针"><a href="#智能指针" class="headerlink" title="智能指针"></a>智能指针</h2><p>智能指针是C++11引入的一种解决内存管理问题的方式，它可以自动释放指向的对象，避免内存泄漏。</p><h3 id="RAII自动释放原理"><a href="#RAII自动释放原理" class="headerlink" title="RAII自动释放原理"></a>RAII自动释放原理</h3><p>智能指针类内部包含一个指向动态分配内存的指针。在构造函数中获取资源（如通过<code>new</code>分配内存），在析构函数中释放资源（如通过<code>delete</code>释放内存）。当智能指针对象超出其作用域时（如函数返回或局部变量被销毁），栈内存的管理是自动的，由编译器负责，编译器会自动调用其析构函数。</p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><h4 id="如何保证所有权唯一？"><a href="#如何保证所有权唯一？" class="headerlink" title="如何保证所有权唯一？"></a>如何保证所有权唯一？</h4><p>通过删除拷贝构造与拷贝赋值</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>;         <span class="comment">// 禁用拷贝构造</span></span><br><span class="line">unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr&amp;) = <span class="keyword">delete</span>; <span class="comment">// 禁用拷贝赋值</span></span><br></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><h4 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h4><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Node</span>(<span class="type">const</span> T&amp; value)</span><br><span class="line">:_pPre(<span class="literal">NULL</span>)</span><br><span class="line">, _pNext(<span class="literal">NULL</span>)</span><br><span class="line">, _value(value)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Node</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;~Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this:&quot;</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shared_ptr&lt;Node&lt;T&gt;&gt; _pPre;</span><br><span class="line">shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">T _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funtest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp1</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp2</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">sp1-&gt;_pNext = sp2; <span class="comment">//sp2的引用+1</span></span><br><span class="line">sp2-&gt;_pPre = sp1; <span class="comment">//sp1的引用+1</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">Funtest</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//Node()</span></span><br><span class="line"><span class="comment">//sp1.use_count:1</span></span><br><span class="line"><span class="comment">//sp2.use_count:1</span></span><br><span class="line"><span class="comment">//sp1.use_count:2</span></span><br><span class="line"><span class="comment">//sp2.use_count:2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p><code>sp1</code> 和 <code>sp2</code> 的生命周期结束，<code>Node(1)</code> 和 <code>Node(2)</code> 的引用计数各减 1。</p></li><li><p><strong>最终状态</strong>：</p><ul><li><code>sp1</code> 和 <code>sp2</code> 被析构了，但是<code>Node(1)</code> 和 <code>Node(2)</code> 的内存没能被释放，因为指向<code>Node(1)</code> 和 <code>Node(2)</code> 的智能指针引用计数不为0，当<code>use_count</code>归0时，<code>shared_ptr</code>管理的对象会被销毁，其占用的内存也会被释放。</li><li><code>Node(1)</code> 的引用计数 &#x3D; 1（因为 <code>Node(2)</code> 的 <code>_pPre</code> 指向它）。</li><li><code>Node(2)</code> 的引用计数 &#x3D; 1（因为 <code>Node(1)</code> 的 <code>_pNext</code> 指向它）。</li></ul></li><li><p>引用计数无法归零 → 内存泄漏。</p></li><li><p><strong><code>sp1</code> 和 <code>sp2</code> 管理的是不同对象</strong>：</p><ul><li><code>sp1</code> 管理 <code>Node(1)</code>，<code>sp2</code> 管理 <code>Node(2)</code>。</li><li><code>sp2</code> 析构只会减少 <code>Node(2)</code> 的引用计数，与 <code>Node(1)</code> 无关。</li></ul></li></ul><p><strong>解决方案</strong>：</p><p>使用 <code>weak_ptr</code>（弱引用）替代其中一个 <code>shared_ptr</code>。<code>weak_ptr</code> 不会增加引用计数，从而打破循环依赖。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">const</span> T&amp; value) : _value(value) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>() &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;~Node()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Node&lt;T&gt;&gt; _pNext;</span><br><span class="line">    weak_ptr&lt;Node&lt;T&gt;&gt; _pPre; <span class="comment">// 将其中一个改为 weak_ptr</span></span><br><span class="line">    T _value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funtest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp1</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>));</span><br><span class="line">    shared_ptr&lt;Node&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sp2</span>(<span class="keyword">new</span> <span class="built_in">Node</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    sp1-&gt;_pNext = sp2;  <span class="comment">// Node(2) 引用计数 +1 → 2</span></span><br><span class="line">    sp2-&gt;_pPre = sp1;   <span class="comment">// Node(1) 引用计数不变 → 1</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp1.use_count:&quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 1</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sp2.use_count:&quot;</span> &lt;&lt; sp2.<span class="built_in">use_count</span>() &lt;&lt; endl;  <span class="comment">// 输出 2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Funtest</span>();</span><br><span class="line">    <span class="comment">// 函数结束时：</span></span><br><span class="line">    <span class="comment">// 1. sp2 析构 → Node(2) 引用计数 -1 → 1</span></span><br><span class="line">    <span class="comment">// 2. sp1 析构 → Node(1) 引用计数 -1 → 0 → 调用 ~Node(1)</span></span><br><span class="line">    <span class="comment">// 3. Node(1) 析构时，其 _pNext（shared_ptr）析构 → Node(2) 引用计数 -1 → 0 → 调用 ~Node(2)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="built_in">Node</span>()</span><br><span class="line"><span class="built_in">Node</span>()</span><br><span class="line">sp1.use_count:<span class="number">1</span></span><br><span class="line">sp2.use_count:<span class="number">2</span></span><br><span class="line">~<span class="built_in">Node</span>()</span><br><span class="line">~<span class="built_in">Node</span>()</span><br></pre></td></tr></table></figure><ol><li>**将 <code>_pPre</code> 改为 <code>weak_ptr</code>**：<ul><li><code>weak_ptr</code> 不会增加 <code>Node(1)</code> 的引用计数。</li><li><code>Node(1)</code> 的引用计数始终为 1（仅由 <code>sp1</code> 持有）。</li></ul></li><li><strong>析构顺序</strong>：<ul><li><code>sp1</code> 析构 → <code>Node(1)</code> 引用计数归零 → 调用 <code>~Node(1)</code>。</li><li><code>Node(1)</code> 析构时，其 <code>_pNext</code>（<code>shared_ptr&lt;Node(2)&gt;</code>）析构 → <code>Node(2)</code> 引用计数减 1 → 归零 → 调用 <code>~Node(2)</code>。</li></ul></li></ol><h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>依赖关联的 <code>shared_ptr</code>，指向 <code>shared_ptr</code> 管理的对象，但不增加引用计数。用于解决循环引用问题</p><h4 id="如何判断指向对象是否存活？"><a href="#如何判断指向对象是否存活？" class="headerlink" title="如何判断指向对象是否存活？"></a>如何判断指向对象是否存活？</h4><p><code>weak_ptr</code>通过其内部数据结构与<code>shared_ptr</code>的控制块（Control Block）协同工作，判断指向对象是否存活。</p><ol><li><p>通过<code>expired()</code>方法：</p><ul><li><strong>原理</strong>：检查控制块的<strong>强引用计数（<code>_Uses</code>）是否为0</strong>。若为0，表示所有<code>shared_ptr</code>已释放，对象被销毁。</li></ul></li><li><p>通过<code>lock()</code>方法</p><ul><li><strong>原理</strong>：尝试将<code>weak_ptr</code>提升为<code>shared_ptr</code>，若提升成功则对象存活。</li></ul></li></ol><p><strong>控制块的销毁时机</strong></p><ul><li><strong>对象销毁</strong>：当强引用计数（<code>_Uses</code>）减为0时，调用<code>_Destroy()</code>销毁被管理对象。</li><li><strong>控制块销毁</strong>：当弱引用计数（<code>_Weaks</code>）也减为0时，调用<code>_Delete_this()</code>销毁控制块自身</li></ul><h3 id="是否存在shared-ptr引用计数归零，内存已释放，weak-ptr仍指向该内存导致内存泄漏的情况？"><a href="#是否存在shared-ptr引用计数归零，内存已释放，weak-ptr仍指向该内存导致内存泄漏的情况？" class="headerlink" title="是否存在shared_ptr引用计数归零，内存已释放，weak_ptr仍指向该内存导致内存泄漏的情况？"></a>是否存在<code>shared_ptr</code>引用计数归零，内存已释放，<code>weak_ptr</code>仍指向该内存导致内存泄漏的情况？</h3><p>不存在，<code>weak_ptr</code>在STL的设计中无法直接访问内存，需要先通过<code>lock()</code>函数提升为<code>shared_ptr</code>才能访问该内存，<code>lock()</code>函数在强引用计数为0时会返回空的<code>shared_ptr</code>，即无法将<code>weak_ptr</code>提升为<code>shared_ptr</code>因此不会导致内存泄漏。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; weak;</span><br><span class="line">&#123;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; shared = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    weak = shared;</span><br><span class="line">&#125; <span class="comment">// shared 离开作用域，对象被销毁</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> shared = weak.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">    std::cout &lt;&lt; *shared &lt;&lt; std::endl; <span class="comment">// 不会执行，因为对象已销毁</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;对象已销毁&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出：对象已销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="强制转换（cast）"><a href="#强制转换（cast）" class="headerlink" title="强制转换（cast）"></a>强制转换（cast）</h2><h3 id="dynamic-cast"><a href="#dynamic-cast" class="headerlink" title="dynamic_cast"></a>dynamic_cast</h3><p><code>dynamic_cast</code> 是一种用于处理继承体系中类型安全向下转型（downcasting）和交叉转型（cross-casting）的操作符。它依赖于<strong>运行时类型信息（RTTI, Run-Time Type Information）</strong>，能够在运行时检查对象类型是否与目标类型兼容，从而确保转换的安全性。</p><ol><li><strong>向下转型</strong>：将基类指针&#x2F;引用转换为派生类指针&#x2F;引用。</li><li><strong>交叉转型</strong>：在多重继承中，将指向一个基类的指针&#x2F;引用转换为另一个基类的指针&#x2F;引用。</li></ol><h4 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>dynamic_cast</code> 的核心机制依赖于 <strong>RTTI</strong> 和 <strong>虚函数表（vtable）</strong>。</p><ol><li><strong>RTTI 和虚函数表</strong>：</li></ol><ul><li><strong>RTTI 结构</strong>：每个多态类型（至少有一个虚函数的类）的虚函数表中会包含一个指向其 <code>type_info</code> 对象的指针。<code>type_info</code> 存储了类的名称和继承关系信息。</li><li><strong>运行时类型检查</strong>：当执行 <code>dynamic_cast</code> 时，编译器生成的代码会通过对象的 <code>type_info</code> 检查类型兼容性。</li></ul><ol start="2"><li><strong>类型兼容性检查</strong>：</li></ol><ul><li><strong>单继承</strong>：直接比较目标类型的 <code>type_info</code> 是否与对象的实际类型（基类指针指向派生类，将基类指针转换为派生类指针）或其基类一致（将基类指针转换为另一个基类指针）。</li><li><strong>多重继承&#x2F;虚继承</strong>：需要遍历继承树，检查目标类型是否在继承路径中。如果存在多个基类子对象，可能需要调整指针偏移量。</li></ul><h4 id="RTTI应用场景"><a href="#RTTI应用场景" class="headerlink" title="RTTI应用场景"></a>RTTI应用场景</h4><ol><li><strong>运行时类型检查</strong>：通过 <code>typeid</code> 判断对象的实际类型，执行不同的逻辑</li><li><strong>安全类型转换</strong>：使用 <code>dynamic_cast</code> 在多态场景下安全地转换类型</li></ol><h4 id="向下转型行为"><a href="#向下转型行为" class="headerlink" title="向下转型行为"></a>向下转型行为</h4><p>如果检查通过，返回有效的派生类指针&#x2F;引用；否则返回 <code>nullptr</code>（指针）或抛出 <code>std::bad_cast</code> 异常（引用）。</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><ol><li><strong>安全的向下转型</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">   </span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">Derived* derived_ptr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base_ptr);  <span class="comment">// 安全转换</span></span><br></pre></td></tr></table></figure><p>目标类型是Derived，实际类型也是Derived，因此转换成功</p><ol start="2"><li><strong>处理多重继承中的交叉转型</strong>：</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base1* base1_ptr = <span class="keyword">new</span> Derived;</span><br><span class="line">Base2* base2_ptr = <span class="built_in">dynamic_cast</span>&lt;Base2*&gt;(base1_ptr);</span><br></pre></td></tr></table></figure><ul><li><code>base1_ptr</code> 指向 <code>Derived</code> 对象中的 <code>Base1</code> 子对象。</li><li><code>dynamic_cast</code> 需要将指针从 <code>Base1</code> 子对象的位置调整到 <code>Base2</code> 子对象的起始位置。</li><li>这种调整是通过 RTTI 中的偏移信息实现的。</li></ul><h3 id="static-cast"><a href="#static-cast" class="headerlink" title="static_cast"></a>static_cast</h3><p><code>static_cast</code> 是一种显式类型转换运算符，用于在<strong>编译时</strong>进行类型转换。它适用于相关类型之间的转换，依赖编译器的静态类型检查，不涉及运行时类型信息（RTTI）。</p><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>基本数据类型转换（如 <code>int</code> → <code>double</code>，<code>float</code> → <code>int</code>）。</li><li>类层次结构中的 <strong>上行转换</strong>（派生类指针&#x2F;引用 → 基类指针&#x2F;引用）。</li><li>用户自定义类型转换（通过转换构造函数或类型转换运算符）。</li><li>将 <code>void*</code> 转换为具体类型的指针。</li><li>枚举类型与整数类型之间的转换。</li></ul><h4 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h4><ul><li><code>static_cast</code> 在编译时完成所有类型检查，不涉及运行时开销。</li><li>编译器会验证源类型（<code>source</code>）和目标类型（<code>TargetType</code>）是否具有<strong>隐式转换关系</strong>或<strong>明确的转换路径</strong>。</li></ul><p>向下转换（downcasting）时，<code>dynamic_cast</code> 和 <code>static_cast</code> 编译都能正常通过：</p><ul><li><code>dynamic_cast</code> 编译器只会检查源类型和目标类型是不是多态类型（至少有一个虚函数），运行失败会返回nullptr或者抛出异常</li><li><code>static_cast</code>编译器只会检查源类型和目标类型之间存在某种转换关系（如继承关系）。</li></ul><h3 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a>const_cast</h3><p><code>const_cast</code>是用于移除对象的<code>const</code>或<code>volatile</code>限定符的类型转换运算符。它主要<strong>用于指针和引用的类型转换</strong>，允许修改原本被声明为<code>const</code>的变量。这种转换通常在需要对<code>const</code>对象进行写操作时使用，但必须非常小心，因为修改<code>const</code>对象是未定义行为，可能会导致程序错误。</p><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><ol><li><strong>编译时操作</strong></li></ol><ul><li><code>const_cast</code> 是一种<strong>编译时操作</strong>，不涉及运行时开销。</li><li>它仅仅修改编译器对类型的解释方式，而不改变对象的底层二进制表示。</li></ul><ol start="2"><li><strong>类型检查</strong></li></ol><ul><li>编译器会检查源类型（<code>source</code>）和目标类型（<code>TargetType</code>）是否除了 <code>const</code> 或 <code>volatile</code> 限定符外完全相同。</li><li>如果类型不匹配（例如 <code>int*</code> 转换为 <code>double*</code>），编译器会报错。</li></ul><ol start="3"><li><strong>底层实现</strong></li></ol><ul><li><code>const_cast</code> 不会生成额外的机器指令。</li><li>它只是告诉编译器：“忽略 <code>const</code> 或 <code>volatile</code> 限定符，将指针&#x2F;引用视为目标类型”。</li></ul><h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li><code>const_cast</code>不能用来修改声明为常量的数据，会产生未定义行为。但是可以用来移除指针常量和引用常量的const，用来修改非常量的值。<strong>即只能作用于底层const，不能作用于顶层const。</strong></li><li>当我们调用第三方库和一些API时，它们需要使用非<code>const</code>形式的数据，但我们只有<code>const</code>形式数据时候才能使用<code>const_cast</code>。</li></ul><h3 id="reinterpret-cast"><a href="#reinterpret-cast" class="headerlink" title="reinterpret_cast"></a>reinterpret_cast</h3><ul><li><strong>reinterpret_cast</strong> 是 C++ 中的一个类型转换运算符，它用于在不同类型之间进行低级转换，通常是为了对数据的二进制表示进行重新解释。这种转换不会改变原始数据的比特位，但会改变数据的类型。</li><li>通常可用于将地址转化为整数类型，计算地址偏移量（不做类型检查，只检查变量大小匹配）。</li></ul><h4 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h4><ul><li><code>reinterpret_cast</code> 是一种编译时操作，不涉及运行时开销。</li><li>它仅仅告诉编译器：“将源类型的内存表示重新解释为目标类型”</li><li><code>reinterpret_cast</code> 几乎不进行类型检查。只要源类型和目标类型的大小兼容，转换就是合法的。</li></ul><h2 id="模板元编程"><a href="#模板元编程" class="headerlink" title="模板元编程"></a>模板元编程</h2><h3 id="类型萃取（TODO）"><a href="#类型萃取（TODO）" class="headerlink" title="类型萃取（TODO）"></a>类型萃取（TODO）</h3><p><strong>类型萃取（Type Traits）</strong> 是C++模板元编程的核心技术，用于在编译时提取或操作类型的特性（如是否可拷贝、是否有特定成员函数等）。而 <strong>迭代器萃取（Iterator Traits）</strong> 是类型萃取的一种具体应用，专门用于获取迭代器的相关类型信息（如元素类型、迭代器类别等），以支持泛型算法的统一操作</p><h4 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h4><ul><li>检查类型属性：例如判断类型是否为指针、是否可移动构造等。</li><li>修改类型属性：例如移除引用（<code>remove_reference&lt;T&gt;</code>）、添加常量（<code>add_const&lt;T&gt;</code>）等。</li><li>类型关系判断：例如判断两个类型是否相同（<code>is_same&lt;T, U&gt;</code>）</li></ul><h2 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h2><h3 id="左右值定义"><a href="#左右值定义" class="headerlink" title="左右值定义"></a>左右值定义</h3><ul><li>C++03标准，把具有标识（identity）的表达式规定为左值，不具有标识的表达式规定为右值。因而，名字、指针、引用等是左值，是命名对象，<strong>具有确定的内存地址</strong>；字面量、临时对象等为右值，右值仅在创建它的表达式中可以被访问。</li><li>C++11标准分成左值（lvalue），将亡值（xvalue）和纯右值(prvalue)，将右值拆分成将亡值和纯右值。在C++11，对于值的分类，要考虑标识（identity）与可移动性（movability）。<ul><li>左值lvalue：可以用取地址运算符&amp;获取地址的表达式。也可定义为非临时对象或非成员函数。具有标识，但不可移动。</li><li>将亡值（xvalue）：具有标识，并且可以移动。对应的对象接近生存期结束，但其内容尚未被移走。例如：函数返回的右值引用，static_cast&lt;T&amp;&amp;&gt;进行的左值到右值引用的转换。</li><li>纯右值prvalue：不具有标识，但可以移动。对应临时对象或不对应任何对象的值。</li></ul></li></ul><blockquote><p>[!Note]</p><p>具有标识的右值引用被定义为左值</p></blockquote><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>右值引用</strong>是C++11引入的一种新的引用类型，用于引用右值。右值引用使用<code>&amp;&amp;</code>符号声明，可以绑定到右值。右值引用的主要目的是支持<strong>移动语义</strong>，这是一种资源管理技术，允许资源从临时对象转移到另一个对象，而不是进行复制。</p><h3 id="介绍一下右值引用"><a href="#介绍一下右值引用" class="headerlink" title="介绍一下右值引用"></a>介绍一下右值引用</h3><p>在C++中值通常被分为左值和右值，左值是具有标识并且可以用取地址运算符获取地址的表达式或变量，右值通常是字面量、临时对象等不可重复使用的表达式。<strong>右值引用</strong>是C++11引入的一种新的引用类型，用于匹配右值，主要是为了解决资源管理效率和性能优化的问题。右值引用允许我们标记某些对象为“可以移动”，而不是只能拷贝。比如，在处理一些临时对象或者即将销毁的对象时，我们可以通过右值引用直接“转移”它们的资源，而不是复制一份，这样可以避免不必要的开销。</p><h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>完美转发的实现依赖于<code>万能引用</code>+<code>引用折叠</code>+<code>std::forward</code>，协同实现完美转发功能</p><h3 id="万能引用（Universal-Reference）"><a href="#万能引用（Universal-Reference）" class="headerlink" title="万能引用（Universal Reference）"></a>万能引用（Universal Reference）</h3><p><strong>定义</strong>： 万能引用是指模板函数中形如 <code>T&amp;&amp;</code> 的参数，它既可以绑定到左值，也可以绑定到右值。其核心特性是能够根据传入参数的类型自动推导出 <code>T</code> 的类型，从而决定 <code>T&amp;&amp;</code> 是左值引用还是右值引用。</p><p><strong>原理</strong>：</p><ul><li>当传入左值时，<code>T</code> 被推导为 <code>T&amp;</code>，根据引用折叠规则，<code>T&amp; &amp;&amp;</code> 折叠为 <code>T&amp;</code>，即左值引用。</li><li>当传入右值时，<code>T</code> 被推导为 <code>T&amp;&amp;</code>，<code>T&amp;&amp; &amp;&amp;</code> 折叠为 <code>T&amp;&amp;</code>，即右值引用。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// t 可以是左值引用或右值引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(x);  <span class="comment">// x 是左值，T 推导为 int&amp;</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 10 是右值，T 推导为 int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引用折叠（Reference-Collapsing）"><a href="#引用折叠（Reference-Collapsing）" class="headerlink" title="引用折叠（Reference Collapsing）"></a>引用折叠（Reference Collapsing）</h3><p><strong>定义</strong>： 引用折叠是C++中的一种规则，用于处理“引用的引用”情况。当模板参数推导或类型别名中产生引用的引用时，编译器会根据规则将其折叠为单一引用。</p><p><strong>规则</strong>：</p><ul><li><code>T&amp; &amp;</code> → <code>T&amp;</code></li><li><code>T&amp; &amp;&amp;</code> → <code>T&amp;</code></li><li><code>T&amp;&amp; &amp;</code> → <code>T&amp;</code></li><li><code>T&amp;&amp; &amp;&amp;</code> → <code>T&amp;&amp;</code></li></ul><p><strong>原理</strong>： 引用折叠是万能引用的基础。通过引用折叠，<code>T&amp;&amp;</code> 可以根据传入参数的类型推导出正确的引用类型。</p><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据传入参数类型，T&amp;&amp; 折叠为 T&amp; 或 T&amp;&amp;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">func</span>(x);  <span class="comment">// T 推导为 int&amp;，int&amp; &amp;&amp; 折叠为 int&amp;</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// T 推导为 int&amp;&amp;，int&amp;&amp; &amp;&amp; 折叠为 int&amp;&amp;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h3><p><strong>定义</strong>： 完美转发是指在函数模板中将参数以原始的左值或右值属性传递给另一个函数。其目的是在多层函数调用中保持参数的左值或右值特性。</p><p><strong>原理</strong>： 完美转发依赖于万能引用和 <code>std::forward</code> 函数。<code>std::forward</code> 根据模板参数 <code>T</code> 的类型决定是否保留参数的左值或右值属性：</p><ul><li>如果 <code>T</code> 是左值引用，<code>std::forward</code> 返回左值引用。</li><li>如果 <code>T</code> 是右值引用，<code>std::forward</code> 返回右值引用。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将参数 t 完美转发给 func</span></span><br><span class="line">    <span class="built_in">func</span>(std::forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Lvalue\n&quot;</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Rvalue\n&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x);  <span class="comment">// 调用 func(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">10</span>); <span class="comment">// 调用 func(int&amp;&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现机制</strong>： <code>std::forward</code> 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span></span><br><span class="line"><span class="function">  _GLIBCXX_NODISCARD</span></span><br><span class="line"><span class="function">  <span class="keyword">constexpr</span> _Tp&amp;&amp;</span></span><br><span class="line"><span class="function">  <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p>通过 <code>static_cast</code>，<code>std::forward</code> 将参数 <code>t</code> 转换为正确的左值或右值引用类型 </p><h3 id="三者的关系"><a href="#三者的关系" class="headerlink" title="三者的关系"></a>三者的关系</h3><ul><li><strong>万能引用</strong>：通过 <code>T&amp;&amp;</code> 和引用折叠规则，可以同时绑定左值和右值。</li><li><strong>引用折叠</strong>：是万能引用的基础，用于处理引用的引用情况。</li><li><strong>完美转发</strong>：依赖万能引用和 <code>std::forward</code>，确保参数在传递过程中保持其原始的左值或右值属性。</li></ul><p>通过这三者的结合，C++11实现了高效的参数传递机制，避免了不必要的拷贝和移动操作</p><h3 id="完美转发解决的问题"><a href="#完美转发解决的问题" class="headerlink" title="完美转发解决的问题"></a>完美转发解决的问题</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有完美转发的包装函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(t);  <span class="comment">// 直接传递 t，丢失了右值属性</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x);  <span class="comment">// 传入左值，调用 process(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">10</span>); <span class="comment">// 传入右值，调用 process(int&amp;)，而不是 process(int&amp;&amp;)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述示例中，由于变量t在wrapper函数中是一个具名变量，因此尽管传入右值，类型是int&amp;&amp;，但是值类别是左值，函数重载会绑定到void process(int&amp; x)。基于此，得出一个结论：<strong>函数重载的选择值类别匹配优先级高于类型匹配</strong>。</p><p>使用完美转发可以解决上述问题：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Lvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span>&amp;&amp; x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Rvalue: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wrapper</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">process</span>(std::forward&lt;T&gt;(t));  <span class="comment">// 完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">wrapper</span>(x);  <span class="comment">// 传入左值，调用 process(int&amp;)</span></span><br><span class="line">    <span class="built_in">wrapper</span>(<span class="number">10</span>); <span class="comment">// 传入右值，调用 process(int&amp;&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// Lvalue: 10</span></span><br><span class="line"><span class="comment">// Rvalue: 10</span></span><br></pre></td></tr></table></figure><h2 id="移动构造函数"><a href="#移动构造函数" class="headerlink" title="移动构造函数"></a>移动构造函数</h2><p>移动构造函数是 C++11 引入的一种特殊构造函数，用于将资源（如动态内存、文件句柄等）从一个对象“移动”到另一个对象，而不是复制。它通过<strong>右值引用</strong>（<code>&amp;&amp;</code>）实现，通常用于优化性能。</p><h3 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">        data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(str) + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(data, str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动构造函数</span></span><br><span class="line">    <span class="built_in">MyString</span>(MyString&amp;&amp; other) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">        data = other.data;  <span class="comment">// 接管资源</span></span><br><span class="line">        other.data = <span class="literal">nullptr</span>;  <span class="comment">// 将原对象的资源置为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 析构函数</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">str1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    MyString str2 = std::<span class="built_in">move</span>(str1);  <span class="comment">// 调用移动构造函数</span></span><br><span class="line"></span><br><span class="line">    str1.<span class="built_in">print</span>();  <span class="comment">// 输出空（资源已被移动）</span></span><br><span class="line">    str2.<span class="built_in">print</span>();  <span class="comment">// 输出 &quot;Hello&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>std::move()</code>调用移动构造函数</p><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a><strong>关键点</strong></h3><ol><li><p><strong>右值引用</strong>：</p><p>移动构造函数使用右值引用（<code>&amp;&amp;</code>）作为参数，表示可以“窃取”临时对象的资源。</p></li><li><p><strong>资源移动</strong>：</p><p>移动构造函数将资源从源对象（<code>other</code>）移动到当前对象，避免不必要的复制。</p></li><li><p><strong>性能优化</strong>：</p><p>移动构造函数通常用于管理动态内存、文件句柄等资源，避免深拷贝的开销。</p></li><li><p>**<code>noexcept</code>**：</p><p>移动构造函数通常标记为 <code>noexcept</code>，表示不会抛出异常，以便在标准库中优化性能。</p></li></ol><h3 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    _GLIBCXX_NODISCARD</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function">    <span class="title">move</span><span class="params">(_Tp&amp;&amp; <span class="type">__t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> std::remove_reference&lt;_Tp&gt;::type&amp;&amp;&gt;(<span class="type">__t</span>); &#125;</span><br></pre></td></tr></table></figure><p>参数接受一个万能引用，使用<code>std::remove_reference</code>去除引用，使得最终参数类型变成<code>T &amp;&amp;</code>类型的右值引用，从而保证可以被移动</p><h3 id="移动过后的对象生命周期在什么时候结束？"><a href="#移动过后的对象生命周期在什么时候结束？" class="headerlink" title="移动过后的对象生命周期在什么时候结束？"></a>移动过后的对象生命周期在什么时候结束？</h3><p>资源被转移但是生命周期不发生改变，仍然在它原本的作用域结束时结束。</p><h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>委托构造函数是 C++11 引入的特性，允许一个构造函数调用同一个类中的另一个构造函数，从而避免代码重复。</p><h3 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a><strong>示例</strong></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 主构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">double</span> y) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Primary constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">MyClass</span>(x, <span class="number">0.0</span>) &#123;  <span class="comment">// 委托给主构造函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Delegating constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b = &quot;</span> &lt;&lt; b &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="number">10</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="number">20</span>)</span></span>;  <span class="comment">// 调用委托构造函数</span></span><br><span class="line"></span><br><span class="line">    obj1.<span class="built_in">print</span>();  <span class="comment">// 输出 &quot;a = 10, b = 3.14&quot;</span></span><br><span class="line">    obj2.<span class="built_in">print</span>();  <span class="comment">// 输出 &quot;a = 20, b = 0&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a><strong>关键点</strong></h3><ol><li><p><strong>代码重用</strong>：</p><p>委托构造函数可以调用同一个类中的其他构造函数，避免重复代码。</p></li><li><p><strong>初始化顺序</strong>：</p><p>委托构造函数会先调用被委托的构造函数，然后再执行自己的函数体。</p></li><li><p><strong>适用场景</strong>：</p><p>当一个类有多个构造函数，且某些构造函数的逻辑可以复用时，可以使用委托构造函数。</p></li></ol><h2 id="Lambda表达式（匿名函数对象）"><a href="#Lambda表达式（匿名函数对象）" class="headerlink" title="Lambda表达式（匿名函数对象）"></a>Lambda表达式（匿名函数对象）</h2><p>在C++中，匿名函数通常指的是Lambda表达式，它是C++11标准中引入的一种功能，允许我们定义和使用没有具体名称的函数对象。Lambda表达式的主要用途是<strong>简化代码</strong>，特别是在需要使用简短函数但不想单独定义一个函数时。Lambda表达式也使得<strong>代码更加紧凑和可读</strong>，因为它允许我们直接在代码中定义一个函数的行为，而不是在别处。Lambda表达式的基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[capture](parameters) <span class="keyword">mutable</span> -&gt; return_type &#123; body &#125;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>capture</strong> 是捕获列表，用于指定Lambda表达式可以访问的外部变量，以及是否通过值或引用来捕获它们。</li><li><strong>parameters</strong> 是参数列表，与普通函数的参数列表类似。</li><li><strong>mutable</strong> 关键字用于指定Lambda表达式可以修改通过值捕获的变量。</li><li><strong>return_type</strong> 是返回类型，如果Lambda表达式的返回类型可以自动推断，则可以省略。</li><li><strong>body</strong> 是Lambda表达式的函数体，包含了表达式的执行代码。</li></ul><p>Lambda表达式只能捕获父作用域的局部变量或形参，不能捕获全局变量或静态变量。捕获全局变量时编译器提示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;var&#x27; cannot be captured because it does not have automatic storage duration</span><br></pre></td></tr></table></figure><p>捕获方式可以是值捕获（通过值传递），也可以是引用捕获（通过引用传递）。例如：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lambda = [x]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125;; <span class="comment">// 值捕获</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lambda_ref = [&amp;x]() &#123; <span class="keyword">return</span> x + <span class="number">1</span>; &#125;; <span class="comment">// 引用捕获</span></span><br></pre></td></tr></table></figure><ul><li>在上述例子中，第一个Lambda表达式通过值捕获变量x，而第二个通过引用捕获x。值得注意的是，如果Lambda表达式被声明为mutable，那么即使是通过值捕获，Lambda表达式也可以修改捕获的变量（但不会影响外部变量本身，引用捕获会影响）。</li><li>这里的lambda只是Lambda表达式的别名，它依然是一个匿名类，由编译器进行转换</li></ul><h3 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h3><p>编译器实现 <strong>lambda 表达式</strong>大致分为以下几个步骤：</p><ol><li>创建 <strong>lambda匿名类</strong>，实现构造函数，使用 lambda 表达式的函数体重载 **operator()**（所以 lambda 表达式 也叫匿名函数对象）</li><li>创建 lambda 对象</li><li>通过对象调用 <strong>operator()</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode日常刷题总结</title>
      <link href="/2024/10/09/3158dd3ea568/"/>
      <url>/2024/10/09/3158dd3ea568/</url>
      
        <content type="html"><![CDATA[<p>本文记录了在LeetCode练习中针对部分题目的思路与题解。</p><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="912-排序数组"><a href="#912-排序数组" class="headerlink" title="912. 排序数组"></a><a href="https://leetcode.cn/problems/sort-an-array/">912. 排序数组</a></h2><h3 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>nums</code>，请你将该数组升序排列。</p><p>你必须在 <strong>不使用任何内置函数</strong> 的情况下解决问题，时间复杂度为 <code>O(nlog(n))</code>，并且空间复杂度尽可能小。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,2,3,1]</span><br><span class="line">输出：[1,2,3,5]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,1,1,2,0,0]</span><br><span class="line">输出：[0,0,1,1,2,5]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5 * 104</code></li><li><code>-5 * 104 &lt;= nums[i] &lt;= 5 * 104</code></li></ul><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p><strong>思路</strong></p><ul><li><p>快速排序由两部分构成，quickSort作为主体，通过递归的方式进行排序，partition辅助函数返回一个元素在数组中排序后的下标</p></li><li><p>采用分治的思想，通过选择一个基准元素（pivot），将列表分为两部分：一部分小于基准元素，另一部分大于基准元素，然后递归地对这两部分进行排序</p></li></ul><p><strong>细节</strong></p><p>多看多写几次吧</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 选取中间元素</span></span><br><span class="line">        <span class="type">int</span> pivot = nums[(begin + end) / <span class="number">2</span>];</span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[(begin + end) / <span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> le = begin + <span class="number">1</span>, ge = end;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (le &lt;= ge) &#123;</span><br><span class="line">            <span class="comment">// 第一个大于等于的</span></span><br><span class="line">            <span class="keyword">while</span> (le &lt;= ge &amp;&amp; nums[le] &lt; pivot)</span><br><span class="line">                ++le;</span><br><span class="line"><span class="comment">// 第一个小于等于的</span></span><br><span class="line">            <span class="keyword">while</span> (le &lt;= ge &amp;&amp; nums[ge] &gt; pivot)</span><br><span class="line">                --ge;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (le &lt;= ge) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[le], nums[ge]);</span><br><span class="line">                ++le;</span><br><span class="line">                --ge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ge跳出循环时nums[ge] &lt;= pivot</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[begin], nums[ge]);</span><br><span class="line">        <span class="keyword">return</span> ge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> begin, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (begin &lt;= end) &#123;</span><br><span class="line">            <span class="type">int</span> pivotIndex = <span class="built_in">partition</span>(nums, begin, end);</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, begin, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">quickSort</span>(nums, pivotIndex + <span class="number">1</span>, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">quickSort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="二进制中有多少个1"><a href="#二进制中有多少个1" class="headerlink" title="二进制中有多少个1"></a><a href="https://www.nowcoder.com/practice/8ee967e43c2c4ec193b040ea7fbb10b8">二进制中有多少个1</a></h2><h3 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h3><p><strong>描述</strong></p><p>输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p><p>数据范围：−231&lt;&#x3D;n&lt;&#x3D;231−1−231&lt;&#x3D;<em>n</em>&lt;&#x3D;231−1</p><p>即范围为:−2147483648&lt;&#x3D;n&lt;&#x3D;2147483647−2147483648&lt;&#x3D;<em>n</em>&lt;&#x3D;2147483647</p><p><strong>示例1</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">十进制中10的32位二进制表示为0000 0000 0000 0000 0000 0000 0000 1010，其中有两个1。       </span><br></pre></td></tr></table></figure><p><strong>示例2</strong></p><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">负数使用补码表示 ，-1的32位二进制表示为1111 1111 1111 1111 1111 1111 1111 1111，其中32个1    </span><br></pre></td></tr></table></figure><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ol><li>将1进行左移，每次进行与运算，正负数都可以使用</li><li>使用n &amp; (n - 1)可以每次消除最低位的1，循环直至n为0，可以统计二进制中所有1的个数</li></ol><p><strong>细节</strong></p><p>负数右移会出现高位1补位，循环可能无法终止，使用左移或者n &amp; (n - 1)可以避免</p><p><strong>代码</strong></p><ol><li>左移</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(count &lt; <span class="number">32</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(n &amp; i)</span><br><span class="line">                ++ans;</span><br><span class="line">            ++count;</span><br><span class="line">            i = i &lt;&lt; <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>n &amp; (n - 1)</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><h3 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h3><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意</strong> ，必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [0]</span><br><span class="line">输出: [0]</span><br></pre></td></tr></table></figure><p><strong>提示</strong>:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><p><strong>进阶：</strong>你能尽量减少完成的操作次数吗？</p><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>所有0移动到数组尾部并且基于原数组，换个说法就是将非0元素移动到前面，统计非0元素数目可以得到应该置0的数目</p><p><strong>细节</strong></p><p>注意count值的更新不要越界</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num != <span class="number">0</span>)</span><br><span class="line">                nums[count++] = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(count &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            nums[count++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><h3 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>nums</code> ，判断是否存在三元组 <code>[nums[i], nums[j], nums[k]]</code> 满足 <code>i != j</code>、<code>i != k</code> 且 <code>j != k</code> ，同时还满足 <code>nums[i] + nums[j] + nums[k] == 0</code> 。请你返回所有和为 <code>0</code> 且不重复的三元组。</p><p><strong>注意：</strong>答案中不可以包含重复的三元组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br><span class="line">解释：</span><br><span class="line">nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。</span><br><span class="line">nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。</span><br><span class="line">nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。</span><br><span class="line">不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。</span><br><span class="line">注意，输出的顺序和三元组的顺序并不重要。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,1]</span><br><span class="line">输出：[]</span><br><span class="line">解释：唯一可能的三元组和不为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,0,0]</span><br><span class="line">输出：[[0,0,0]]</span><br><span class="line">解释：唯一可能的三元组和为 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= nums.length &lt;= 3000</code></li><li><code>-105 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>要找三个和为0的数，最笨的办法就是三重循环，如果先进行排序，则可以跳过重复值从而减少循环遍历次数</li><li>当最外层循环<code>nums[i]</code>确定下来，<code>nums[j]</code>与<code>nums[k]</code>的和随之确定下来为<code>target = -nums[i]</code></li><li>两层循环可以用双指针更改为一层循环，因为<code>target</code>已经确定，<code>left</code>设置为<code>i + 1</code>，<code>right</code>设置为<code>nums.size() - 1</code>，如果<code>sum = nums[l] + nums[r] == target</code>则找到答案之一，跳过重复元素继续寻找；如果<code>sum &gt; target</code>则需要让<code>sum</code>减小，<code>left</code>向右移只会让<code>sum</code>增大，因此应该把<code>right</code>向左移；如果<code>sum &lt; target</code>则需要让<code>sum</code>增大，<code>left</code>向右移会让<code>sum</code>增大</li></ul><p><strong>细节</strong></p><p>总而言之，言而总之，首先将数组变成有序的，当最外层循环确定当前元素时，target值就完成了锁定，双指针进行潜在答案的遍历，判断出sum与左右指针移动方向的关联</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 先排序</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 跳过重复元素</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 双指针，目标是找到 nums[l] + nums[r] = -nums[i]</span></span><br><span class="line">            <span class="type">int</span> l = i + <span class="number">1</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> target = -nums[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">                <span class="type">int</span> sum = nums[l] + nums[r];</span><br><span class="line">                <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">                    <span class="comment">// 这里用push_back更快</span></span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i], nums[l], nums[r]&#125;);</span><br><span class="line">                    ++l;</span><br><span class="line">                    --r;</span><br><span class="line">                    <span class="comment">// 跳过重复元素</span></span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[l] == nums[l - <span class="number">1</span>])</span><br><span class="line">                        ++l;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; nums[r] == nums[r + <span class="number">1</span>])</span><br><span class="line">                        --r;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) &#123;</span><br><span class="line">                    ++l;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    --r;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><h3 id="题干-4"><a href="#题干-4" class="headerlink" title="题干"></a>题干</h3><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长 子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>滑动窗口动态维护最大值，当end右移时需要判断是否此前已有重复字符，因此需要哈希表（可以用数组代替）</li><li>如果有重复字符则以start为起始的字符串的无重复字符的最长子串是从start到end - 1，需要更新start判断新的起点是否存在更长子串</li></ul><p><strong>细节</strong></p><p>本题除了字母外，字符串由数字、符号和空格组成，因此不能用长度大小26的数组，得用128的数组（基本ASCII码128个）</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">bool</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; end &lt; s.<span class="built_in">size</span>(); ++end) &#123;</span><br><span class="line">            <span class="comment">// 此前出现过当前字符</span></span><br><span class="line">            <span class="keyword">while</span> (hash[s[end]]) &#123;</span><br><span class="line">                <span class="comment">// 推进起始位置直到当前字符不在子串中</span></span><br><span class="line">                hash[s[start]] = <span class="literal">false</span>;</span><br><span class="line">                ++start;</span><br><span class="line">            &#125;</span><br><span class="line">            hash[s[end]] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (end - start + <span class="number">1</span> &gt; ans)</span><br><span class="line">                ans = end - start + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h1><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和*"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和*</a></h2><h3 id="题干-5"><a href="#题干-5" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong>是数组中的一个连续部分。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出：6</span><br><span class="line">解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,4,-1,7,8]</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong>如果你已经实现复杂度为 <code>O(n)</code> 的解法，尝试使用更为精妙的 <strong>分治法</strong> 求解。</p><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>动态规划思路：判断沿用之前的连续数组还是从当前位置重新开始，如果此前的数组和小于0，舍弃并从当前位置开始建立新的；否则将当前位置纳入数组和当中</li><li>前缀和：维护当前的最小前缀和，当前位置的前缀和与最小前缀和的差就是以当前位置结尾的最大子数组和，动态更新这个值即可</li></ul><p><strong>细节</strong></p><ul><li>容易产生的误区：当前位置如果是小于0的，将它加入到连续数组中不是会让值变小吗？</li><li>解答：确实会变小，但是答案并不是最终的<code>dp</code>，而是通过<code>ans</code>实时与<code>dp</code>比较进行维护，因为最大值可以出现在中间的任意一段。</li></ul><p><strong>代码</strong></p><ol><li>动态规划</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> dp = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-10001</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                dp = dp + num;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp = num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (dp &gt; ans) &#123;</span><br><span class="line">                ans = dp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>前缀和</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前缀和</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">-10001</span>;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> minSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>&amp; num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            ans = <span class="built_in">max</span>(sum - minSum, ans);</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; minSum) &#123;</span><br><span class="line">                minSum = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Ax-By-Cz-Dw-N-的最小字典序解"><a href="#Ax-By-Cz-Dw-N-的最小字典序解" class="headerlink" title="Ax + By + Cz + Dw &#x3D; N 的最小字典序解"></a>Ax + By + Cz + Dw &#x3D; N 的最小字典序解</h2><h3 id="题干-6"><a href="#题干-6" class="headerlink" title="题干"></a>题干</h3><p>给定一个方程<code>Ax + By + Cz + Dw = N</code>，输入<code>A，B，C，D，N</code>，其中<code>A，B，C，D，N</code>均为正整数，<code>x，y，z，w</code>的范围是<code>0-2500</code>求字典序最小的<code>x，y，z，w</code>解，无解输出<code>-1</code>。</p><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>暴力三重循环 + 整除，$2500^3$会超时，可以将问题分解，求出<code>Cz + Dw</code>的和并且用哈希表存储z和w的值，注意按字典序</li><li>两重循环求出<code>N - Ax + By</code>的值，查找哈希表，顺序遍历可以保证找的第一个解是字典序最小的</li></ul><p><strong>细节</strong></p><p>注意哈希表存储的<code>key</code>是<code>sum</code>，不同的<code>z</code>和<code>w</code>可能对应相同的<code>sum</code>，基于最小字典序的要求，只需存储第一次的<code>value</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findSolution</span><span class="params">(<span class="type">int</span> A, <span class="type">int</span> B, <span class="type">int</span> C, <span class="type">int</span> D, <span class="type">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 哈希表存储 Ax + By 的值及其对应的 (x, y)</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; hashMap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举 z 和 w</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> z = <span class="number">0</span>; z &lt;= <span class="number">2500</span>; z++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w = <span class="number">0</span>; w &lt;= <span class="number">2500</span>; w++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = C * z + D * w;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; N) <span class="keyword">break</span>; <span class="comment">// 剪枝：后续 w 的枚举无意义</span></span><br><span class="line">            <span class="keyword">if</span> (hashMap.<span class="built_in">count</span>(sum)) <span class="keyword">continue</span>; <span class="comment">// 选取字典序最小的解</span></span><br><span class="line">            hashMap[sumAB] = &#123;z, w&#125;; <span class="comment">// 存储 Cz + Dw 的值及其对应的 (z, w)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举 x 和 y</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt;= <span class="number">2500</span>; x++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y = <span class="number">0</span>; y &lt;= <span class="number">2500</span>; y++) &#123;</span><br><span class="line">            <span class="type">int</span> sumCD = A * x + B * y;</span><br><span class="line">            <span class="keyword">if</span> (sumCD &gt; N) <span class="keyword">break</span>; <span class="comment">// 剪枝：后续 y 的枚举无意义</span></span><br><span class="line">            <span class="keyword">if</span> (hashMap.<span class="built_in">count</span>(N - sumCD)) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [z, w] = hashMap[N - sumCD];</span><br><span class="line">                cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; z &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl; <span class="comment">// 如果没有找到解</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> A, B, C, D, N;</span><br><span class="line">    cin &gt;&gt; A &gt;&gt; B &gt;&gt; C &gt;&gt; D &gt;&gt; N;</span><br><span class="line">    <span class="built_in">findSolution</span>(A, B, C, D, N);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&envId=2024-spring-sprint-100">48 旋转图像</a></h2><h3 id="题干-7"><a href="#题干-7" class="headerlink" title="题干"></a>题干</h3><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li><p>问题转换成矩阵左上角进行旋转，每一次交换4个数据的位置，增加一个中间临时变量来完成交换。</p></li><li><p>问题关键在于左上角的定义，偶数不用赘述；矩阵边长为奇数时，取前n &#x2F; 2行，前(n + 1) &#x2F; 2列。以示例1为例，即(1, 2)视作左上角的矩阵。</p></li></ul><p><strong>细节</strong></p><p>实现时要思考清楚矩阵中的交换元素，可以结合实例去验证判断。最终是交换matrix [i] [j]和matrix [n - j -1] [i]，接下来把n - j -1代入i，i代入j得到后续的交换下标即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> row = n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> col = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j <span class="number">-1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i <span class="number">-1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i <span class="number">-1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i <span class="number">-1</span>];</span><br><span class="line">            matrix[j][n - i <span class="number">-1</span>]= temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="402-移掉k位数字"><a href="#402-移掉k位数字" class="headerlink" title="402 移掉k位数字"></a><a href="https://leetcode.cn/problems/remove-k-digits/description/?envType=study-plan-v2&envId=2024-spring-sprint-100">402 移掉k位数字</a></h2><h3 id="题干-8"><a href="#题干-8" class="headerlink" title="题干"></a>题干</h3><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><p><strong>示例 1 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;1432219&quot;, k = 3</span><br><span class="line">输出：&quot;1219&quot;</span><br><span class="line">解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</span><br></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;10200&quot;, k = 1</span><br><span class="line">输出：&quot;200&quot;</span><br><span class="line">解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;10&quot;, k = 2</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：从原数字移除所有的数字，剩余为空就是 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= num.length &lt;= 105</code></li><li><code>num</code> 仅由若干位数字（0 - 9）组成</li><li>除了 <strong>0</strong> 本身之外，<code>num</code> 不含任何前导零</li></ul><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>数字或者字母排序可以构建单调栈来保持顺序，遍历整个字符串，当遇到字符小于栈顶字符时弹栈直至栈空或大于栈顶字符。移除过程中可能会出现移除的字母数小于k，但字符串已经是从小到大排序的了，此时仅需要取字符串的前num.size() - k位并删除前导0即可。</p><p><strong>细节</strong></p><p>循环条件是重点，while(k !&#x3D; 0 &amp;&amp; !s.empty() &amp;&amp; s[s.size()-1]  &gt;  c)即还有字符没有删除、栈不为空、当前字符小于栈顶字符时执行弹栈。</p><p>另外string可以用来当栈使用，pop_back()函数可实现stack.pop()一样的效果</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n - k;</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : num) &#123;</span><br><span class="line">            <span class="keyword">while</span>(k!=<span class="number">0</span> &amp;&amp; !s.<span class="built_in">empty</span>() &amp;&amp; s[s.<span class="built_in">size</span>()<span class="number">-1</span>] &gt; c) &#123;</span><br><span class="line">                s.<span class="built_in">pop_back</span>();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            s += c;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, res);</span><br><span class="line">        <span class="comment">// 消除前导0</span></span><br><span class="line">        <span class="keyword">while</span>(s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.<span class="built_in">size</span>()!=<span class="number">1</span>) &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><h3 id="题干-9"><a href="#题干-9" class="headerlink" title="题干"></a>题干</h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5]</span><br><span class="line">输出：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = [1,2]</span><br><span class="line">输出：[2,1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><p><strong>进阶：</strong>链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？</p><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>维护<code>prev</code>、<code>cur</code>、<code>next</code>三个指针，依次修改指向，顺序是<code>prev</code>、<code>cur</code>、<code>next</code></p><ol><li><code>cur</code>不为空的情况下<code>next</code>指向<code>cur</code>的next</li><li><code>cur</code>的next指向<code>prev</code>，将<code>prev</code>指向<code>cur</code></li><li>将<code>cur</code>指向<code>next</code></li><li>循环1、2、3</li></ol><p><strong>细节</strong></p><ul><li>循环条件是<code>cur</code>不为空，<code>next</code>不需要预先设置，根据<code>cur</code>的情况设置<code>next</code></li><li>循环跳出时<code>cur</code>为空，<code>prev</code>指向“头节点”</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存*"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存*</a></h2><h3 id="题干-10"><a href="#题干-10" class="headerlink" title="题干"></a>题干</h3><p>请你设计并实现一个满足 <a href="https://baike.baidu.com/item/LRU">LRU (最近最少使用) 缓存</a> 约束的数据结构。</p><p>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以 <strong>正整数</strong> 作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该 <strong>逐出</strong> 最久未使用的关键字。</li></ul><p>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</p><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</span><br><span class="line">[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1, null, -1, null, -1, 3, 4]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">LRUCache lRUCache = new LRUCache(2);</span><br><span class="line">lRUCache.put(1, 1); // 缓存是 &#123;1=1&#125;</span><br><span class="line">lRUCache.put(2, 2); // 缓存是 &#123;1=1, 2=2&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 1</span><br><span class="line">lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 &#123;1=1, 3=3&#125;</span><br><span class="line">lRUCache.get(2);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 &#123;4=4, 3=3&#125;</span><br><span class="line">lRUCache.get(1);    // 返回 -1 (未找到)</span><br><span class="line">lRUCache.get(3);    // 返回 3</span><br><span class="line">lRUCache.get(4);    // 返回 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 105</code></li><li>最多调用 <code>2 * 105</code> 次 <code>get</code> 和 <code>put</code></li></ul><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>LRU缓存首先要满足缓存的快速查找（<strong>哈希表</strong>），其次要经常修改、删除、插入（<strong>双向链表</strong>），这些要求让我们应该使用这两种数据结构</li><li>梳理功能然后判断应该需要哪些<strong>函数</strong>和<strong>成员</strong><ul><li><strong>成员</strong>：首先缓存本身需要容量和当前大小（<code>int</code>）；接着需要一个哈希表用于查找（<code>unordered_map</code>）哈希表的<code>key</code>就是查找的键，<code>value</code>应该是双向链表中的节点；另外需要维护一个双向链表，用于插入、修改、删除（<code>list</code>，但是通常面试时要自己实现，实现一个节点结构体包含前置和后置节点指针即可）；因为要经常更新节点的位置，移动到头部或者直接从尾部删除，因此创建虚拟head和tail更好，自此全部成员已确定</li><li><strong>函数</strong>：缓存没满，在链表首插入即可；缓存满了，链表首插入同时移除尾部。没有查到，返回<code>-1</code>；查到了将节点移动到首部（<code>moveToHead</code>），返回节点的val。因此需要一个添加到头部的函数（<code>addToHead</code>），移动到首部和移除尾部（<code>removeTail</code>）实际上都需要移除操作，但是移动到首部可以转化为移除（<code>remove</code>）+添加到头部实现复用，至此全部函数已确定</li></ul></li></ul><p><strong>细节</strong></p><ul><li>移除节点要处理前置和后置两个节点的联系</li><li>真正删除节点的只有<code>removeTail</code>，因此需要返回值释放内存</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* pre;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() &#123;</span><br><span class="line">        key = <span class="number">0</span>;</span><br><span class="line">        val = <span class="number">0</span>;</span><br><span class="line">        pre = <span class="literal">nullptr</span>;</span><br><span class="line">        next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _key, <span class="type">int</span> _val) &#123;</span><br><span class="line">        key = _key;</span><br><span class="line">        val = _val;</span><br><span class="line">        pre = <span class="literal">nullptr</span>;</span><br><span class="line">        next = <span class="literal">nullptr</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, Node*&gt; cache;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    Node* dummyHead;</span><br><span class="line">    Node* dummyTail;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> _capacity) : <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        dummyHead = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        dummyTail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">        dummyHead-&gt;next = dummyTail;</span><br><span class="line">        dummyTail-&gt;pre = dummyHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.<span class="built_in">count</span>(key)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">moveToHead</span>(cache[key]);</span><br><span class="line">        <span class="keyword">return</span> cache[key]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!cache.<span class="built_in">count</span>(key)) &#123;</span><br><span class="line">            Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">            <span class="built_in">addToHead</span>(node);</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="keyword">if</span>(size &gt; capacity) &#123;</span><br><span class="line">                Node* node = <span class="built_in">removeTail</span>();</span><br><span class="line">                <span class="comment">// 需要从哈希表里擦除因此removeTail需要Node*类型的返回值</span></span><br><span class="line">                cache.<span class="built_in">erase</span>(node-&gt;key);</span><br><span class="line">                --size;</span><br><span class="line">                <span class="keyword">delete</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cache[key]-&gt;val = value;</span><br><span class="line">            <span class="built_in">moveToHead</span>(cache[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addToHead</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;next = dummyHead-&gt;next;</span><br><span class="line">        node-&gt;pre = dummyHead;</span><br><span class="line">        dummyHead-&gt;next-&gt;pre = node;</span><br><span class="line">        dummyHead-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveToHead</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="built_in">addToHead</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node* <span class="title">removeTail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node* node = dummyTail-&gt;pre;</span><br><span class="line">        <span class="built_in">removeNode</span>(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeNode</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;pre-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;pre = node-&gt;pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=2024-spring-sprint-100">94 二叉树的中序遍历</a></h2><h3 id="题干-11"><a href="#题干-11" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>递归；迭代需要依托栈，入栈直到为空，出栈并添加到返回向量中</p><p><strong>实现</strong></p><p>若输出方式是ACM模式，不需要额外创建中间函数，在inorderTraversal函数中调用标准输出流即可；若输出方式是核心代码模式，则需要另外创建一个向量存储返回结果，并创建一个中间函数用于更新结果向量。</p><p><strong>代码</strong></p><p>递归：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代：</p><p>迭代的第一个循环条件是当前节点为空或者栈为空则结束循环。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="comment">// 当前处理节点不为空或者待处理节点不为空</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 找到最左</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = s.<span class="built_in">top</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        cur = cur -&gt; right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><h3 id="题干-12"><a href="#题干-12" class="headerlink" title="题干"></a>题干</h3><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li><p>节点的左子树只包含<strong>小于</strong>当前节点的数。</p></li><li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p></li><li><p>所有左子树和右子树自身必须也是二叉搜索树。</p></li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，因此可以通过判断中序遍历的结果是否升序来判断是不是BST</li></ul><p><strong>细节</strong></p><p>上下界的递归，基本框架就是<code>return judge(root, (long) INT_MIN - 1, (long) INT_MAX + 1)</code>，这一部分很容易想。难点在于上下界的界定，左子树无下界，只有上界；右子树无下界，只有上届。</p><p><strong>代码</strong></p><ol><li><strong>中序遍历</strong>判断是否递增</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// -(2^31+1) 宏是INT_MIN</span></span><br><span class="line">    <span class="comment">// long prev = (long) (1&lt;&lt;31) - 1;</span></span><br><span class="line">    <span class="type">long</span> prev = (<span class="type">long</span>) INT_MIN - <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= prev) &#123;</span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            prev = root-&gt;val;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p><strong>INT_MIN</strong>是CPP中的最小整数值-2147483648的宏，也可以用1&lt;&lt;31表示，但是要做减法运算需要转换为<strong>long</strong>类型</p></blockquote><ol start="2"><li><strong>上下界</strong>递归</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(TreeNode* root, <span class="type">long</span> low, <span class="type">long</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= low || root-&gt;val &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(root-&gt;left, low, root-&gt;val) &amp;&amp; <span class="built_in">judge</span>(root-&gt;right, root-&gt;val, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(root, (<span class="type">long</span>) INT_MIN - <span class="number">1</span>, (<span class="type">long</span>) INT_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><h3 id="题干-13"><a href="#题干-13" class="headerlink" title="题干"></a>题干</h3><p>给你一个二叉树的根节点 <code>root</code> ， 检查它是否轴对称。</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1698026966-JDYPDU-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,3,4,4,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://pic.leetcode.cn/1698027008-nPFLbM-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,2,null,3,null,3]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[1, 1000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><p><strong>进阶：</strong>你可以运用递归和迭代两种方法解决这个问题吗？</p><h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>对称需要保证左子节点和右子节点同时为空，若不同时为空则两个都不能为空，并且值需要相等，此外<strong>左子节点的左子树与右子节点的右子树应该相同</strong>，<strong>左子节点的右子树与右子节点的左子树应该相同</strong></li><li>递归的返回条件是判断传入节点值是否相等（包括同时为空），通过传入的参数来控制左子树和右子树的选择</li></ul><p><strong>细节</strong></p><p>多看几遍，记住不要中序回文</p><p><strong>代码</strong></p><p>递归判断<strong>左子节点的左子树与右子节点的右子树是否相同</strong>，<strong>左子节点的右子树与右子节点的左子树是否相同</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* l, TreeNode* r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l &amp;&amp; !r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!l || !r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> l-&gt;val == r-&gt;val &amp;&amp; <span class="built_in">check</span>(l-&gt;left, r-&gt;right) &amp;&amp;</span><br><span class="line">               <span class="built_in">check</span>(l-&gt;right, r-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left, root-&gt;right); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="230-二叉搜索树中第-K-小的元素"><a href="#230-二叉搜索树中第-K-小的元素" class="headerlink" title="230. 二叉搜索树中第 K 小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第 K 小的元素</a></h2><h3 id="题干-14"><a href="#题干-14" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数为 <code>n</code> 。</li><li><code>1 &lt;= k &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>BST的中序遍历是递增的，符合题目要求</p><p><strong>细节</strong></p><p>用数组存储中序遍历结果即可，看清楚k的定义，这里选取<code>array[k-1]</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; array;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        array.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> array[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><h3 id="题干-15"><a href="#题干-15" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>root &#x3D; [1,2,3,null,5,null,4]</p><p><strong>输出：</strong>[1,3,4]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png" alt="img"></p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>root &#x3D; [1,2,3,4,null,null,null,5]</p><p><strong>输出：</strong>[1,3,4,5]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png" alt="img"></p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>root &#x3D; [1,null,3]</p><p><strong>输出：</strong>[1,3]</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>root &#x3D; []</p><p><strong>输出：</strong>[]</p><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>参照题目意思，右视图的定义应该使用<strong>层序遍历</strong>去解决，每一层节点直接有优先级，优先级关系为：<code>右右&gt;右左&gt;左右&gt;左左</code></p><p><strong>细节</strong></p><p>层序遍历使用<strong>队列</strong>实现，内循环条件基于队列的大小，本题中队列末尾对应最右侧的节点</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 顺序 右右 右左 左右 左左 层序遍历 队列</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; q;</span><br><span class="line">            q.<span class="built_in">push</span>(root);</span><br><span class="line">            TreeNode* cur = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                len = q.<span class="built_in">size</span>();</span><br><span class="line">                cur = q.<span class="built_in">back</span>();</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                    cur = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><h3 id="题干-16"><a href="#题干-16" class="headerlink" title="题干"></a>题干</h3><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>不考虑空间限制的情况下，按照<strong>先序遍历</strong>的方式将节点指针用数组存储，再迭代数组替换为右节点并清空左节点即可</p><p><strong>细节</strong></p><p>先序遍历时根节点也会被加入到vec中，进行展开链表的构建时需要跳过它</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flattenHelper</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">emplace_back</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">flattenHelper</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">flattenHelper</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">flattenHelper</span>(root);</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cur-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            cur-&gt;right = vec[i];</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><h3 id="题干-17"><a href="#题干-17" class="headerlink" title="题干"></a>题干</h3><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>思路1是通过递归拆分成左子树和右子树的构建，进而转化为<code>preorder</code>和<code>inorder</code>子数组的划分，缺点是<code>cpp</code>实现不方便</p><p>思路2不划分子数组，而是通过明确子数组的边界来代替切分，缺点是参数多，容易混淆</p><p><strong>细节</strong></p><p><code>python</code>数组切片冒号前面的包括，后面的不包括；另外需要判断<code>preorder</code>和<code>inorder</code>是否为空，若为空则表示无法构建子树，返回<code>None</code></p><p><code>cpp</code>实现可以建立一个哈希表，便于查找根节点在<code>inorder</code>数组中的下标；左子树的size可以根据<code>inorder</code>根节点的下标与<code>inorder</code>左边界进行计算</p><p><strong>代码</strong></p><ol><li>子数组&#x2F;数组切片递归，<code>python</code>子数组实现更方便</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTreeHelper</span>(<span class="params">self, preorder, inorder</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(inorder):</span><br><span class="line">            <span class="keyword">if</span> inorder[left] == preorder[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            left = left + <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">        right = <span class="built_in">len</span>(inorder) - <span class="number">1</span> - left</span><br><span class="line">        <span class="comment"># pre:[1, left+1] in:[0, left]</span></span><br><span class="line">        root.left = self.buildTreeHelper(preorder[<span class="number">1</span>:left+<span class="number">1</span>], inorder[<span class="number">0</span>:left])</span><br><span class="line">        <span class="comment"># pre:[left+1, end] in:[left+1, end]</span></span><br><span class="line">        root.right = self.buildTreeHelper(preorder[left+<span class="number">1</span>:], inorder[left+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: Optional[TreeNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTreeHelper(preorder, inorder)</span><br></pre></td></tr></table></figure><ol start="2"><li><code>cpp</code>解法，通过明确先序数组和中序数组的边界来代替数组切片</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span> inLeft,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> inRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inRight &lt; inLeft)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preLeft]);</span><br><span class="line">        <span class="type">int</span> rootIndex = index[preorder[preLeft]];</span><br><span class="line">        <span class="type">int</span> leftSize = rootIndex - inLeft;</span><br><span class="line">        <span class="comment">// 先序边界[preLeft + 1, preLeft + leftSize] 中序边界[inLeft, rootIndex - 1]  </span></span><br><span class="line">        root-&gt;left =</span><br><span class="line">            <span class="built_in">buildTreeHelper</span>(preorder, inorder, preLeft + <span class="number">1</span>,</span><br><span class="line">                            preLeft + leftSize, inLeft, rootIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 先序边界[preLeft + 1 + leftSize, preRight] 中序边界[rootIndex + 1, inRight]</span></span><br><span class="line">        root-&gt;right =</span><br><span class="line">            <span class="built_in">buildTreeHelper</span>(preorder, inorder, preLeft + <span class="number">1</span> + leftSize,</span><br><span class="line">                            preRight, rootIndex + <span class="number">1</span>, inRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTreeHelper</span>(preorder, inorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                               inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2><h3 id="题干-18"><a href="#题干-18" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</span><br><span class="line">输出：3</span><br><span class="line">解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,1000]</code></li><li><code>-109 &lt;= Node.val &lt;= 109</code> </li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>根据题目意思容易想到搜索每一条路径，统计和为<code>targetsum</code>的路径。使用递归的思想先构建辅助函数，求出以指定节点作为根节点时，经过该根节点同时节点值和为<code>targetsum</code>的路径数目，再双重递归将每一个节点作为根节点并求和</p><p><strong>细节</strong></p><p>双重递归很容易混淆，需要理清思路和结构；</p><p><code>pathSumHelper</code>函数中的<code>targetSum</code>参数要使用<code>long</code>类型，因为<code>root-&gt;val</code>的范围是<code>-10^9 &lt;= Node.val &lt;= 10^9</code> ，超过了<code>int</code>的范围</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSumHelper</span><span class="params">(TreeNode* root, <span class="type">long</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pathSumHelper</span>(root-&gt;left, targetSum - root-&gt;val) +</span><br><span class="line">                   <span class="built_in">pathSumHelper</span>(root-&gt;right, targetSum - root-&gt;val) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pathSumHelper</span>(root-&gt;left, targetSum - root-&gt;val) +</span><br><span class="line">                   <span class="built_in">pathSumHelper</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">pathSumHelper</span>(root, targetSum);</span><br><span class="line">        ans += <span class="built_in">pathSum</span>(root-&gt;left, targetSum);</span><br><span class="line">        ans += <span class="built_in">pathSum</span>(root-&gt;right, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><h3 id="题干-19"><a href="#题干-19" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>两个节点分别位于左右子树时，说明当前节点是最近祖先；递归的终止条件：如果当前节点为空或者为<code>p</code> 或 <code>q</code>，则返回当前节点，如果只有一方为空则说明两个节点都位于这个子树，返回它的递归结果即可。</p><blockquote><p>[!Note]</p><p>根据递归终止条件，实际上结果是自底向上的，因此满足<strong>深度尽可能大</strong>这一要求</p></blockquote><p><strong>细节</strong></p><p>比较特别的递归终止条件，需要结合理解去记忆</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 两个节点分别位于左右子树时 说明当前节点是最近祖先</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left? left:right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><h3 id="题干-20"><a href="#题干-20" class="headerlink" title="题干"></a>题干</h3><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>递归搜索，计算经过每个节点的路径，若当前路径大于最长路径则更新最长路径</p><p><strong>细节</strong></p><p>辅助函数的返回值并不是经过当前节点的<code>左路</code>+<code>右路</code>+<code>val</code>，而应该是<code>左路和右路的最大值</code>+<code>val</code>，这样才符合更新答案的部分需要的返回值，以最后一个示例为例，路径经过节点<code>20</code>向下搜索时不可能既走左边又走右边，应当择最大值；考虑到递归的返回是自底向上的，因此当前的<code>左子值</code>和<code>右子值</code>都是最优解。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// dfs 返回最大 统计</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1001</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        left = <span class="built_in">max</span>(<span class="number">0</span>, left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        right = <span class="built_in">max</span>(<span class="number">0</span>, right);</span><br><span class="line">        <span class="type">int</span> val = root-&gt;val + <span class="built_in">max</span>(left, right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val + left + right &gt; ans) ans = root-&gt;val + left + right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><h3 id="题干-21"><a href="#题干-21" class="headerlink" title="题干"></a>题干</h3><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>参考了题解<a href="https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-">“岛屿类问题的通用解法、DFS 遍历框架”</a></p><p>将树中搜索从对左右子节点递归搜索改成对矩阵周围元素的搜索</p><ul><li>需要有边界检查</li><li>需要避免重复搜索即搜索之后做标记</li></ul><p><strong>细节</strong></p><p>边界判断方面可以基于函数实现，代码会更优雅清晰一些，边界检查的上限要通常是≥时不符合</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inArea</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">inArea</span>(grid.<span class="built_in">size</span>(), grid[<span class="number">0</span>].<span class="built_in">size</span>(), i, j)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                <span class="built_in">update</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">                <span class="built_in">update</span>(grid, i + <span class="number">1</span>, j);</span><br><span class="line">                <span class="built_in">update</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">update</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">update</span>(grid, i, j);</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h2><h3 id="题干-22"><a href="#题干-22" class="headerlink" title="题干"></a>题干</h3><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p><p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>首先需要统计新鲜橘子数目，并且不断更新，才能判断最后是否全部腐烂</li><li>其次需要BFS&#x2F;层序，贴合题目中的一轮一轮的模拟</li><li>最后在层序遍历的同时更新矩阵，避免重复感染好橘子</li></ul><p><strong>细节</strong></p><ul><li>因为橘子向上下左右四个方向感染，因此可以创建一个辅助数组来便于感染部分代码实现</li><li>层序遍历的模板一般是外循环判断队列是否为空，内循环根据队列当前大小（动态变化因此需要一个变量存储当前大小）决定循环次数</li><li>可能会出现的问题：1. 只有坏橘子，没有好橘子； 2. 最后一次内循环，已经全是坏橘子了，并没有传染给其他橘子<ul><li>在<code>while</code>循环中添加一个<code>fresh</code>辅助判断，可以有效解决两个问题</li><li>不改变外循环条件，则在循环前进行<code>fresh</code>数目判断，可解决问题1；增加一个布尔变量记录是否发生感染放在内循环，用于更新<code>ans</code></li></ul></li></ul><p><strong>代码</strong></p><ol><li>自己写的，不是很优雅，效率也低了点</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inGrid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 感染橘子辅助数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 坏橘子队列</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 好橘子计数</span></span><br><span class="line">        <span class="type">int</span> fresh = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 坏橘子入队列 好橘子计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    ++fresh;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列大小</span></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 分钟数</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fresh &amp;&amp; !q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">// 感染其他橘子</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">inGrid</span>(grid.<span class="built_in">size</span>(), grid[<span class="number">0</span>].<span class="built_in">size</span>(), cur.first + dir[<span class="number">0</span>],</span><br><span class="line">                               cur.second + dir[<span class="number">1</span>]) &amp;&amp;</span><br><span class="line">                        grid[cur.first + dir[<span class="number">0</span>]][cur.second + dir[<span class="number">1</span>]] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[cur.first + dir[<span class="number">0</span>]][cur.second + dir[<span class="number">1</span>]] = <span class="number">2</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;cur.first + dir[<span class="number">0</span>], cur.second + dir[<span class="number">1</span>]&#125;);</span><br><span class="line">                        --fresh;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有剩余的好橘子</span></span><br><span class="line">        <span class="keyword">if</span> (fresh)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>请gpt优化过的，思路没换</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inGrid</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; directions = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> fresh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列和计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ++fresh;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fresh == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有好橘子，直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minutes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">bool</span> hasRotten = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size; ++k) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dx, dy] : directions) &#123;</span><br><span class="line">                    <span class="type">int</span> nx = x + dx, ny = y + dy;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">inGrid</span>(grid.<span class="built_in">size</span>(), grid[<span class="number">0</span>].<span class="built_in">size</span>(), nx, ny) &amp;&amp; grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[nx][ny] = <span class="number">2</span>; <span class="comment">// 感染橘子</span></span><br><span class="line">                        q.<span class="built_in">emplace</span>(nx, ny);</span><br><span class="line">                        --fresh;</span><br><span class="line">                        hasRotten = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasRotten) ++minutes; <span class="comment">// 只有感染发生时才增加时间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fresh == <span class="number">0</span> ? minutes : <span class="number">-1</span>; <span class="comment">// 剩余好橘子返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表*"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表*</a></h2><h3 id="题干-23"><a href="#题干-23" class="headerlink" title="题干"></a>题干</h3><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li></ul><h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>先后关系&#x2F;依赖关系 转换为有向图，若能构成包含所有节点的<strong>有向无环图</strong>则能完成所有课程。将有向无环图转化为线性排序即为<strong>拓扑排序</strong>。</p><p>有向图有<strong>入度</strong>&#x2F;出度的概念，通过队列保存当前入度为0的节点，然后按照bfs的思想搜索并不断更新完成课程的数目，直至队列为空。</p><p><strong>细节</strong></p><p>通过哈希表存储从当前节点出发的边，可以快速对依赖关系做更新</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 有向图的思想 计算入度 当入度为0说明没有前置条件 使用队列进行bfs</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : prerequisites) &#123;</span><br><span class="line">            ++count[item[<span class="number">0</span>]];</span><br><span class="line">            mp[item[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(item[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="type">int</span> unfinish = numCourses;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            --unfinish;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : mp[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(count[item] &gt; <span class="number">0</span>) --count[item];</span><br><span class="line">                <span class="keyword">if</span>(count[item] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(unfinish) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><h3 id="题干-24"><a href="#题干-24" class="headerlink" title="题干"></a>题干</h3><p>**<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li></ul><h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ol><li>用集合或者哈希表，查找效率高，查找前缀效率低</li><li>使用字典树，26叉树列举出现过的字符，查找即搜索</li></ol><p><strong>细节</strong></p><p>cpp初始化成员变量的方式：<code>Trie() : children(26), isEnd(false) &#123;&#125;</code></p><p>迭代搜索时使用临时变量<code>node</code>进行，初始化为<code>Trie* node = this;</code>，迭代<code>node = node-&gt;children[c];</code></p><p><strong>代码</strong></p><ol><li>自己写的，效率略低</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;string&gt; s;</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">count</span>(word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;str : s) &#123;</span><br><span class="line">            <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;prefix.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i] != prefix[i]) &#123;</span><br><span class="line">                    ans = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>26叉树&#x2F;字典树</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 26个子节点</span></span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="comment">// 当前节点是否为某个字符串的结尾</span></span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="comment">// 若prefix存在，返回结尾节点；若不存在，返回NULL</span></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 初始化 子节点全为空 不是结尾</span></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将对应位置的子节点初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 前缀返回值不为空同时要求当前节点为结尾</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">if</span> (node &amp;&amp; node-&gt;isEnd)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 前缀返回值不为空则表示有该前缀</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchPrefix</span>(prefix) == <span class="literal">NULL</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><h3 id="题干-25"><a href="#题干-25" class="headerlink" title="题干"></a>题干</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>回溯与深度优先搜索雷同，递归思路相似；</li><li>通过循环遍历的方式依次固定位置，从0开始到<code>nums.size()-1</code>例如<code>[1, 2, 3]</code>的全排列可以转化为<code>1+[2, 3]</code>、<code>2+[1, 3]</code>、<code>3+[1, 2]</code>的全排列，依次类推</li></ul><p><strong>细节</strong></p><p>递归终止条件即固定到最后一位，无需遍历，此时将当前<code>nums</code>添加到结果集中</p><p><strong>代码</strong></p><ol><li>解法一：<code>nums</code>作为参数不传递引用，易理解、代码简单</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]); <span class="comment">// 交换，将 nums[i] 固定在第 x 位</span></span><br><span class="line">            <span class="built_in">dfs</span>(nums, x + <span class="number">1</span>);       <span class="comment">// 开启固定第 x + 1 位元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>解法二：<code>nums</code>的引用传参，<code>nums</code>在递归返回后会与递归前不一致，从而影响结果，因此需要撤销交换</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]); <span class="comment">// 交换，将 nums[i] 固定在第 x 位</span></span><br><span class="line">            <span class="built_in">dfs</span>(nums, x + <span class="number">1</span>);       <span class="comment">// 开启固定第 x + 1 位元素</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]); <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><h3 id="题干-26"><a href="#题干-26" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的</p><p>子集</p><p>（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>子集数目是2^n，可以使用二进制来考虑每一个元素是否加入当前集合，作为子集之一</li><li>对于<code>cur</code>位置，我们需要考虑<code>a[cur]</code>取或者不取，如果取，我们需要把<code>a[cur]</code>放入一个临时的答案数组中，再执行 <code>dfs(cur+1,n)</code>，执行结束后需要对临时数组进行回溯；如果不取，则直接执行<code> dfs(cur+1,n)</code>。在整个递归调用的过程中，<code>cur</code> 是从小到大递增的，当<code>cur</code> 增加到<code>n</code>的时候，记录答案并终止递归。</li></ul><p><strong>细节</strong></p><ul><li>第一层循环是0到2^n-1，第二层循环是0到size，使用当前掩码<code>mask</code>和<code>1 &lt;&lt; i</code>做<code>&amp;</code>运算</li><li>递归终止条件是cur &#x3D;&#x3D; nums.size()，表示所有位置都已经确定</li></ul><p><strong>代码</strong></p><ol><li>使用二进制掩码来判断是否添加到当前集合作为子集</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 子集数目是2^n 可以使用二进制来表示子集(空集和全集都纳入了考虑)</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; <span class="number">1</span> &lt;&lt; n; ++mask) &#123;</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask &amp; <span class="number">1</span> &lt;&lt; i) &#123;</span><br><span class="line">                    temp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>回溯，添加当前元素，递归考虑cur+1之后的情况；回溯撤回添加，递归考虑cur+1之后的情况</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">        t.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h2><h3 id="题干-27"><a href="#题干-27" class="headerlink" title="题干"></a>题干</h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>每个位置选择对应的每个字母，排列组合；</li><li>递归返回条件是当<code>cur == digits.size()</code>，说明每一位都已经确定了；</li><li>使用哈希表做映射，能够快速遍历每个数字对应的字母列表。</li></ul><p><strong>细节</strong></p><ul><li><code>digits</code>作为参数传递时使用引用，减小开销；</li><li><code>string</code>没有<code>emplace_back()</code>，但是有<code>pop_back()</code>；</li><li>成员变量<code>mp</code>的初始化通过函数进行。</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string s;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, string&gt; mp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, string&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[digits[cur]].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            s += mp[digits[cur]][i];</span><br><span class="line">            <span class="built_in">dfs</span>(cur + <span class="number">1</span>, digits);</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        mp[<span class="string">&#x27;2&#x27;</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;3&#x27;</span>] = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;4&#x27;</span>] = <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;5&#x27;</span>] = <span class="string">&quot;jkl&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;6&#x27;</span>] = <span class="string">&quot;mno&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;7&#x27;</span>] = <span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;8&#x27;</span>] = <span class="string">&quot;tuv&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;9&#x27;</span>] = <span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!digits.<span class="built_in">empty</span>()) <span class="built_in">dfs</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><h3 id="题干-28"><a href="#题干-28" class="headerlink" title="题干"></a>题干</h3><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>看到可选重复的我以为确认每一位的方法不可行了，实际上依旧可以套用这个模板，只需要在此基础上更改递归的选择思路，选择当前元素后可以再选当前元素，递归修改为<code>dfs(cur)</code>，回溯后跳过该元素进行下一个位置的确定<code>dfs(cur+1)</code>。这样可以保障每个元素都可以出现n次。</p><p><strong>细节</strong></p><ul><li>递归终止条件除了<code>cur == candidates.size()</code>表示所有位置都已经确定了，还要增加<code>target == 0</code>，并且在此时将<code>t</code>添加到<code>ans</code>中</li><li><code>target - candidates[cur] &gt;= 0</code> 表示还能继续容纳，<code>target == 0</code>作为终止条件比<code>candidates[cur] == target</code>更符合逻辑</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == candidates.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择当前</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[cur] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            t.<span class="built_in">emplace_back</span>(candidates[cur]);</span><br><span class="line">            <span class="built_in">dfs</span>(cur, candidates, target - candidates[cur]);</span><br><span class="line">            t.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, candidates, target);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><h3 id="题干-29"><a href="#题干-29" class="headerlink" title="题干"></a>题干</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>因为要求是<strong>有效括号</strong>组合，因此在元素选择时要先选左括号，再选右括号；</p><p>左右括号的选择条件不同，<code>open</code>的上限是<code>n</code>，而<code>close</code>的上限是<code>open</code></p><p><strong>细节</strong></p><p>基于添加右括号的条件<code>close &lt; open</code>，达到递归终止条件时的t一定是有效括号组合</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;string&gt;&amp; ans, string&amp; t, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">size</span>() == <span class="number">2</span> * n) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">            t += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">backTrace</span>(ans, t, open + <span class="number">1</span>, close, n);</span><br><span class="line">            t.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            t += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">backTrace</span>(ans, t, open, close + <span class="number">1</span>, n);</span><br><span class="line">            t.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        string t;</span><br><span class="line">        <span class="built_in">backTrace</span>(ans, t, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h2><h3 id="题干-30"><a href="#题干-30" class="headerlink" title="题干"></a>题干</h3><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>查找字符串，从起点开始向上下左右四个方向进行搜索，同时每个点都应作为起点进行搜索；</li><li>搜索中，访问过的应当标记避免二次访问，搜索结束后还原；</li></ul><p><strong>细节</strong></p><p>终止条件包括<code>ans</code>已经为<code>true</code>，<code>cur == word.size()</code>即搜索完成，以及超出边界或者字符不匹配；</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> cur, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">bool</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 终止条件：已经找到单词</span></span><br><span class="line">        <span class="keyword">if</span> (cur == word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() ||</span><br><span class="line">            board[i][j] != word[cur]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> temp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 标记访问</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, cur + <span class="number">1</span>, board, word, ans);</span><br><span class="line">        <span class="built_in">dfs</span>(i - <span class="number">1</span>, j, cur + <span class="number">1</span>, board, word, ans);</span><br><span class="line">        <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, cur + <span class="number">1</span>, board, word, ans);</span><br><span class="line">        <span class="built_in">dfs</span>(i, j - <span class="number">1</span>, cur + <span class="number">1</span>, board, word, ans);</span><br><span class="line"></span><br><span class="line">        board[i][j] = temp; <span class="comment">// 恢复</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> rows = board.<span class="built_in">size</span>(), cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(i, j, <span class="number">0</span>, board, word, ans);</span><br><span class="line">                    <span class="keyword">if</span> (ans)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="两种情况的二分查找区分"><a href="#两种情况的二分查找区分" class="headerlink" title="两种情况的二分查找区分"></a>两种情况的二分查找区分</h2><h3 id="精确查找目标值和查找边界或插入位置"><a href="#精确查找目标值和查找边界或插入位置" class="headerlink" title="精确查找目标值和查找边界或插入位置"></a>精确查找目标值和查找边界或插入位置</h3><table><thead><tr><th><strong>条件</strong></th><th><strong><code>l &lt;= r</code></strong></th><th><strong><code>l &lt; r</code></strong></th></tr></thead><tbody><tr><td><strong>搜索区间</strong></td><td>闭区间 <code>[l, r]</code></td><td>左闭右开区间 <code>[l, r)</code></td></tr><tr><td><strong>循环结束条件</strong></td><td><code>l = r + 1</code></td><td><code>l = r</code></td></tr><tr><td><strong>适用场景</strong></td><td>精确查找目标值</td><td>查找边界或插入位置</td></tr><tr><td><strong><code>mid</code> 计算</strong></td><td><code>mid = l + (r - l) / 2</code></td><td><code>mid = l + (r - l) / 2</code></td></tr><tr><td><strong>边界更新</strong></td><td><code>l = mid + 1</code> 和 <code>r = mid - 1</code></td><td><code>l = mid + 1</code> 和 <code>r = mid</code></td></tr></tbody></table><h3 id="返回值的选择"><a href="#返回值的选择" class="headerlink" title="返回值的选择"></a>返回值的选择</h3><ul><li><strong><code>l</code> 和 <code>r</code> 的关系</strong>：<ul><li>如果循环条件是 <code>l &lt;= r</code>，循环结束时 <code>l = r + 1</code>。</li><li>如果循环条件是 <code>l &lt; r</code>，循环结束时 <code>l = r</code>。</li></ul></li><li><strong>返回值的确定</strong>：<ul><li>如果需要返回<strong>最后一个满足条件的值</strong>，通常返回 <code>r</code>。</li><li>如果需要返回<strong>第一个满足条件的值</strong>，通常返回 <code>l</code>。</li><li>具体返回值需要根据问题的语义和二分查找的实现逻辑来确定。</li></ul></li></ul><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h2><h3 id="题干-31"><a href="#题干-31" class="headerlink" title="题干"></a>题干</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>对于有序数组中的查找，不断迭代更新上限和下限直至查找完成或不再满足循环条件<code>l &lt;= r</code></p><p><strong>细节</strong></p><p>循环条件是<code>l &lt;= r</code></p><p><strong>代码</strong></p><ol><li>二分查找模板</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            cur = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[cur] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[cur] &gt; target) &#123;</span><br><span class="line">                r = cur - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = cur + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>递归做太多，下意识用递归写了一份</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[l + (r - l) / <span class="number">2</span>] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l + (r - l) / <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">div</span>(l, l + (r - l) / <span class="number">2</span> - <span class="number">1</span>, nums, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">div</span>(l + (r - l) / <span class="number">2</span> + <span class="number">1</span>, r, nums, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">div</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h2><h3 id="题干-32"><a href="#题干-32" class="headerlink" title="题干"></a>题干</h3><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ul><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-104 &lt;= matrix[i][j], target &lt;= 104</code></li></ul><h3 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>将一维有序数组更换为二维有序矩阵，只需要找到下标之间的对应关系即可转换为一维有序数组的查找</p><p><strong>细节</strong></p><p>无</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将线性排列对应到矩阵下标即可</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = matrix.<span class="built_in">size</span>() * matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            i = l + (r - l) / <span class="number">2</span> / matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            j = l + (r - l) / <span class="number">2</span> % matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                r = l + (r - l) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><h3 id="题干-33"><a href="#题干-33" class="headerlink" title="题干"></a>题干</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>在找到target数值时更新答案边界，并且设置为二分的新边界</p><p><strong>细节</strong></p><p>循环中不需要break跳出，因为找到target后需要设置新的边界并进行下一步迭代</p><p><strong>代码</strong></p><ol><li><code>logn</code>复杂度的解法，两次二分找到左边界和右边界</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> first = <span class="number">-1</span>, last = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                first = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(first);</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(last);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>非<code>logn</code>复杂度的解法，找到target之后向两侧拓展，测试用例没设置好估计，时长超过100%了…</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 查找到对应的target之后向两侧拓展更新答案即可</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l + (r - l) / <span class="number">2</span>] == target) &#123;</span><br><span class="line">                l = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l + (r - l) / <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                r = l + (r - l) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">            <span class="comment">// 找到左边界</span></span><br><span class="line">            <span class="type">int</span> left = l;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; nums[left - <span class="number">1</span>] == target) &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(left);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到右边界</span></span><br><span class="line">            <span class="type">int</span> right = l;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[right + <span class="number">1</span>] == target) &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(right);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; ans = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><h3 id="题干-34"><a href="#题干-34" class="headerlink" title="题干"></a>题干</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h3 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>数组局部有序，将数组分成两段意味着一定有一段是有序的，若target在有序数组中则二分查找；若不在则继续缩小范围</p><p><strong>细节</strong></p><ul><li>nums数量为0和1时可以单独考虑</li><li>判断数组是否有序时条件一使用<code>nums[mid] &gt;= nums[l]</code>而不是<code>nums[mid] &gt; nums[l]</code>，当数组大小为2时，可能会出现<code>mid == l</code>的情况，前半部分已经有序（只有一个数），但是没有被考虑进去。</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[l]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><h3 id="题干-35"><a href="#题干-35" class="headerlink" title="题干"></a>题干</h3><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><h3 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>旋转数组若进行奇数次旋转则数组被分为两段，后半段的最大值小于前半段的最小值；</li><li>当中间值比当前<code>min</code>小时，说明中间值与当前<code>min</code>一定不在同一段，查找后半段即可；</li><li>当中间值大于<code>min</code>时，只需要搜索<code>mid+1</code>之后的序列即可；</li></ul><p><strong>细节</strong></p><p>使用<code>min = nums[mid];</code>来更新答案，这样更新右边界时就应该是<code>r = mid - 1;</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; min) &#123;</span><br><span class="line">                min = nums[mid];</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316 去除重复字母"></a><a href="https://leetcode.cn/problems/remove-duplicate-letters/?envType=study-plan-v2&envId=2024-spring-sprint-100">316 去除重复字母</a></h2><h3 id="题干-36"><a href="#题干-36" class="headerlink" title="题干"></a>题干</h3><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的</strong></p><p><strong>字典序</strong></p><p><strong>最小</strong>（要求不能打乱其他字符的相对位置）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbacdcbc&quot;</span><br><span class="line">输出：&quot;acdb&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>316与402是同一种题型，循环条件中删除k个数字变成对于栈顶字符剩余数目的考量，需要先建立一个map来映射各个字母的出现次数</p><p><strong>细节</strong></p><p>循环条件变为while (!res.empty() &amp;&amp; i &lt; res[res.size() - 1] &amp;&amp; m[res[res.size() - 1]] &gt; 0)，即栈不为空、栈顶字符剩余数目大于0、当前字符小于栈顶字符</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">                m[c] += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[c] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">find</span>(i) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!res.<span class="built_in">empty</span>() &amp;&amp; i &lt; res[res.<span class="built_in">size</span>() - <span class="number">1</span>] &amp;&amp;</span><br><span class="line">                       m[res[res.<span class="built_in">size</span>() - <span class="number">1</span>]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                res += i;</span><br><span class="line">            &#125;</span><br><span class="line">            m[i] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="321-拼接最大数"><a href="#321-拼接最大数" class="headerlink" title="321 拼接最大数"></a><a href="https://leetcode.cn/problems/create-maximum-number/">321 拼接最大数</a></h2><h3 id="题干-37"><a href="#题干-37" class="headerlink" title="题干"></a>题干</h3><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code>，它们的长度分别为 <code>m</code> 和 <code>n</code>。数组 <code>nums1</code> 和 <code>nums2</code> 分别代表两个数各位上的数字。同时你也会得到一个整数 <code>k</code>。</p><p>请你利用这两个数组中的数字中创建一个长度为 <code>k &lt;= m + n</code> 的最大数，在这个必须保留来自同一数组的数字的相对顺序。</p><p>返回代表答案的长度为 <code>k</code> 的数组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5</span><br><span class="line">输出：[9,8,6,5,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [6,7], nums2 = [6,0,4], k = 5</span><br><span class="line">输出：[6,7,6,0,4]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [3,9], nums2 = [8,9], k = 3</span><br><span class="line">输出：[9,8,9]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 9</code></li><li><code>1 &lt;= k &lt;= m + n</code></li></ul><h3 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>在完成了402与316后，这道题的思路很清晰，将问题转化为两个“移掉k位数字”，即在nums1中保留i位数字，nums2中保留k-i位数字（与移除类似），并且保障两个数组分别最大顺序，再通过归并算法的合并部分进行整合得到最终结果。看了其他人的题解，感觉Python的归并比Cpp简单好多，Cpp我努力过了还是写错了</p><p><strong>细节</strong></p><p>实现一个maxNumber函数针对单个数组排序，实现一个merge函数将两个数组进行相对位置不改变的最大排序。</p><p>merge的实现过程中当两个数组当前字符相等时，需要判断两个字符串后续的字典序，基于compare函数。</p><p>compare函数的实现思路是，比较a和b直至出现两个不相等或者a和b遍历完成，如果b遍历完成，则a的长度≥b的长度，a的后续字典序大于b；如果b没有遍历完，a遍历完成，则a的长度＜b的长度，a的后续字典序小于b；如果a和b都没有遍历结束但是出现了字符不相同的情况，返回当前字符的比较结果即可。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>() || j &lt; b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; a.<span class="built_in">size</span>() &amp;&amp; (j &gt;= b.<span class="built_in">size</span>() || a[i] &gt; b[j] ||</span><br><span class="line">                                 (a[i] == b[j] &amp;&amp; <span class="built_in">compare</span>(a, i, b, j)))) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(a[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(b[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; b, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>() &amp;&amp; j &lt; b.<span class="built_in">size</span>() &amp;&amp; a[i] == b[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == b.<span class="built_in">size</span>() || (i &lt; a.<span class="built_in">size</span>() &amp;&amp; a[i] &gt; b[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (res.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; s[i] &gt; res[res.<span class="built_in">size</span>() - <span class="number">1</span>] &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">max</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> len1 = i;</span><br><span class="line">            <span class="type">int</span> len2 = k - i;</span><br><span class="line">            <span class="keyword">if</span> (len1 &lt;= nums1.<span class="built_in">size</span>() &amp;&amp; len2 &lt;= nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; s2 = <span class="built_in">maxNumber</span>(nums2, nums2.<span class="built_in">size</span>() - len2);</span><br><span class="line">                    <span class="keyword">if</span> (s2 &gt; max) &#123;</span><br><span class="line">                        max = s2;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; s1 = <span class="built_in">maxNumber</span>(nums1, nums1.<span class="built_in">size</span>() - len1);</span><br><span class="line">                    <span class="keyword">if</span> (s1 &gt; max) &#123;</span><br><span class="line">                        max = s1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; s1 = <span class="built_in">maxNumber</span>(nums1, nums1.<span class="built_in">size</span>() - len1);</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; s2 = <span class="built_in">maxNumber</span>(nums2, nums2.<span class="built_in">size</span>() - len2);</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; <span class="keyword">final</span> = <span class="built_in">merge</span>(s1, s2);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">final</span> &gt; max) &#123;</span><br><span class="line">                    max = <span class="keyword">final</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈*"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈*</a></h2><h3 id="题干-38"><a href="#题干-38" class="headerlink" title="题干"></a>题干</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li></ul><h3 id="题解-38"><a href="#题解-38" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>没想出什么好方法，想用<code>stack</code>来实现<code>MinStack</code>，一看题解还真是…</li><li>栈后进先出的性质可以理解为展示最新的，因此一个正常栈用于存储数据，另一个栈陪跑记录最新的最小值</li></ul><p><strong>细节</strong></p><p>在<code>push</code>时陪跑栈的<code>top</code>值取出来与当前值对比，选择压入陪跑栈新的值或者继续压入<code>top</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minStack;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123; minStack.<span class="built_in">push</span>(INT_MAX); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; minStack.<span class="built_in">top</span>())</span><br><span class="line">            minStack.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            minStack.<span class="built_in">push</span>(minStack.<span class="built_in">top</span>());    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        minStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">top</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> minStack.<span class="built_in">top</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><h3 id="题干-39"><a href="#题干-39" class="headerlink" title="题干"></a>题干</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 30</code></li><li><code>s</code> 由小写英文字母、数字和方括号 <code>&#39;[]&#39;</code> 组成</li><li><code>s</code> 保证是一个 <strong>有效</strong> 的输入。</li><li><code>s</code> 中所有整数的取值范围为 <code>[1, 300]</code></li></ul><h3 id="题解-39"><a href="#题解-39" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li><strong>思路一</strong><ul><li>基本思路是识别字符序列，识别数字并重复；</li><li>考虑到括号嵌套，可以使用栈来处理，入栈直至遇到右括号，弹栈至左括号获取字符串，弹栈至栈空或者不为数字取出重复次数；</li><li>重复完当前字符串后压栈，可以有效解决嵌套；</li></ul></li><li>思路二<ul><li>字符和数字分开处理；</li><li>非括号元素时更新<code>currentString</code>和<code>currentNum</code>，基于规则可以得知没有括号的情况下不可能出现两个<code>currentString</code>或者<code>currentNum</code>；</li><li>遇到左括号时，即遇到新的一层，将当前字符串和数字压入栈；</li><li>遇到右括号时，即当前层结束，从栈中弹出数字，重复当前字符串，再从字符串栈中弹出前缀并拼接（若无前缀则与空串拼接）</li></ul></li></ul><p><strong>细节</strong></p><ul><li>可以使用<code>isdigit()</code>函数判断字符是否为数字;</li><li>进行字符串数字的处理方式见代码1；</li></ul><p><strong>代码</strong></p><ol><li>数字栈和字符串两个栈，代码更简洁</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; charStack; <span class="comment">// 存储字符串片段</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; numStack;     <span class="comment">// 存储数字</span></span><br><span class="line">        string currentString;    <span class="comment">// 当前处理的字符串</span></span><br><span class="line">        <span class="type">int</span> currentNum = <span class="number">0</span>;      <span class="comment">// 当前处理的数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                <span class="comment">// 处理多位数</span></span><br><span class="line">                currentNum = currentNum * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将当前字符串和数字压入栈中，并重置</span></span><br><span class="line">                charStack.<span class="built_in">push</span>(currentString);</span><br><span class="line">                numStack.<span class="built_in">push</span>(currentNum);</span><br><span class="line">                currentString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                currentNum = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 弹出数字和字符串，重复当前字符串并拼接</span></span><br><span class="line">                <span class="type">int</span> repeatTimes = numStack.<span class="built_in">top</span>();</span><br><span class="line">                numStack.<span class="built_in">pop</span>();</span><br><span class="line">                string prevString = charStack.<span class="built_in">top</span>();</span><br><span class="line">                charStack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 使用 string 构造函数生成重复字符串</span></span><br><span class="line">                string repeatedString;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; repeatTimes; ++i) &#123;</span><br><span class="line">    repeatedString += currentString;</span><br><span class="line">&#125;</span><br><span class="line">                currentString = prevString + repeatedString;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通字符，直接添加到当前字符串</span></span><br><span class="line">                currentString += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>自己写的，一个栈，思路如上所述</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; decodeStack;</span><br><span class="line">        string ans;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">int</span> digit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                temp.<span class="built_in">clear</span>();</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                digit = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 弹栈直至遇到 &#x27;[&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> (decodeStack.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                    temp = decodeStack.<span class="built_in">top</span>() + temp;</span><br><span class="line">                    decodeStack.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 弹出&#x27;[&#x27;</span></span><br><span class="line">                decodeStack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 循环次数，空栈则不需要压栈，否则压栈</span></span><br><span class="line">                <span class="keyword">while</span> (!decodeStack.<span class="built_in">empty</span>() &amp;&amp; decodeStack.<span class="built_in">top</span>() &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp;</span><br><span class="line">                       decodeStack.<span class="built_in">top</span>() &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (digit) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        n += decodeStack.<span class="built_in">top</span>() - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        n += (decodeStack.<span class="built_in">top</span>() - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        n += (decodeStack.<span class="built_in">top</span>() - <span class="string">&#x27;0&#x27;</span>) * <span class="number">100</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    decodeStack.<span class="built_in">pop</span>();</span><br><span class="line">                    ++digit;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (decodeStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                        ans += temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 循环temp,压栈</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    string copy = temp;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                        temp += copy;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> tempChar : temp) &#123;</span><br><span class="line">                        decodeStack.<span class="built_in">push</span>(tempChar);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                decodeStack.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(!decodeStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            temp = decodeStack.<span class="built_in">top</span>() + temp;</span><br><span class="line">            decodeStack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans += temp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><h3 id="题干-40"><a href="#题干-40" class="headerlink" title="题干"></a>题干</h3><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><h3 id="题解-40"><a href="#题解-40" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>建立单调递减栈，当遇到更高的气温时，会一路弹栈并更新之前的答案，契合要求；</li><li>遍历数组进行入栈，可以保证当前元素大于栈顶元素时一定是<strong>第一个大于栈顶元素值的元素</strong>。</li></ul><p><strong>细节</strong></p><p>栈仅用于存储下标，数值比较只需要取出下标基于<code>temperatures</code>数组进行比较，同时在更新距离时下标之差正好是距离</p><p><strong>代码</strong></p><ol><li>暴力，超时</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(temperatures.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;temperatures.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;temperatures.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(temperatures[j] &gt; temperatures[i]) &#123;</span><br><span class="line">                    ans[i] = j - i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>单调（递减）栈</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[s.<span class="built_in">top</span>()] &lt; temperatures[i]) &#123;</span><br><span class="line">                ans[s.<span class="built_in">top</span>()] = i - s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形*"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形*</a></h2><h3 id="题干-41"><a href="#题干-41" class="headerlink" title="题干"></a>题干</h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h3 id="题解-41"><a href="#题解-41" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>每日温度的变体，每日温度是寻找第一个<strong>“大于”</strong>，最大矩形是寻找第一个<strong>“小于”</strong>；</p><p><strong>细节</strong></p><p>更新右边界应该正向循环，更新左边界应该逆向循环，可以保障弹栈更新时一定是第一个<strong>“小于”</strong>自身值的元素；</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; leftStack;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; rightStack;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(heights.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(heights.size(), heights.size())</span></span>;</span><br><span class="line">        <span class="comment">// 正向遍历更新右边界，构建单调递增栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 当前元素小于栈顶时，弹栈更新对应位置的右边界</span></span><br><span class="line">            <span class="keyword">while</span> (!rightStack.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                   heights[i] &lt; heights[rightStack.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                r[rightStack.<span class="built_in">top</span>()] = i;</span><br><span class="line">                rightStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            rightStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反向遍历更新左边界，构建单调递增栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = heights.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 当前元素小于栈顶时，弹栈更新对应位置的左边界</span></span><br><span class="line">            <span class="keyword">while</span> (!leftStack.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                   heights[i] &lt; heights[leftStack.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                l[leftStack.<span class="built_in">top</span>()] = i;</span><br><span class="line">                leftStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            leftStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, heights[i] * (r[i] - l[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="UI可能的关闭顺序（可能的出栈序列）"><a href="#UI可能的关闭顺序（可能的出栈序列）" class="headerlink" title="UI可能的关闭顺序（可能的出栈序列）"></a>UI可能的关闭顺序（可能的出栈序列）</h2><h3 id="题干-42"><a href="#题干-42" class="headerlink" title="题干"></a>题干</h3><p>输入n表示UI的编号从1至n，打开3之前必须打开2，打开2之前必须打开1；关闭2之前必须关闭3，关闭1之前必须关闭2，依此类推。输出20种可能的UI关闭顺序，不足20则全部输出。</p><h3 id="题解-42"><a href="#题解-42" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>理解题意后实际上就是按照1到n的顺序入栈，问可能的出栈序列。</p><p><strong>细节</strong></p><ul><li>使用引用传递参数，需要考虑好回溯</li><li>回溯取消的是父调用的操作</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">generateSequences</span><span class="params">(stack&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> i, <span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; currentSequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(currentSequence.<span class="built_in">size</span>() == n) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(currentSequence);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i &lt; n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 打开新的页面</span></span><br><span class="line">        s.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="built_in">generateSequences</span>(s, i + <span class="number">1</span>, n, currentSequence);</span><br><span class="line">        <span class="comment">// 不再打开页面，选择关闭一些页面，撤回前一次打开，此时页面i尚未打开</span></span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 关闭页面</span></span><br><span class="line">        <span class="type">int</span> top = s.<span class="built_in">top</span>();</span><br><span class="line">        currentSequence.<span class="built_in">emplace_back</span>(top);</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 关闭了一个页面，接下来选择是否打开页面i，还是继续关闭页面</span></span><br><span class="line">        <span class="built_in">generateSequences</span>(s, i, n, currentSequence);</span><br><span class="line">        <span class="comment">// 撤回前面关闭的页面，重新选择接下来打开新的页面还是关闭</span></span><br><span class="line">        s.<span class="built_in">push</span>(top);</span><br><span class="line">        currentSequence.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; currentSequence;</span><br><span class="line">    <span class="built_in">generateSequences</span>(s, <span class="number">1</span>, n, currentSequence);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; vec : ans) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cout &lt;&lt; vec[i] &lt;&lt; (i + <span class="number">1</span> &lt; vec.<span class="built_in">size</span>() ? <span class="string">&quot; &quot;</span> : <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><h3 id="题干-43"><a href="#题干-43" class="headerlink" title="题干"></a>题干</h3><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><p><strong>输入：</strong>s &#x3D; “()”</p><p><strong>输出：</strong>true</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>s &#x3D; “()[]{}”</p><p><strong>输出：</strong>true</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>s &#x3D; “(]”</p><p><strong>输出：</strong>false</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>s &#x3D; “([])”</p><p><strong>输出：</strong>true</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h3 id="题解-43"><a href="#题解-43" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>左括号入栈，右括号对比弹栈</p><p><strong>细节</strong></p><p>可能会出现全是左括号的情况，或者全是右括号的情况，因此需要使用<code>open.empty()</code>来解决这两种情况</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; open;</span><br><span class="line">        <span class="type">char</span> cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                open.<span class="built_in">push</span>(c); <span class="comment">// 左括号入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果栈为空，说明没有匹配的左括号</span></span><br><span class="line">                <span class="keyword">if</span> (open.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = open.<span class="built_in">top</span>(); <span class="comment">// 获取栈顶元素</span></span><br><span class="line">                <span class="comment">// 检查括号是否匹配</span></span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; cur != <span class="string">&#x27;(&#x27;</span>) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; cur != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; cur != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                open.<span class="built_in">pop</span>(); <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈为空，说明所有括号都匹配</span></span><br><span class="line">        <span class="keyword">return</span> open.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215 数组中的第K个最大元素</a></h2><h3 id="题干-44"><a href="#题干-44" class="headerlink" title="题干"></a>题干</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="题解-44"><a href="#题解-44" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li><p>快速排序的思想，直到确认的元素位置在<code>target</code>则表示它是第k大的数，同时根据等比数列它的平均时间是<code>O(N)</code></p></li><li><p><code>partition</code>返回随机哨兵最终的下标，根据该下标更新左边界和右边界</p></li><li><p><code>partition</code>函数采用双路快排，可以保证在出现大量与哨兵相等的元素时返回下标也在中间的位置，避免出现$N^2$的情况</p></li></ul><p><strong>细节</strong></p><ul><li><p><code>partition</code>函数哨兵设置选取随机下标执行效率会更高</p></li><li><p><code>partition</code>函数的循环跳出条件是<code>le &gt;= ge</code>，最终返回下标是<code>ge</code></p></li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left], nums[left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>)]);</span><br><span class="line">        <span class="type">int</span> le = left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ge = right;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (le &lt;= ge &amp;&amp; nums[le] &lt; nums[left])</span><br><span class="line">                ++le;</span><br><span class="line">            <span class="keyword">while</span> (le &lt;= ge &amp;&amp; nums[ge] &gt; nums[left])</span><br><span class="line">                --ge;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (le &gt;= ge)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(nums[le], nums[ge]);</span><br><span class="line">            ++le;</span><br><span class="line">            --ge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left], nums[ge]);</span><br><span class="line">        <span class="keyword">return</span> ge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> target = n - k;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (pivot == target)</span><br><span class="line">                <span class="keyword">return</span> nums[target];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pivot &gt; target)</span><br><span class="line">                right = pivot - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = pivot + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><h3 id="题干-45"><a href="#题干-45" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><h3 id="题解-45"><a href="#题解-45" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>构建哈希表统计词频，排序哈希表的<code>value</code>取出前k个即可</p><p><strong>细节</strong></p><ul><li>注意优先队列的STL模板以及使用方法</li><li>使用大顶堆则不需要对堆元素进行删除，但是最终维护堆的成本较高；使用小顶堆可以一直将堆的大小控制在k</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 推排序比较方式</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 小顶堆</span></span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计频率创建一个哈希表</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            ++hashMap[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对哈希表进行排序，取出前k个元素的key</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : hashMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.<span class="built_in">top</span>().second &lt; pair.second) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pair);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(pair);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><h3 id="题干-46"><a href="#题干-46" class="headerlink" title="题干"></a>题干</h3><p><strong>中位数</strong>是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。</p><ul><li>例如 <code>arr = [2,3,4]</code> 的中位数是 <code>3</code> 。</li><li>例如 <code>arr = [2,3]</code> 的中位数是 <code>(2 + 3) / 2 = 2.5</code> 。</li></ul><p>实现 MedianFinder 类:</p><ul><li><code>MedianFinder() </code>初始化 <code>MedianFinder</code> 对象。</li><li><code>void addNum(int num)</code> 将数据流中的整数 <code>num</code> 添加到数据结构中。</li><li><code>double findMedian()</code> 返回到目前为止所有元素的中位数。与实际答案相差 <code>10-5</code> 以内的答案将被接受。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]</span><br><span class="line">[[], [1], [2], [], [3], []]</span><br><span class="line">输出</span><br><span class="line">[null, null, null, 1.5, null, 2.0]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MedianFinder medianFinder = new MedianFinder();</span><br><span class="line">medianFinder.addNum(1);    // arr = [1]</span><br><span class="line">medianFinder.addNum(2);    // arr = [1, 2]</span><br><span class="line">medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)</span><br><span class="line">medianFinder.addNum(3);    // arr[1, 2, 3]</span><br><span class="line">medianFinder.findMedian(); // return 2.0</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>-105 &lt;= num &lt;= 105</code></li><li>在调用 <code>findMedian</code> 之前，数据结构中至少有一个元素</li><li>最多 <code>5 * 104</code> 次调用 <code>addNum</code> 和 <code>findMedian</code></li></ul><h3 id="题解-46"><a href="#题解-46" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>建一个大于等于中位数的堆，但是是小顶堆，堆顶是最小的大于中位数的堆，再建一个小于中位数的堆，但是是大顶堆，堆顶的最大小于中位数的堆。</li><li>调节堆节点数量平衡，保证小顶堆数目最多比大顶堆数目多1（初始第一个元素一定加到小顶堆里）</li></ul><p><strong>细节</strong></p><ul><li>调节节点数目平衡的判断条件一定要写<code>smallHeap.size() &gt; bigHeap.size() + 1</code>而不要写成<code>smallHeap.size() - bigHeap.size() &gt; 1</code></li><li>因为<code>size()</code>返回<code>size_t</code>类型，是个无符号整数，没有负数，当<code>bigHeap.size()</code>大于<code>smallHeap.size()</code>时不会得到负数而是反向溢出</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; smallHeap;</span><br><span class="line">    <span class="comment">// 大顶堆</span></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>&gt; bigHeap;</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smallHeap.<span class="built_in">empty</span>() || num &gt;= smallHeap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            smallHeap.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; smallHeap.<span class="built_in">top</span>()) &#123;</span><br><span class="line">            bigHeap.<span class="built_in">emplace</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (smallHeap.<span class="built_in">size</span>() &gt; bigHeap.<span class="built_in">size</span>() + <span class="number">1</span>) &#123;</span><br><span class="line">            bigHeap.<span class="built_in">emplace</span>(smallHeap.<span class="built_in">top</span>());</span><br><span class="line">            smallHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bigHeap.<span class="built_in">size</span>() &gt; smallHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            smallHeap.<span class="built_in">emplace</span>(bigHeap.<span class="built_in">top</span>());</span><br><span class="line">            bigHeap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (smallHeap.<span class="built_in">size</span>() == bigHeap.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="type">double</span> sum = smallHeap.<span class="built_in">top</span>() + bigHeap.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">return</span> sum / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> smallHeap.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><h3 id="题干-47"><a href="#题干-47" class="headerlink" title="题干"></a>题干</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="题解-47"><a href="#题解-47" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>动态维护最小值，非最小值时尝试更新答案，<code>O(n)</code>时间内可以完成利润计算</p><p><strong>细节</strong></p><p><code>prices</code>本身是按照时间顺序递进的，因此正向遍历时动态更新最小值符合时间顺序</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2><h3 id="题干-48"><a href="#题干-48" class="headerlink" title="题干"></a>题干</h3><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题解-48"><a href="#题解-48" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>根据题干，每个元素代表<strong>可以</strong>跳跃的最大长度；</p><p>依次遍历每个位置并且实时更新可以到达的最大长度，如果元素代表跳跃距离就无法贪心；</p><p><strong>细节</strong></p><p><code>reach</code>可以初始化为<code>nums[0]</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> reach = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; reach)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            reach = <span class="built_in">max</span>(reach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reach &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2><h3 id="题干-49"><a href="#题干-49" class="headerlink" title="题干"></a>题干</h3><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li>题目保证可以到达 <code>nums[n-1]</code></li></ul><h3 id="题解-49"><a href="#题解-49" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>根据当前位置<code>cur</code>以及当前可跳距离<code>nums[cur]</code>可以得到当前可达位置范围，同时根据可达位置范围以及<code>nums</code>数组就可以知道哪一个可达位置能让你下一步的可达范围最大化。</li><li>听起来似乎有点绕，仔细阅读可以理解，跳跃是区间范围选择的，因此每次选择最远范围的即可，因为它的区间一定能覆盖其他选择，不理解的时候可以画图（借用一下官图）</li><li><img src="https://assets.leetcode.cn/solution-static/45/45_fig1.png" alt="fig1"></li></ul><p><strong>细节</strong></p><p><code>cur</code>不需要遍历到<code>nums.size() - 1</code>，避免重复计算跳跃次数</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前位置</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 能达到的范围</span></span><br><span class="line">        <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最远</span></span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算能达到的范围</span></span><br><span class="line">            next = cur + nums[cur];</span><br><span class="line">            <span class="comment">// 达到则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (next &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最远的位置必然大于cur</span></span><br><span class="line">            maxPos = cur;</span><br><span class="line">            <span class="comment">// 当前位置到能达到的范围遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = cur + <span class="number">1</span>; i &lt;= next &amp;&amp; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="comment">// 最远的选择为落点</span></span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt; maxPos) &#123;</span><br><span class="line">                    <span class="comment">// 更新最远范围</span></span><br><span class="line">                    maxPos = i + nums[i];</span><br><span class="line">                    <span class="comment">// 更新落点选择</span></span><br><span class="line">                    cur = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 跳一次</span></span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间*"></a><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间*</a></h2><h3 id="题干-50"><a href="#题干-50" class="headerlink" title="题干"></a>题干</h3><p>给你一个字符串 <code>s</code> 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。</p><p>注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 <code>s</code> 。</p><p>返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;、&quot;defegde&quot;、&quot;hijhklij&quot; 。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 这样的划分是错误的，因为划分的片段数较少。 </span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;eccbbbbdec&quot;</span><br><span class="line">输出：[10]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 500</code></li><li><code>s</code> 仅由小写英文字母组成</li></ul><h3 id="题解-50"><a href="#题解-50" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li><p>一个新字符出现，那么这一段最短也得到它最后一次出现的位置，否则同一字符会出现在两段</p></li><li><p>保证每一段都是最短的，那么就能分出最多的段</p></li></ul><p><strong>细节</strong></p><ul><li><p>可以使用一个26大小的数组存储最后一次出现的位置，代替哈希表</p></li><li><p>遍历时比较与end的大小可以减少赋值次数，理论上应该效率更高</p></li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> charEnd[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            charEnd[s[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 减少赋值</span></span><br><span class="line">            <span class="keyword">if</span> (charEnd[s[i] - <span class="string">&#x27;a&#x27;</span>] &gt; end)</span><br><span class="line">                end = charEnd[s[i] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(end - start + <span class="number">1</span>);</span><br><span class="line">                start = end + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><h3 id="题干-51"><a href="#题干-51" class="headerlink" title="题干"></a>题干</h3><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。</p><p>每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：有两种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶</span><br><span class="line">2. 2 阶</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：有三种方法可以爬到楼顶。</span><br><span class="line">1. 1 阶 + 1 阶 + 1 阶</span><br><span class="line">2. 1 阶 + 2 阶</span><br><span class="line">3. 2 阶 + 1 阶</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 45</code></li></ul><h3 id="题解-51"><a href="#题解-51" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>经典动态规划，每一级都可以由上一级和上上一级到达，因此只需要知道到达上一级楼梯和上上一级楼梯有几种方法，相加即可。</p><p><strong>细节</strong></p><p>第0级和第1级台阶可以视为只有一种方法到达</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a></h2><h3 id="题干-52"><a href="#题干-52" class="headerlink" title="题干"></a>题干</h3><p>给定一个非负整数 <em><code>numRows</code>，</em>生成「杨辉三角」的前 <em><code>numRows</code></em> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 5</span><br><span class="line">输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: numRows = 1</span><br><span class="line">输出: [[1]]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= numRows &lt;= 30</code></li></ul><h3 id="题解-52"><a href="#题解-52" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>每一行的数量与行数对应，头尾都是1因此可以全部初始化为1；</li><li>从第3行开始，除去头和尾，每个元素等于上一行前一个下标元素和当前下标元素相加；</li></ul><p><strong>细节</strong></p><p>上一行在ans中应该是ans[i - 2]</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generate</span>(<span class="type">int</span> numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= numRows; ++i) &#123;</span><br><span class="line">            <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cur</span><span class="params">(i, <span class="number">1</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">// cur[j] = ans[ans.size() - 1][j - 1] + ans[ans.size() - 1][j];</span></span><br><span class="line">                cur[j] = ans[i - <span class="number">2</span>][j - <span class="number">1</span>] + ans[i - <span class="number">2</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198. 打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198. 打家劫舍</a></h2><h3 id="题干-53"><a href="#题干-53" class="headerlink" title="题干"></a>题干</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警</strong>。</p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 400</code></li></ul><h3 id="题解-53"><a href="#题解-53" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li><strong>思路一</strong>是隔一个偷或者隔两个偷，因为<code>nums</code>都是大于0的，把每个<code>nums</code>都视为偷，那么就只能隔一个偷或者隔两个偷，但是需要处理两间屋子及以下的特殊情况；</li><li><strong>思路二</strong>不将每个<code>nums</code>视为必偷，而是选择如果偷则<code>+ dp[i - 2]</code>，不偷则等于<code>dp[i - 1]</code>，更加符合动态规划思路，只需要初始化而不需要单独处理特殊情况</li></ul><p><strong>细节</strong></p><p><code>dp</code>中的<code>i</code>下标对应<code>nums</code>中<code>i-1</code>的屋子</p><p><strong>代码</strong></p><ol><li><strong>解法一</strong>：每一个视为必偷</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = nums[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> ans = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">max</span>(nums[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>], nums[i - <span class="number">1</span>] + dp[i - <span class="number">3</span>]);</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>解法二</strong>：不把每一个都视为必偷</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>] + nums[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h2><h3 id="题干-54"><a href="#题干-54" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数 <code>n</code> ，返回 <em>和为 <code>n</code> 的完全平方数的最少数量</em> 。</p><p><strong>完全平方数</strong> 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，<code>1</code>、<code>4</code>、<code>9</code> 和 <code>16</code> 都是完全平方数，而 <code>3</code> 和 <code>11</code> 不是。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 12</span><br><span class="line">输出：3 </span><br><span class="line">解释：12 = 4 + 4 + 4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 13</span><br><span class="line">输出：2</span><br><span class="line">解释：13 = 4 + 9</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 104</code></li></ul><h3 id="题解-54"><a href="#题解-54" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>$n$可以表示为一个平方数与另一个数$n - i^2$相加，基于动态规划思想，$dp[n] &#x3D; dp[n - i^2] + 1$</li><li>双重循环，一个循环遍历更新<code>dp</code>数组，一个循环迭代小于<code>i</code>的平方数</li></ul><p><strong>细节</strong></p><p>初始化时全部初始化为<code>INT_MAX</code>，再将<code>dp[0]</code>设置为<code>0</code>，可以减少一个变量初始化为<code>INT_MAX</code>（代码2的方法）</p><p><strong>代码</strong></p><ol><li>优化过的代码</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 动态规划数组，dp[i] 表示组成 i 的最小完全平方数的数量</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, INT_MAX)</span></span>;</span><br><span class="line">        <span class="comment">// 0 不需要任何完全平方数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历每个数字 i</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="comment">// 遍历每个可能的完全平方数 j^2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="comment">// 更新 dp[i]，通过使用完全平方数 j^2</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - j * j] &lt; dp[i]) &#123;</span><br><span class="line">                    dp[i] = dp[i - j * j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最终加入一个 j^2</span></span><br><span class="line">            ++dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];  <span class="comment">// 返回 dp[n]，即组成 n 的最小完全平方数的数量</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>增加一个中间变量记录<code>ans</code>，用于更新<code>dp</code></li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i - j * j] &lt; ans)</span><br><span class="line">                    ans = dp[i - j * j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = ans + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><h3 id="题干-55"><a href="#题干-55" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>coins</code> ，表示不同面额的硬币；以及一个整数 <code>amount</code> ，表示总金额。</p><p>计算并返回可以凑成总金额所需的 <strong>最少的硬币个数</strong> 。如果没有任何一种硬币组合能组成总金额，返回 <code>-1</code> 。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [2], amount = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：coins = [1], amount = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= coins.length &lt;= 12</code></li><li><code>1 &lt;= coins[i] &lt;= 231 - 1</code></li><li><code>0 &lt;= amount &lt;= 104</code></li></ul><h3 id="题解-55"><a href="#题解-55" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>和完全平方数一样的思路，但是更新条件更加复杂：</p><ul><li>下标首先不能越界</li><li>其次得是有效结果即dp值不为-1</li><li>最后要比ans值更小</li></ul><p><strong>细节</strong></p><p>如果ans没有发生过更新说明不存在符合条件的前置选项，此时不应该更新dp数组，保持-1作为不满足条件的标记</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - coin &gt;= <span class="number">0</span> &amp;&amp; dp[i - coin] != <span class="number">-1</span> &amp;&amp; ans &gt; dp[i - coin]) &#123;</span><br><span class="line">                    ans = dp[i - coin];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans != INT_MAX)</span><br><span class="line">                dp[i] = ans + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h2><h3 id="题干-56"><a href="#题干-56" class="headerlink" title="题干"></a>题干</h3><p>给你一个字符串 <code>s</code> 和一个字符串列表 <code>wordDict</code> 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 <code>s</code> 则返回 <code>true</code>。</p><p><strong>注意：</strong>不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以由 &quot;leet&quot; 和 &quot;code&quot; 拼接成。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以由 &quot;apple&quot; &quot;pen&quot; &quot;apple&quot; 拼接成。</span><br><span class="line">     注意，你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 300</code></li><li><code>1 &lt;= wordDict.length &lt;= 1000</code></li><li><code>1 &lt;= wordDict[i].length &lt;= 20</code></li><li><code>s</code> 和 <code>wordDict[i]</code> 仅由小写英文字母组成</li><li><code>wordDict</code> 中的所有字符串 <strong>互不相同</strong></li></ul><h3 id="题解-56"><a href="#题解-56" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>与完全平方数一样的思路，但是这次不需要维护最长或者最短；</li><li>遍历整个字符串，从当前字符串长度往前截取一个单词的长度，检查子串是否能和<code>wordDict</code>中单词对应，对应上则该点<code>dp</code>值为<code>true</code>；</li></ul><p><strong>细节</strong></p><p><code>string::compare()</code>函数的一种重载<code>int compare(size_t pos, size_t len, const string&amp; str) const;</code></p><ul><li>参数：<ul><li><code>pos</code>：当前字符串中开始比较的位置。</li><li><code>len</code>：当前字符串中要比较的子串长度。</li><li><code>str</code>：要比较的另一个字符串。</li></ul></li><li>返回值：<ul><li>如果当前子串小于 <code>str</code>，返回负值。</li><li>如果当前子串等于 <code>str</code>，返回 <code>0</code>。</li><li>如果当前子串大于 <code>str</code>，返回正值。</li></ul></li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// substr构造子串，我的常用方法，但是效率低需要创建临时字符串</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符长度进行dp</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (string&amp; word : wordDict) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= word.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">                    word == s.<span class="built_in">substr</span>(i - word.<span class="built_in">size</span>(), word.<span class="built_in">size</span>()) &amp;&amp;</span><br><span class="line">                    dp[i - word.<span class="built_in">size</span>()])</span><br><span class="line">                    dp[i] = dp[i - word.<span class="built_in">size</span>()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// string::compare函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">wordBreak</span><span class="params">(string s, vector&lt;string&gt;&amp; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 字符长度进行dp</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (string&amp; word : wordDict) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= word.<span class="built_in">size</span>() &amp;&amp;</span><br><span class="line">                    s.<span class="built_in">compare</span>(i - word.<span class="built_in">size</span>(), word.<span class="built_in">size</span>(), word) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    dp[i - word.<span class="built_in">size</span>()])</span><br><span class="line">                    dp[i] = dp[i - word.<span class="built_in">size</span>()];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="300-最长递增子序列"><a href="#300-最长递增子序列" class="headerlink" title="300. 最长递增子序列*"></a><a href="https://leetcode.cn/problems/longest-increasing-subsequence/">300. 最长递增子序列*</a></h2><h3 id="题干-57"><a href="#题干-57" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p><strong>子序列</strong> 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的</p><p>子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [10,9,2,5,3,7,101,18]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1,0,3,2,3]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [7,7,7,7,7,7,7]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2500</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><p><strong>进阶：</strong></p><ul><li>你能将算法的时间复杂度降低到 <code>O(n log(n))</code> 吗?</li></ul><h3 id="题解-57"><a href="#题解-57" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ol><li><strong>dp</strong>：</li></ol><ul><li><p>依旧是完全平方数的思路，往前遍历更新最大值，<code>dp[i]</code>表示以<code>nums[i]</code>结尾的最长子序列长度</p></li><li><p>比较<code>nums[i]</code>与其之前的每一个<code>nums[j]</code>，更新<code>dp[i]</code></p></li><li><p>但是这题<code>dp[n - 1]</code>不一定是最大的，因为<code>nums[n - 1]</code>可能是一个很小的数，因此是递减的，没有纳入最长递增序列</p></li></ul><ol start="2"><li><strong>二分</strong>：</li></ol><ul><li>想要动态维护最长递增子序列可能做不到，但是动态维护最长递增子序列的结尾是可以做到的</li><li>维护一个递增数组，如果<code>nums[i]</code>大于递增数组尾元素更新答案并且直接加在递增数组后面</li><li>如果<code>nums[i]</code>小于递增数组尾元素，则用它更新递增数组，<code>increase[i]</code>表示长度为<code>i+1</code>的子序列尾元素的可能值，将对应长度子序列的尾元素都维护在当前的最小值，可以保证子序列尽可能地增长（贪心策略）</li></ul><p><strong>细节</strong></p><p>二分查找和普通二分不一样，如果缩小边界的方式并不是<code>mid + 1</code>和<code>mid - 1</code>，而是<code>mid + 1</code>和<code>mid</code> 或 <code>mid - 1</code> 和 <code>mid</code> 的话，那么循环条件是<code>l &lt; r</code></p><p><strong>代码</strong></p><ol><li>动态规划</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> temp = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j] &amp;&amp; dp[j] &gt; temp)</span><br><span class="line">                    temp = dp[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp != INT_MIN)</span><br><span class="line">                dp[i] = temp + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; ans)</span><br><span class="line">                ans = dp[i];                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>维护递增数组，二分查找</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; increase = &#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="comment">// 遍历元素维护递增数组 如果大于最大值直接插入</span></span><br><span class="line">        <span class="comment">// 否则把它更新到正确的位置，更新当前序列（至少小于最大值）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; increase[increase.<span class="built_in">size</span>() - <span class="number">1</span>])</span><br><span class="line">                increase.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; increase[increase.<span class="built_in">size</span>() - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 二分查找 log k</span></span><br><span class="line">                <span class="type">int</span> left = <span class="number">0</span>, right = increase.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> mid = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (increase[mid] &gt;= nums[i]) &#123;</span><br><span class="line">                        right = mid;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        left = mid + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                increase[right] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> increase.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h1><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径*"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径*</a></h2><h3 id="题干-58"><a href="#题干-58" class="headerlink" title="题干"></a>题干</h3><p>一个机器人位于一个 <code>m x n</code> 网格的左上角 （起始点在下图中标记为 “Start” ）。</p><p>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。</p><p>问总共有多少条不同的路径？</p><p><strong>示例 1：</strong></p><p><img src="https://pic.leetcode.cn/1697422740-adxmsI-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 7</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">从左上角开始，总共有 3 条路径可以到达右下角。</span><br><span class="line">1. 向右 -&gt; 向下 -&gt; 向下</span><br><span class="line">2. 向下 -&gt; 向下 -&gt; 向右</span><br><span class="line">3. 向下 -&gt; 向右 -&gt; 向下</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 7, n = 3</span><br><span class="line">输出：28</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：m = 3, n = 3</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= m, n &lt;= 100</code></li><li>题目数据保证答案小于等于 <code>2 * 109</code></li></ul><h3 id="题解-58"><a href="#题解-58" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>二维动态规划，当前位置可以从左方和上方走到，将它们的路径数目相加即可更新当前位置</li><li>组合数，向右走<code>n - 1</code>次，向下走<code>m - 1</code>次，总共走<code>m + n - 2</code>次，从<code>m + n - 2</code>次行走中选出<code>n - 1</code>次向右走就是答案</li></ul><p><strong>细节</strong></p><ul><li>动态规划第一行和第一列的路径数目都是1，只有一条路（因为只能向下和右）</li><li>组合数不能写函数来进行阶乘计算，会溢出（long long也会），只能乘法和除法同步进行，组合数的特点之一上面相乘的数目和下面相乘的数目相等</li><li>$C_{m + n - 2}^{m - 1} &#x3D; \frac{(m + n -2)!}{(m - 1)!(n - 1)!} &#x3D; \frac{n(n + 1)…(m+n-2)}{(m - 1)!}$，根据组合数上述性质，分母是m-1个数相乘，分子也应该是m-1个数相乘，即从n到m+n-2为n-1个数</li></ul><p><strong>代码</strong></p><ol><li>二维动态规划</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// dp</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>数学方法，组合数</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组合数</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = n; i &lt; m; ++i, ++j) &#123;</span><br><span class="line">            ans = ans * j / i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列*"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列*</a></h2><h3 id="题干-59"><a href="#题干-59" class="headerlink" title="题干"></a>题干</h3><p>给定两个字符串 <code>text1</code> 和 <code>text2</code>，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 <code>0</code> 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，<code>&quot;ace&quot;</code> 是 <code>&quot;abcde&quot;</code> 的子序列，但 <code>&quot;aec&quot;</code> 不是 <code>&quot;abcde&quot;</code> 的子序列。</li></ul><p>两个字符串的 <strong>公共子序列</strong> 是这两个字符串所共同拥有的子序列。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abcde&quot;, text2 = &quot;ace&quot; </span><br><span class="line">输出：3  </span><br><span class="line">解释：最长公共子序列是 &quot;ace&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：最长公共子序列是 &quot;abc&quot; ，它的长度为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：text1 = &quot;abc&quot;, text2 = &quot;def&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：两个字符串没有公共子序列，返回 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><h3 id="题解-59"><a href="#题解-59" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>二维动态规划，其中<code>dp[i][j]</code>表示选取<code>text1</code>的前<code>i</code>个字符，<code>text2</code>的前<code>j</code>个字符时的最长公共子序列长度</li><li><code>text1</code>的第<code>i</code>个字符和<code>text2</code>的第<code>j</code>个字符相同时，这个字符必然被加入到最长公共子序列当中，因此只需要加上选取<code>text1</code>的前<code>i - 1</code>个字符，<code>text2</code>的前<code>j - 1</code>个字符时的最长公共子序列长度即可</li><li>不相同则从<code>dp[i][j - 1]</code>和<code>dp[i - 1][j]</code>中选取最大值（顺序遍历，因此<code>dp[i][j - 1]</code>和<code>dp[i - 1][j]</code>已经完成更新了）</li></ul><p><strong>细节</strong></p><ul><li>第一行与第一列初始化为0，因为<code>dp</code>的更新可能需要基于上一行与上一列，因此将<code>dp</code>数组初始化为<code>dp[row + 1] [col + 1]</code>更合理</li><li><code>dp</code>存储的最长公共子序列长度是递增的，因此不需要动态维护答案，直接返回<code>dp[row] [col]</code>即可</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//  空字符串特殊情况处理</span></span><br><span class="line">        <span class="keyword">if</span> (text1 == <span class="string">&quot;&quot;</span> || text2 == <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  遍历text1和text2两个字符串，用一个二维数组记录</span></span><br><span class="line">        <span class="type">int</span> row = text1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = text2.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dp[row + <span class="number">1</span>][col + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  第一行和第一列的初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; col + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//  从第二行开始遍历，根据左边和上面进行值的确认</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; row + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; col + <span class="number">1</span>; ++j) &#123;</span><br><span class="line">                <span class="comment">//  当前字符相同</span></span><br><span class="line">                <span class="keyword">if</span> (text1[i - <span class="number">1</span>] == text2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//  当前字符不相同</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 递增的，因此不需要动态维护最大值</span></span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串*"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串*</a></h2><h3 id="题干-60"><a href="#题干-60" class="headerlink" title="题干"></a>题干</h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 回文 子串。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h3 id="题解-60"><a href="#题解-60" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li><code>dp</code>思路是当前字符串头和尾相等时，如果中间的字符串是回文的则当前字符串回文</li><li>使用<code>dp[i] [j]</code>表示字符串s从i到j的子串是否为回文</li><li>状态转移方程是<code>dp[i] [j] = s[i] == s[j] &amp;&amp; ((j - i) &lt; 2 || dp[i + 1] [j - 1])</code>，表示如果<code>s[i] == s[j]</code>，那么如果i到j只有一个字符或者两个字符则是回文的，或者中间字符串是回文的，则当前字符串回文</li><li>根据状态转移方程可以判断，状态依赖下一行和上一列，因此i需要逆向遍历，j需要正向遍历</li></ul><p><strong>细节</strong></p><ul><li>很巧妙的一点是<code>j - i &lt; 2</code>这个判断条件可以避免<code>dp[i + 1] [j - 1]</code>发生越界</li><li>当<code>i == s.size() - 1</code>时不会发生越界，因为条件判断在<code>j - i &lt; 2</code>就终止了</li><li>当<code>j == 0</code>时也不会发生越界，<code>j == 0</code>时条件判断在<code>j - i &lt; 2</code>就终止了</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最大长度</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// dp[i][j] 表示s从i到j的子串是否为回文</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移dp[i][j] = s[i] == s[j] &amp;&amp; ((j - i) &lt; 2 || dp[i + 1][j - 1])</span></span><br><span class="line">        <span class="comment">// 状态依赖下一行和上一列，因此i需要逆向遍历，j需要正向遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; <span class="number">-1</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// j大于等于i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; s.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="comment">// i = s.size() - 1时不会发生越界，因为条件判断在j - i &lt; 2就终止了</span></span><br><span class="line">                <span class="comment">// i = 0时也不会发生越界，j = 0时条件判断在j - i &lt; 2就终止了</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == s[j] &amp;&amp; (j - i &lt; <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">// 长度是j - i + 1</span></span><br><span class="line">                    <span class="keyword">if</span> (j - i + <span class="number">1</span> &gt; end - start + <span class="number">1</span>) &#123;</span><br><span class="line">                        end = j;</span><br><span class="line">                        start = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(start, end - start + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><h2 id="384-打乱数组（洗牌算法）"><a href="#384-打乱数组（洗牌算法）" class="headerlink" title="384. 打乱数组（洗牌算法）"></a><a href="https://leetcode.cn/problems/shuffle-an-array/">384. 打乱数组（洗牌算法）</a></h2><h3 id="题干-61"><a href="#题干-61" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>nums</code> ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 <strong>等可能</strong> 的。</p><p>实现 <code>Solution</code> class:</p><ul><li><code>Solution(int[] nums)</code> 使用整数数组 <code>nums</code> 初始化对象</li><li><code>int[] reset()</code> 重设数组到它的初始状态并返回</li><li><code>int[] shuffle()</code> 返回数组随机打乱后的结果</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Solution&quot;, &quot;shuffle&quot;, &quot;reset&quot;, &quot;shuffle&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], []]</span><br><span class="line">输出</span><br><span class="line">[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Solution solution = new Solution([1, 2, 3]);</span><br><span class="line">solution.shuffle();    // 打乱数组 [1,2,3] 并返回结果。任何 [1,2,3]的排列返回的概率应该相同。例如，返回 [3, 1, 2]</span><br><span class="line">solution.reset();      // 重设数组到它的初始状态 [1, 2, 3] 。返回 [1, 2, 3]</span><br><span class="line">solution.shuffle();    // 随机返回数组 [1, 2, 3] 打乱后的结果。例如，返回 [1, 3, 2]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 50</code></li><li><code>-106 &lt;= nums[i] &lt;= 106</code></li><li><code>nums</code> 中的所有元素都是 <strong>唯一的</strong></li><li>最多可以调用 <code>104</code> 次 <code>reset</code> 和 <code>shuffle</code></li></ul><h3 id="题解-61"><a href="#题解-61" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li><code>reset</code>需要存储一份原数组</li><li>随机打乱可以将随机选择的数放置到当前数组末尾，然后逐步减少随机选择范围，提高效率</li></ul><p><strong>细节</strong></p><p>循环应该从后往前遍历，便于选择项的交换</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; orginalNums;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; curNums;</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) : <span class="built_in">orginalNums</span>(nums), <span class="built_in">curNums</span>(nums) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        curNums = orginalNums;</span><br><span class="line">        <span class="keyword">return</span> curNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> randomIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = orginalNums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            randomIndex = <span class="built_in">rand</span>() % (i + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">swap</span>(curNums[i], curNums[randomIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curNums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution* obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_1 = obj-&gt;reset();</span></span><br><span class="line"><span class="comment"> * vector&lt;int&gt; param_2 = obj-&gt;shuffle();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C#常见概念与常用语法</title>
      <link href="/2024/06/06/439ed6e98726/"/>
      <url>/2024/06/06/439ed6e98726/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于C#的常见概念与常用语法。</p><h1 id="C-脚本生命周期"><a href="#C-脚本生命周期" class="headerlink" title="C#脚本生命周期"></a>C#脚本生命周期</h1><ul><li>Awake：初始化。</li><li>Enable：渲染启用时调用，初始化方法不能写在里面。</li><li>Start：第一次Enable后调用。</li><li>Update：每一帧调用一次。</li><li>LateUpdate：update执行完lateupdate就会执行。</li><li>FixedUpdate：类似定时器，定期执行，与机器性能帧数无关，仅和时间有关。默认0.02s。</li><li>UnDisable：非激活状态调用。</li><li>OnDestroy：销毁时调用。</li></ul><h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><ul><li><p>上一帧到下一帧的游戏时间Time.deltaTime。</p></li><li><p>时间缩放值Time.timeScale。</p></li></ul><h1 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h1><ul><li><p>游戏数据文件夹路径（只读，加密压缩）Applicants.dataPath。</p></li><li><p>持久化文件夹路径（可写）Applicants.persistentDataPath。</p></li><li><p>StreamingAssets文件夹路径（只读，不加密）Application.streamingAssetsPath。</p></li><li><p>临时文件夹Application.temporaryCachePath。</p></li><li><p>后台运行Application.runInBackground。</p></li><li><p>打开url Application.OpenURL。</p></li><li><p>退出游戏Application.Quit()。</p></li></ul><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><ul><li><p>SceneManager.CreateScene()创建场景。</p></li><li><p>SceneManager.LoadScene(“场景名称（编号）”)加载场景；LoadSceneMode参数设置为Single时只加载当前场景，设置为Additive时叠加场景。</p></li><li><p>SceneManager.LoadSceneAsync()异步加载场景，当场景很大时加载速度较慢。</p></li><li><p>SceneManager.UnloadSceneAsync()卸载场景。</p></li><li><p>SceneManager.GetActiveScene()获取当前场景。</p></li><li><p>Scene.GetRootGameObjects()获取场景中的所有游戏物体。</p></li></ul><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><ul><li><p>AsyncOperation作为异步加载场景SceneManager.LoadSceneAsync()的返回值，使用yield return返回一个协程IEnumerator，并使用StartCoroutine启动协程。</p></li><li><p>operation.progress可以查看加载进度，在UI制作时可以做进度条。</p></li><li><p>operation.allowSceneActivation可以控制场景是否跳转，设置为False不会自动跳转。</p></li></ul><h1 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h1><ul><li><p>transform.position是世界坐标系里的位置。</p></li><li><p>transform.localPosition是相对父物体的位置。</p></li><li><p>transform.LookAt(点坐标)看向某个点。</p></li><li><p>transform.Rotate(轴, 旋转度数)；transform.RotateAround(点，轴，旋转度数)。</p></li><li><p>transform.Translate()移动。</p></li><li><p>transform.parent.gameObject获取父物体。</p></li><li><p>transform.DetachChildren()解除所有子物体。</p></li><li><p>transform.GetChild(0)根据下标获取子物体；transform.Find(“子物体名称”)根据名称获得子物体。</p></li><li><p>SetParent()设置父物体。</p></li></ul><h1 id="键鼠操作"><a href="#键鼠操作" class="headerlink" title="键鼠操作"></a>键鼠操作</h1><ul><li><p>input.GetMouseButtonDown()按下鼠标；input.GetKeyDown(KeyCode)按下键盘。</p></li><li><p>input.GetMouseButton()按住鼠标；input.GetKey(KeyCode)按住键盘。</p></li><li><p>input.GetMouseButtonUP()松开鼠标；input.GetKeyUp(KeyCode)松开键盘。</p></li></ul><h1 id="触摸操作"><a href="#触摸操作" class="headerlink" title="触摸操作"></a>触摸操作</h1><p>判断触摸点数目使用Input.touchCount。判断触摸阶段，类似键鼠操作中的抬起按下，基于touch.phase。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Input.touchCount == <span class="number">1</span>) &#123;</span><br><span class="line">    Touch touch = Input.touches[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">switch</span>(touch.phase) &#123;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Began:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Moved:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Stationary:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Ended:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Cancled:</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  开启多点触摸</span></span><br><span class="line">Input.multiTouchEnabled = True;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Input.touchCount == <span class="number">2</span>) &#123;</span><br><span class="line">    Touch touch0 = Input.touches[<span class="number">0</span>];</span><br><span class="line">    Touch touch1 = Input.touches[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚拟轴"><a href="#虚拟轴" class="headerlink" title="虚拟轴"></a>虚拟轴</h1><ul><li><p>Input.GetAxis(“Horizontal”)表示水平虚拟轴，由ad或者左右控制，或者摇杆。</p></li><li><p>Input.GetAxis(“Vertical”)表示垂直虚拟轴，由ws或者前后控制，或者摇杆。</p></li><li><p>CharacterController.SimpleMove(向量)会朝着向量方向移动，向量dir设置为Vector3(horizontal, 0, vertical)，可以完成简单角色方向控制。</p></li></ul><h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><ul><li><p>OnCollisionEnter监听发生碰撞；OnCollisionStay监听碰撞持续中；OnCollisionExit监听碰撞结束。</p></li><li><p>Collision类里包含了碰撞的信息，可以用于查看碰撞物体名称等。</p></li></ul><h1 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h1><ul><li><p>OnTriggerEnter监听触发发生；OnCollisionStay监听触发持续中；OnCollisionExit监听触发结束。</p></li><li><p>勾选是触发器选项后，不一样的地方在于，它不受物理影响，可以直接穿透而不会有碰撞体积，但同时可以检测到碰撞。</p></li></ul><hr><p>2024.8.29</p><p>很久没写，我决定重启我的blog，最近基本都在使用Unity和编写C#脚本，然后就是用Python搭模型调参数…</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DWA path planning algorithm</title>
      <link href="/2023/11/21/bcabc54fc9a6/"/>
      <url>/2023/11/21/bcabc54fc9a6/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了关于动态窗口算法(Dynamic Window Approaches, DWA)的一些基本概念与算法步骤。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>动态窗口算法(Dynamic Window Approaches, DWA)，核心思想是根据无人设备当前的位置状态和速度状态在速度空间 (v,ω) 中确定一个满足无人设备硬件约束的采样速度空间，然后计算无人设备在这些速度情况下移动一定时间内的轨迹，并通过评价函数对该轨迹进行评价，最后选出评价最优的轨迹所对应的速度作为无人设备运动速度，如此循环直至移动无人设备到达目标点。</p><p>系统设计过程中对动态窗口算法的实现主要从三个方面出发，速度采样、轨迹预测、轨迹评价。</p><h1 id="速度采样"><a href="#速度采样" class="headerlink" title="速度采样"></a>速度采样</h1><p>现实中不同型号的无人设备所具有的硬件和结构不同，在物理层面上存在一定的限制，例如马力和重量会导致其最大加速度和最大转向加速度受到限制，反映在运动上的限制是运行速度的改变和方向变换的及时性。</p><p>在系统的仿真模拟中，不同模型的无人船也会设置不同的加速度参数，动态窗口算法的速度采样空间<strong>V</strong>s会收到约束。</p><p>速度范围约束：由于真实环境中阻力等物理因素的存在，针对无人船进行建模时根据它的型号对线速度和角速度范围进行了限制，v∈[vmin ,vmax ]，ω∈[ωmin ,ωmax ]。在此条件下可采样的速度空间Vm的限定范围：</p>$${V}_m=\lbrace(v,ω)∣v∈[v_{min} ,v_{max} ],ω∈[ω_{min} ,ω_{max} ]\rbrace$$<p>加速度约束：针对某一时间点，忽略加速度变化所需时间，线加速度和角加速度的范围被约束在av∈[-avmax ,avmax]，aω∈[-aωmax ,aωmax]，假定vc、ωc 分别为无人船当前时刻的线速度和角速度，在极短的时间Δt内，可采样的速度空间<strong>V</strong>d也被限定：</p>$${V}_d=\lbrace(v,ω)∣v∈[v_c−a_{vmax}⋅Δt,v_c+a_{vmax}·Δt], ω∈[ω_c−a_{ωmax}·Δt,ω_c+a_{ωmax}·Δt]\rbrace$$<p>障碍物安全距离约束：当无人船与障碍物之间的距离缩小到达一定程度时，此时即使采用最大加速度进行减速，也无法避免的发生碰撞，基于此对速度采样空间也进行了限制：</p>$${V}_a=\lbrace(v,ω)∣v∈[v_{min} ,2·dist·a_{vmax} ],ω∈[ω_{min} ,2·dist·a_{ωmax} ]\rbrace$$<p>其中，dist表示当前无人设备的位置与障碍物的最近距离。综合以上三个速度空间的限制，通过取交集获取最终的速度采样空间，即：</p>$$V_s=V_m∩V_d∩V_a$$<h1 id="轨迹预测"><a href="#轨迹预测" class="headerlink" title="轨迹预测"></a>轨迹预测</h1><p>在完成了速度采样空间<strong>V</strong>s的确认之后，根据动态窗口算法设置的采样率来对采样空间进行拆分组合。分别用<strong>Ev</strong>和<strong>Ew</strong>表示表示线速度和角速度的采样频率，即每间隔<strong>Ev</strong>进行一次速度采样，根据排列组合能够组成的线速度与角速度组数：</p>$$n=[(v_{high}−v_{low})/E_v]⋅[(w_{high}−w_{low})/E_w]$$<p>每一组(v,ω)按照设置的无人船运动模型，计算其在设置的预测时间内运动轨迹并保存，系统采用的运动模型是差分驱动模型：</p>$$\left\{\begin{aligned}x_k & = x_{k−1}+v⋅\cos(θ_{k−1})Δt \\y_k & = y_{k−1}+v⋅\sin(θ_{k−1})Δt \\θ_k & = θ_{k-1}+ωΔt\end{aligned}\right.$$<p>其中，(x,y,θ)代表无人船的位置状态，k代表采样时刻，Δt代表采样间隔。</p><h1 id="轨迹评价"><a href="#轨迹评价" class="headerlink" title="轨迹评价"></a>轨迹评价</h1><p>经过轨迹预测后得到的n组轨迹，需要经过评价函数来选择最优的轨迹作为无人船接下来的运动轨迹。轨迹评价考虑三个方面：方位角评价，评估轨迹末端位置方向与目标点连线的夹角误差，引导无人船朝向目标；距离评价，计算当前速度下轨迹与障碍物之间的最近距离，避免无人船与障碍物发生碰撞；速度评价，表示当前的速度大小，鼓励无人船保持较高的速度以提高导航效率。</p><p>评价函数量化表现为：</p>$$G(v,ω)=σ(α⋅heading(v,ω)) + σ(β⋅dist(v,ω)) + σ(γ⋅velocity(v,ω))$$<p>其中，heading(v, ω)是方位角的评价函数，轨迹终点方向与目标终点的夹角为Δθ，用heading(v, ω) &#x3D; π – Δθ作为方位角的评价函数，则夹角越小评分越高。dist(v,ω)是距离的评价函数，表示当前状态下无人船与障碍物的最小距离，距离越远越安全，评分越高。velocity(v,ω)是速度评价函数，直接用当前线速度大小作为函数值，在当前方向上的速度越快意味着轨迹越优。</p><p>α、β 、γ均为评价函数的系数，当我们对哪一部分的评分更加看重时可以通过调节评价系数来调整对轨迹的选择。σ则是对评价函数的归一化处理：</p>$$\left\{\begin{aligned}σ⋅ heading(v,ω) &=normalize\_heading(i)= \frac{heading(i)}{\sum_{i=1}^nheading(i)}  \\σ⋅dist(v,ω) &= normalize\_dist (i)= \frac{dist (i)}{\sum_{i=1}^ndist (i)} \\σ⋅velocity(v,ω) &= normalize\_velocity (i)= \frac{velocity (i)}{\sum_{i=1}^nvelocity (i)}\end{aligned}\right.$$<p>其中，n是采样速度空间的组合数目即轨迹数目。</p><p>经过速度采样、轨迹预测、轨迹评价后，得到当前无人船的运动仿真轨迹，如下图所示:</p><p><img src="https://s2.loli.net/2024/08/29/TevJR5LUgKdczEO.gif" alt="image13.gif"></p><p>图中蓝色曲线是通过评价函数选定的最优（仅针对动态窗口算法的评价标准）路径，绿色区域是由n条待评价轨迹组合成的，表示无人船可能的轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 无人船仿真系统 </category>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A* path planning algorithm</title>
      <link href="/2023/11/21/4f6190916ab7/"/>
      <url>/2023/11/21/4f6190916ab7/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了关于A*路径规划算法的一些基本概念与算法步骤。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>G：起点A到网格中的指定点所花费的代价</p><p>H：指定点到终点所花费的代价</p><p>F：F &#x3D; G + H，起点到终点经过指定点的总代价</p><p>open_list：用来寻找最短的路径的中间点</p><p>closed_list：不会被考虑的点</p><p>结束条件：1. 终点出现在open_list；2. open_list为空</p><h1 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h1><ol><li>从起点S开始，把S作为一个等待检查的方格，放入到open_list中</li><li>寻找起点S周围可以到达的方格(最多八个) ，将它们放入到open_list，并设置它们的父方格为S</li><li>从open_list中删除起点S，并将放入到closed_list中(closed_list存放的是不再需要检查的方格)</li><li>计算每个周围方格的F值</li><li>从open_list中选择F值最低的方格，将它从open_list中移除，并且把它可达的方格（障碍和closed_list中的方格舍弃）加入到open_list</li><li>如果可达方格不在open_list中，则父方格设置为当前方格；如果可达方格已经在open_list中，已当前方格为中间点得到的G值比原来的更小，则更新父节点为当前节点，F &#x3D; G’ + H，否则不变</li><li>循环从open_list中找F值最小的点来更新，直到结束条件</li></ol><h1 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h1><p>关于最终代价的计算，首先需要将地图进行网格化如图所示，每个方格视作为一个节点，蓝色方格是障碍物，白色方格是可通过区域，绿色方格是起点，红色方格是终点。</p><p>​    <img src="https://s2.loli.net/2024/08/29/yaJpxu1tvNFEQjD.png#pic_center" alt="素材1.png">                           </p><p>其次需要添加一些约束，针对一个节点，可以选择朝其周围的8个方向移动一个方格，其中朝上、下、左、右移动的成本为 10，朝左上、右上、左下、右下移动的成本为 14（10√2 近似值），蓝色区域也就是障碍物区域表示不可移动。</p><p>实际代价的计算可以由待检查节点向八个方向出发并计算代价，而预计代价的计算则只考虑横纵向的移动，然后把总数乘以 10，通过实际代价与预计代价的叠加来进行启发，如下图的A*算法代价计算示例。<br><img src="https://s2.loli.net/2024/08/29/5vp8xhZaCeODyob.png#pic_center" alt="素材2.png"></p><p>每个方格都标上了综合代价，实际代价，预计代价的值，方格左上角表示综合代价，左下角即从起点到当前节点的实际代价，右下角即由当前节点到终点的预计代价 。最终通过A*算法得到的路径代价计算值为68，按照下图中的方式进行回溯得到路径。</p><p> <img src="https://s2.loli.net/2024/08/29/vc4kDKmgu187wYp.png#pic_center" alt="素材3.png"></p><h1 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h1><p>快手二面的时候面试官居然让我手撕A*，实在没想到，很久没写最后只写了个大概然后讲了一下思路，面完立马灰溜溜的重新捡起来了一遍</p><ol><li>使用<code>unordered_map</code>实现<code>open_list</code>和<code>close_list</code>的快速查询（空间换时间），<code>key</code>是<code>m * row + col</code>，<code>value</code>是节点指针</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> row, col, F, H, G; <span class="comment">// 横坐标，纵坐标，综合代价，估计代价，实际代价</span></span><br><span class="line">    shared_ptr&lt;Node&gt; prev; <span class="comment">// 前缀节点</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _row, <span class="type">int</span> _col) : <span class="built_in">row</span>(_row), <span class="built_in">col</span>(_col), <span class="built_in">F</span>(<span class="number">0</span>), <span class="built_in">H</span>(<span class="number">0</span>), <span class="built_in">G</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _row, <span class="type">int</span> _col, <span class="type">int</span> _G, <span class="type">int</span> _H, shared_ptr&lt;Node&gt; _prev) : <span class="built_in">row</span>(_row), <span class="built_in">col</span>(_col), <span class="built_in">G</span>(_G), <span class="built_in">H</span>(_H), <span class="built_in">prev</span>(_prev) &#123;</span><br><span class="line">        F = G + H;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列比较函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(shared_ptr&lt;Node&gt; a, shared_ptr&lt;Node&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;F &gt; b-&gt;F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算估计代价H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate_H</span><span class="params">(<span class="type">int</span> cur_row, <span class="type">int</span> cur_col, <span class="type">int</span> end_row, <span class="type">int</span> end_col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(end_row - cur_row) + <span class="built_in">abs</span>(end_col - cur_col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Graph = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 行数</span></span><br><span class="line">    <span class="type">int</span> m = Graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 列数</span></span><br><span class="line">    <span class="type">int</span> n = Graph[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 目标节点</span></span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 起始节点</span></span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">calculate_H</span>(<span class="number">2</span>, <span class="number">0</span>, end-&gt;row, end-&gt;col), <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;shared_ptr&lt;Node&gt;, vector&lt;shared_ptr&lt;Node&gt;&gt;, cmp&gt; open_list;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, shared_ptr&lt;Node&gt;&gt; close_set;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, shared_ptr&lt;Node&gt;&gt; open_set;</span><br><span class="line">    open_list.<span class="built_in">push</span>(start);</span><br><span class="line">    open_set[m * start-&gt;row + start-&gt;col] = start;</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; neighbors = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>,  <span class="number">0</span>&#125;, &#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>,  <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>,  <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>,  <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 从当前节点启发式搜索到目标节点</span></span><br><span class="line">    <span class="keyword">while</span> (!open_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = open_list.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;neighbor: neighbors) &#123;</span><br><span class="line">            <span class="type">int</span> new_row = cur-&gt;row + neighbor.first;</span><br><span class="line">            <span class="type">int</span> new_col = cur-&gt;col + neighbor.second;</span><br><span class="line">            <span class="comment">// 如果新节点超出边界或者是障碍物，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (new_row &lt; <span class="number">0</span> || new_row &gt;= m || new_col &lt; <span class="number">0</span> || new_col &gt;= n || Graph[new_row][new_col] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> new_node = <span class="built_in">make_shared</span>&lt;Node&gt;(new_row, new_col,</span><br><span class="line">                                              cur-&gt;G + (neighbor.first == <span class="number">0</span> || neighbor.second == <span class="number">0</span> ? <span class="number">10</span> : <span class="number">14</span>),</span><br><span class="line">                                              <span class="built_in">calculate_H</span>(new_row, new_col, end-&gt;row, end-&gt;col), cur);</span><br><span class="line">            <span class="type">int</span> new_key = m * new_row + new_col;</span><br><span class="line">            <span class="comment">// 如果新节点在close_list中，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (close_set.<span class="built_in">find</span>(new_key) != close_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果新节点是目标节点，输出路径</span></span><br><span class="line">            <span class="keyword">if</span> (new_row == end-&gt;row &amp;&amp; new_col == end-&gt;col) &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = new_node;</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; temp-&gt;row &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; temp-&gt;col &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    temp = temp-&gt;prev;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查新节点是否在开放列表中</span></span><br><span class="line">            <span class="keyword">auto</span> it = open_set.<span class="built_in">find</span>(new_key);</span><br><span class="line">            <span class="comment">// 如果新节点不在open_list中，将新节点加入open_list</span></span><br><span class="line">            <span class="keyword">if</span> (it == open_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                open_list.<span class="built_in">push</span>(new_node);</span><br><span class="line">                open_set[new_key] = new_node;</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">// 如果新节点在open_list中，更新新节点的代价</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> old_node = it-&gt;second;</span><br><span class="line">                <span class="keyword">if</span> (new_node-&gt;G &lt; old_node-&gt;G) &#123;</span><br><span class="line">                    old_node-&gt;G = new_node-&gt;G;</span><br><span class="line">                    old_node-&gt;F = old_node-&gt;G + old_node-&gt;H;</span><br><span class="line">                    old_node-&gt;prev = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前节点从open_list中移除，加入close_list</span></span><br><span class="line">        open_list.<span class="built_in">pop</span>();</span><br><span class="line">        open_set.<span class="built_in">erase</span>(m * cur-&gt;row + cur-&gt;col);</span><br><span class="line">        close_set[m * cur-&gt;row + cur-&gt;col] = cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>重载相等运算符并且编写节点哈希函数的版本</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> row, col, F, H, G; <span class="comment">// 横坐标，纵坐标，综合代价，估计代价，实际代价</span></span><br><span class="line">    shared_ptr&lt;Node&gt; prev; <span class="comment">// 前缀节点</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _row, <span class="type">int</span> _col) : <span class="built_in">row</span>(_row), <span class="built_in">col</span>(_col), <span class="built_in">F</span>(<span class="number">0</span>), <span class="built_in">H</span>(<span class="number">0</span>), <span class="built_in">G</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _row, <span class="type">int</span> _col, <span class="type">int</span> _G, <span class="type">int</span> _H, shared_ptr&lt;Node&gt; _prev) : <span class="built_in">row</span>(_row), <span class="built_in">col</span>(_col), <span class="built_in">G</span>(_G), <span class="built_in">H</span>(_H), <span class="built_in">prev</span>(_prev) &#123;</span><br><span class="line">        F = G + H;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Node &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> row == other.row &amp;&amp; col == other.col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点哈希函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NodeHash</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> shared_ptr&lt;Node&gt; &amp;node)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(node-&gt;row) ^ <span class="built_in">hash</span>&lt;<span class="type">int</span>&gt;()(node-&gt;col);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优先队列比较函数</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(shared_ptr&lt;Node&gt; a, shared_ptr&lt;Node&gt; b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;F &gt; b-&gt;F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算估计代价H</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">calculate_H</span><span class="params">(<span class="type">int</span> cur_row, <span class="type">int</span> cur_col, <span class="type">int</span> end_row, <span class="type">int</span> end_col)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(end_row - cur_row) + <span class="built_in">abs</span>(end_col - cur_col);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查节点是否在关闭列表中</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">inCloseList</span><span class="params">(unordered_set&lt;shared_ptr&lt;Node&gt;, NodeHash&gt; &amp;close_list, shared_ptr&lt;Node&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> close_list.<span class="built_in">find</span>(node) != close_list.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; Graph = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,</span><br><span class="line">                                 &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 行数</span></span><br><span class="line">    <span class="type">int</span> m = Graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 列数</span></span><br><span class="line">    <span class="type">int</span> n = Graph[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 目标节点</span></span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="comment">// 起始节点</span></span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">make_shared</span>&lt;Node&gt;(<span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">calculate_H</span>(<span class="number">2</span>, <span class="number">0</span>, end-&gt;row, end-&gt;col), <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;shared_ptr&lt;Node&gt;, vector&lt;shared_ptr&lt;Node&gt;&gt;, cmp&gt; open_list;</span><br><span class="line">    unordered_set&lt;shared_ptr&lt;Node&gt;, NodeHash&gt; close_set;</span><br><span class="line">    unordered_set&lt;shared_ptr&lt;Node&gt;, NodeHash&gt; open_set;</span><br><span class="line">    open_list.<span class="built_in">push</span>(start);</span><br><span class="line">    open_set.<span class="built_in">insert</span>(start);</span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; neighbors = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>,  <span class="number">0</span>&#125;, &#123;<span class="number">0</span>,  <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>,  <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>,  <span class="number">1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>,  <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">    <span class="comment">// 从当前节点启发式搜索到目标节点</span></span><br><span class="line">    <span class="keyword">while</span> (!open_list.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> cur = open_list.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;neighbor: neighbors) &#123;</span><br><span class="line">            <span class="type">int</span> new_row = cur-&gt;row + neighbor.first;</span><br><span class="line">            <span class="type">int</span> new_col = cur-&gt;col + neighbor.second;</span><br><span class="line">            <span class="comment">// 如果新节点超出边界或者是障碍物，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (new_row &lt; <span class="number">0</span> || new_row &gt;= m || new_col &lt; <span class="number">0</span> || new_col &gt;= n || Graph[new_row][new_col] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">auto</span> new_node = <span class="built_in">make_shared</span>&lt;Node&gt;(new_row, new_col,</span><br><span class="line">                                              cur-&gt;G + (neighbor.first == <span class="number">0</span> || neighbor.second == <span class="number">0</span> ? <span class="number">10</span> : <span class="number">14</span>),</span><br><span class="line">                                              <span class="built_in">calculate_H</span>(new_row, new_col, end-&gt;row, end-&gt;col), cur);</span><br><span class="line">            <span class="comment">// 如果新节点在close_set中，直接跳过</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">inCloseList</span>(close_set, new_node)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果新节点是目标节点，输出路径</span></span><br><span class="line">            <span class="keyword">if</span> (new_row == end-&gt;row &amp;&amp; new_col == end-&gt;col) &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = new_node;</span><br><span class="line">                <span class="keyword">while</span> (temp != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; temp-&gt;row &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; temp-&gt;col &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; endl;</span><br><span class="line">                    temp = temp-&gt;prev;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 检查新节点是否在开放列表中</span></span><br><span class="line">            <span class="keyword">auto</span> it = open_set.<span class="built_in">find</span>(new_node);</span><br><span class="line">            <span class="comment">// 如果新节点不在open_list中，将新节点加入open_list</span></span><br><span class="line">            <span class="keyword">if</span> (it == open_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                open_list.<span class="built_in">push</span>(new_node);</span><br><span class="line">                open_set.<span class="built_in">insert</span>(new_node);</span><br><span class="line">            &#125;</span><br><span class="line">                <span class="comment">// 如果新节点在open_list中，更新新节点的代价</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">auto</span> old_node = *it;</span><br><span class="line">                <span class="keyword">if</span> (new_node-&gt;G &lt; old_node-&gt;G) &#123;</span><br><span class="line">                    old_node-&gt;G = new_node-&gt;G;</span><br><span class="line">                    old_node-&gt;F = old_node-&gt;G + old_node-&gt;H;</span><br><span class="line">                    old_node-&gt;prev = cur;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前节点从open_list中移除，加入close_set</span></span><br><span class="line">        open_list.<span class="built_in">pop</span>();</span><br><span class="line">        open_set.<span class="built_in">erase</span>(cur);</span><br><span class="line">        close_set.<span class="built_in">insert</span>(cur);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 无人船仿真系统 </category>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见船舶局部路径规划算法</title>
      <link href="/2023/11/20/b6efb589d40f/"/>
      <url>/2023/11/20/b6efb589d40f/</url>
      
        <content type="html"><![CDATA[<p>本文是一篇综述，从<strong>路径搜索</strong>和<strong>轨迹优化</strong>这两个层面来对目前的路径规划算法进行总结。</p><h1 id="路径搜索"><a href="#路径搜索" class="headerlink" title="路径搜索"></a>路径搜索</h1><p><img src="https://s2.loli.net/2023/11/21/J6virsL3NZtRhn1.jpg" alt="img"></p><h2 id="Astar"><a href="#Astar" class="headerlink" title="Astar*"></a>Astar*</h2><p>文章提到了两种Astar的改进算法：一种稀疏Astar算法，对转角的最大增量做了限制，得到的曲线更加平滑；一种结合自适应替换缓存（ARC）策略与基于Astar算法的Theta star算法——<a href="https://www.sciencedirect.com/science/article/abs/pii/S0029801814001292?via=ihub">Angular rate-constrained path planning algorithm for unmanned surface vehicles</a>，考虑了角速度约束得到了更符合其运动特性的规划路径（我认为比较符合我们的需求）</p><p><img src="https://s2.loli.net/2023/11/21/xUPiMm4nuDg5HQo.jpg" alt="img"></p><p>另外除了海域内的障碍，还需要考虑到船只，以及船舶安全领域、国际海上避碰规则等真实因素限制。</p><h2 id="虚拟势场法"><a href="#虚拟势场法" class="headerlink" title="虚拟势场法"></a>虚拟势场法</h2><p>包含人工势场法和快速行进法</p><h3 id="人工势场法"><a href="#人工势场法" class="headerlink" title="人工势场法*"></a>人工势场法*</h3><p>人工势场APF借鉴了电势场的概念，目标点产生引力，而障碍物产生斥力，引力场与斥力场叠加形成包含引导USV到达目标点及避障信息的人工势场。传统APF针对动态避障效果较差，集群运动需要考虑到船舶之间的距离。</p><p><a href="https://www.sciencedirect.com/science/article/pii/S002980182100144X">The hybrid path planning algorithm based on improved A* and artificial potential field for unmanned surface vehicle formations</a>这篇论文中提出的改进APF方法，在结合Astar算法的前提下，对集群编队采用了优先策略，设置一个领队，一个跟随者，一个副跟随者。通过检测船舶之间的距离对速度进行控制来避免集群之间碰撞：跟随者与副跟随者距离靠近时，副跟随者减速，反之加速。形成队形后再按照Astar规划的路径前行。</p><p><img src="https://s2.loli.net/2023/11/21/K4IfGyRlWCZpvok.jpg" alt="img"></p><h3 id="快速进行法"><a href="#快速进行法" class="headerlink" title="快速进行法"></a>快速进行法</h3><p>$|∇(T(s))|W(s)&#x3D;1$</p><p>利用二值栅格法进行环境建模，将障碍物区域设为$W(i, j)&#x3D;0$，将可通行区域设为。$W(i, j)&#x3D;1$通过数值求解程函方程，得到地图中各网格点的<em>T</em>值，将其视为势场值，从而建立虚拟势场</p><p>与APF法相比，FMM法构建势场唯一的极小值点便是起点，不存在路径陷入局部极小值问题（暂时不考虑）</p><h2 id="智能算法"><a href="#智能算法" class="headerlink" title="智能算法"></a>智能算法</h2><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>GA算法的实时性较差，一般不用于实时规划，用于离线规划，暂不考虑</p><h3 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a>粒子群算法</h3><p>通过最优解的位置启发其它粒子朝着最优解方向前进，从而实现粒子群整体朝着最优解的方向收敛，本文中提到的算法年代久远了需要重新调研</p><p><img src="https://s2.loli.net/2023/11/13/yQ9gjscvZRGKYDr.png" alt="image-20231113111655572"></p><p>$v_{i,d}$为当前代数下粒子运动速度；$x_{i,d}$为当前代数下粒子位置；$P_{i,d}$为当前代数下的最优解；$P_{g,d}$为历史（全局）最优解；$ω$为惯性权重；$c_1$和$c_2$为学习因子；$r_1$和$r_2$为[0 1]区间内的随机小数；<em>t</em>为当前迭代数。PSO算法首先初始化一群随机粒子，再通过上式进行迭代和进化，从而找到最优解</p><blockquote><p><strong>TODO</strong> 这篇文章提到的智能算法感觉不是很满意，暂时跳过，后续调研寻找新的算法补充上来</p></blockquote><h1 id="轨迹优化"><a href="#轨迹优化" class="headerlink" title="轨迹优化"></a>轨迹优化</h1><h2 id="Dubins"><a href="#Dubins" class="headerlink" title="Dubins"></a>Dubins</h2><p>直线与圆弧组合的曲线，简便易行、计算量小；曲率变化不连续，在直线段与圆弧段的交点处曲率发生突变</p><h2 id="Reeds-Shepp"><a href="#Reeds-Shepp" class="headerlink" title="Reeds-Shepp"></a>Reeds-Shepp</h2><p>针对可以倒退的模型可以规划出更短的路径</p><h2 id="三次样条曲线"><a href="#三次样条曲线" class="headerlink" title="三次样条曲线"></a>三次样条曲线</h2><p>把区间[a,b]分成n个区间，每个小区间的曲线是一个三次方程，路径连续平滑，适合用于优化折线路径</p><h2 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2><p>由起点，终点，控制点组成，调整控制点，贝塞尔曲线的形状会发生变化。计算速度和曲线形状控制方面优于三次样条曲线</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只是初步的调研，目标是寻找一个能够考虑到物理约束（最大角速度）的算法，或者对给出的路径进行较好的轨迹优化</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 仿真系统 </category>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
            <tag> 曲线优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Flask与SpringCloud的酒店管理系统</title>
      <link href="/2023/09/13/5e9fd62c1bea/"/>
      <url>/2023/09/13/5e9fd62c1bea/</url>
      
        <content type="html"><![CDATA[<p>本项目用于辅助SpringCloud相关技术的学习，通过代码实践进行学习。</p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>经过对SpringCloud的基础知识学习后，希望将它应用到酒店管理系统这个项目中去。我的规划如下：</p><ul><li>在功能需求已知的情况下，分析并将业务拆解成多个模块实现微服务架构</li><li>进行初步的实体类设计，数据库设计</li><li>优先使用已掌握技能完成基础功能模块，如处理秒杀库存暂时不考虑使用分布式锁，目前计划使用synchronized解决</li></ul><p>当前阻力：</p><ul><li>前端设计</li><li>用户权限控制管理这块没有系统的学习，只能基础的使用JWT进行token解析</li><li>Flask框架并没有实际上手写过，也并没有使用Python进行过与数据库交互的项目开发，没有编写过脚本</li><li>消息中间件没有过多实际编码经验，尚无法确认能否顺利投入到项目使用中</li></ul><p>理想状态：</p><ul><li><input checked="" disabled="" type="checkbox"> 能够熟练的使用SpringCloud对项目各个服务模块进行开发</li><li><input disabled="" type="checkbox"> 引入消息中间件来实现对高并发的支持，引入redis缓存来提高秒杀效率</li><li><input disabled="" type="checkbox"> 补充SpringSecurity知识，对权限认证进行完善</li></ul><hr><p>2023.09.13</p><p>redis和SpringSecurity在后续学习的时候再用于这个项目</p><p>2024.11.22</p><p>把我自己都看笑了，太能🕊了</p><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>仅针对Java部分的SpringCloud微服务设计</p><ol><li>用户管理模块：负责处理用户的注册、登录、基本信息维护等功能。</li><li>酒店信息管理模块：负责处理酒店列表、基本信息、细节信息的维护等功能。</li><li>订单管理模块：负责处理用户预定的订单，包括浏览订单等功能。</li><li>管理员客户管理模块：负责帮助客户重置密码，生成新的随机密码，删除用户</li></ol><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>针对酒店管理系统的业务进行数据库设计和类图的设计</p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><strong>t_user</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">用户id</td></tr><tr><td align="center">username</td><td align="center">varchar</td><td align="center">255</td><td align="center">用户名</td></tr><tr><td align="center">password</td><td align="center">varchar</td><td align="center">255</td><td align="center">密码</td></tr><tr><td align="center">salt</td><td align="center">varchar</td><td align="center">255</td><td align="center">盐值</td></tr><tr><td align="center">sex</td><td align="center">int</td><td align="center"></td><td align="center">性别(女0，男1)</td></tr><tr><td align="center">type</td><td align="center">int</td><td align="center"></td><td align="center">类型(0未成年人，1成年人)</td></tr><tr><td align="center">identity</td><td align="center">int</td><td align="center"></td><td align="center">身份(0为普通用户，1为用户管理员，2为酒店管理人员，3为酒店管理员)</td></tr><tr><td align="center">idcn</td><td align="center">char</td><td align="center">18</td><td align="center">身份证号码</td></tr><tr><td align="center">real_name</td><td align="center">varchar</td><td align="center">255</td><td align="center">真实姓名</td></tr><tr><td align="center">phone</td><td align="center">varchar</td><td align="center">255</td><td align="center">电话号码</td></tr><tr><td align="center">email</td><td align="center">varchar</td><td align="center">255</td><td align="center">邮箱</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_hotel</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">用户id</td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center">255</td><td align="center">酒店名称</td></tr><tr><td align="center">address</td><td align="center">varchar</td><td align="center">255</td><td align="center">酒店地址</td></tr><tr><td align="center">introduction</td><td align="center">varchar</td><td align="center">255</td><td align="center">酒店介绍</td></tr><tr><td align="center">phone</td><td align="center">varchar</td><td align="center"></td><td align="center">联系方式</td></tr><tr><td align="center">stars</td><td align="center">int</td><td align="center"></td><td align="center">星级</td></tr><tr><td align="center">brand</td><td align="center">varchar</td><td align="center">255</td><td align="center">品牌</td></tr><tr><td align="center">business_district</td><td align="center">varchar</td><td align="center">255</td><td align="center">所属商圈</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_order</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">订单id</td></tr><tr><td align="center">user_id</td><td align="center">int</td><td align="center">255</td><td align="center">用户id</td></tr><tr><td align="center">room_id</td><td align="center">int</td><td align="center">255</td><td align="center">房间id</td></tr><tr><td align="center">check_in_date</td><td align="center">datetime</td><td align="center">255</td><td align="center">入住日期</td></tr><tr><td align="center">check_out_date</td><td align="center">datetime</td><td align="center"></td><td align="center">退房日期</td></tr><tr><td align="center">room_num</td><td align="center">int</td><td align="center"></td><td align="center">房间数量</td></tr><tr><td align="center">expected_guest_num</td><td align="center">int</td><td align="center"></td><td align="center">预期入住人数</td></tr><tr><td align="center">has_children</td><td align="center">int</td><td align="center">18</td><td align="center">是否有儿童（0无1有）</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">255</td><td align="center">订单状态（0未支付，1已支付，2已取消）</td></tr><tr><td align="center">price</td><td align="center">decimal</td><td align="center">255</td><td align="center">订单价格</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_room</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">房间id</td></tr><tr><td align="center">hotel_id</td><td align="center">int</td><td align="center"></td><td align="center">所属酒店id</td></tr><tr><td align="center">num</td><td align="center">int</td><td align="center"></td><td align="center">剩余数量</td></tr><tr><td align="center">type</td><td align="center">varchar</td><td align="center">255</td><td align="center">房间类型（0单人间，1双床房，2大床房）</td></tr><tr><td align="center">original_price</td><td align="center">decimal</td><td align="center"></td><td align="center">原价</td></tr><tr><td align="center">price</td><td align="center">decimal</td><td align="center"></td><td align="center">当前价格</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_facilities</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">设施id</td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center">255</td><td align="center">设施名称</td></tr><tr><td align="center">is_free</td><td align="center">int</td><td align="center"></td><td align="center">是否免费(0付费，1免费)</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_hotel_facilities</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">hotel_id</td><td align="center">int</td><td align="center"></td><td align="center">酒店id</td></tr><tr><td align="center">facilities_id</td><td align="center">int</td><td align="center"></td><td align="center">设施id</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><hr><p>2023.09.13</p><p>t_facilities设计有问题，is_free字段应该放在t_hotel_facilities中而不是t_facilities中；其次为用户增加了一个hotel_id的字段，提供给酒店管理人员标识其管理的酒店</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>有机会再补吧，先🕊了</p><p>2023.09.13</p><p>不会再补了，彻底🕊了</p><h1 id="用户业务"><a href="#用户业务" class="headerlink" title="用户业务"></a>用户业务</h1><h2 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h2><p>以前写项目的时候根本没有怎么考虑过权限问题，很简单的做了一个token验证就结束了，现在自己开始考虑到这些问题发现自己根本想不到什么好的解决方案。</p><p>首先担心的是同角色之间资源的相互访问问题，也许可以通过验证用户的角色身份来解决一部分问题，但是如果同角色试图访问其他用户的资源，不对token中的用户id进行解析是没法解决的。这样的话我在Gateway的微服务中还需要添加与数据库的连接，我不知道是不是必须如此…我主观上是这么想的，确实想不到更优雅的办法，但是感觉这样子会很笨。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取请求头</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">    <span class="comment">//  请求路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line">    <span class="comment">//  判断是否需要核验token</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要token</span></span><br><span class="line">    <span class="keyword">if</span>(tokenShouldCheck(requestPath)) &#123;</span><br><span class="line">      <span class="comment">//  不包含token</span></span><br><span class="line">      <span class="keyword">if</span>(!headers.containsKey(<span class="string">&quot;Authorization&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  核验token是否有效,以及用户权限能否获取资源</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> headers.getFirst(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.getClaimsByToken(token);</span><br><span class="line">      <span class="comment">//  过期</span></span><br><span class="line">      <span class="keyword">if</span>(claims.getExpiration().getTime() &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().getTime()) &#123;</span><br><span class="line">        <span class="comment">//  token过期，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  没有过期，对权限进行验证  </span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  传递给下一个过滤器</span></span><br><span class="line">    <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">tokenShouldCheck</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !path.equals(<span class="string">&quot;/users/login&quot;</span>) &amp;&amp; !path.equals(<span class="string">&quot;/users/register&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整段代码我只能说，和优雅是完全不沾边，感觉过滤器只学到了皮毛…</p><hr><p>2023&#x2F;09&#x2F;06</p><p>在昨晚写下博客之后又自己捣鼓了好久，发现我确实学的不精…</p><p>我最开始的思路是用feign来获取用户信息，但是我居然认为feign的远程调用要经过http，所以我放弃了这个想法。如果真是这样的话，那微服务中使用feign调用其他微服务来实现功能都没法成立了，毕竟你在实现中哪来的token（如果要做token验证）</p><p>于是使用feign解决了，但是确实不算优雅</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  UserClient userClient;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取请求头</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">    <span class="comment">//  从请求中获取参数</span></span><br><span class="line"><span class="comment">//    MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span></span><br><span class="line">    <span class="comment">//  请求路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要token</span></span><br><span class="line">    <span class="keyword">if</span>(tokenShouldCheck(requestPath)) &#123;</span><br><span class="line">      <span class="comment">//  不包含token</span></span><br><span class="line">      <span class="keyword">if</span>(!headers.containsKey(<span class="string">&quot;Authorization&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  核验token是否有效,以及用户权限能否获取资源</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> headers.getFirst(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      <span class="comment">//  空token</span></span><br><span class="line">      <span class="keyword">if</span>(token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.getClaimsByToken(token);</span><br><span class="line">      <span class="comment">//  过期</span></span><br><span class="line">      <span class="keyword">if</span>(claims.getExpiration().getTime() &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().getTime()) &#123;</span><br><span class="line">        <span class="comment">//  token过期，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  没有过期</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> Integer.valueOf(claims.getSubject());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.findUserById(id);</span><br><span class="line">        <span class="comment">//  权限不足</span></span><br><span class="line">        <span class="keyword">if</span>(!hasAuthority(user, requestPath)) &#123;</span><br><span class="line">          <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">          <span class="comment">//  403权限不足</span></span><br><span class="line">          response.setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">          <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  传递给下一个过滤器</span></span><br><span class="line">    <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">tokenShouldCheck</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !path.equals(<span class="string">&quot;/users/login&quot;</span>) &amp;&amp; !path.equals(<span class="string">&quot;/users/register&quot;</span>) &amp;&amp; !path.equals(<span class="string">&quot;/users/sendVerifyCode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否有权限访问当前url下的资源</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> user 用户</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> requestPath 请求路径</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否有权限</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">hasAuthority</span><span class="params">(User user, String requestPath)</span> &#123;</span><br><span class="line">    <span class="comment">//  判断管理员权限</span></span><br><span class="line">    <span class="keyword">if</span>(requestPath.equals(<span class="string">&quot;/users&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> user.getIdentity() == Identity.Admin.ordinal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  已/users/为开头</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (requestPath.startsWith(<span class="string">&quot;/users/&quot;</span>)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">paramId</span> <span class="operator">=</span> requestPath.split(<span class="string">&quot;/&quot;</span>)[<span class="number">2</span>];</span><br><span class="line">      <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> String.valueOf(user.getId());</span><br><span class="line">      <span class="comment">//  id正确</span></span><br><span class="line">      <span class="keyword">if</span>(paramId.equals(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  id错误，判断是否有管理权限</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getIdentity() == Identity.Admin.ordinal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  其他url</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他功能以前都写烂了，没什么好说的感觉，不能很好的完成权限认证是我认为这项目开局的败笔😡</p><h1 id="酒店业务"><a href="#酒店业务" class="headerlink" title="酒店业务"></a>酒店业务</h1><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>这两天几乎遇到的所有难题都和Feign有关，可以说被Feign狠狠拷打了…</p><p><strong>错误一</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">feign.codec.DecodeException: Error <span class="keyword">while</span> extracting response <span class="keyword">for</span> <span class="built_in">type</span> [java.util.ArrayList&lt;com.magus.api.entity.Room&gt;] and content <span class="built_in">type</span> [application/json];</span><br></pre></td></tr></table></figure><p>这两天见到的最多的就是这句话，然而造成这个错误的原因是多种多样的。</p><p>我第一次遭遇这个错误是返回值不匹配造成的，起因是我在网上看到了和我同样的操作，在Controller中返回自定义的Json类，他说他在修改为Java自封装类型List之后就解决了（其实自定义类完全是可以的，但是需要创建无参构造函数）。因此我进行了尝试，以至于后面改的太乱了，有的地方是JsonResult，有的地方是User，不匹配造成了这个错误。</p><p>然后还有一个原因则是我的Feign中缺少一个配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.magus.base.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.http.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * feign的http客户端配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *No qualifying bean of type ‘org.springframework.boot.autoconfigure.http.HttpMessage</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> HttpMessageConverters <span class="title function_">messageConverters</span><span class="params">(ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpMessageConverters</span>(converters.orderedStream().collect(Collectors.toList()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HttpMessageConverters在一些版本中无法被装配，因此我们添加一个Feign的配置类对他进行@Bean装配</p><p><strong>错误二</strong></p><p>这个错误又难找又逆天，网上也搜罗不到相关的信息，我只能一点点的推测来判断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;roomProvider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RoomClient</span> &#123;</span><br><span class="line">  <span class="comment">//  根据id获取room</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/rooms/&#123;id&#125;&quot;)</span></span><br><span class="line">  Room <span class="title function_">findRoomById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  获取所有room</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/rooms&quot;)</span></span><br><span class="line">  ArrayList&lt;Room&gt; <span class="title function_">findAllRooms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  根据酒店id获取room</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/rooms/roomsOfHotel&quot;)</span></span><br><span class="line">  ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(<span class="meta">@RequestParam(&quot;hotelId&quot;)</span> Integer hotelId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果FeignClient中定义的接口需要带参数的话，而且参数本身不是在url上，那么一定要添加注解@RequestParam，不然是无法识别到对应的controller接口的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;roomsOfHotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(Integer hotelId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> roomService.findRoomByHotel(hotelId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我的controller接口名称，返回值，参数名，一切都是吻合的，但是依然要加@RequestParam注解，不然收获一小时调试hhh</p><h2 id="查询酒店详细信息"><a href="#查询酒店详细信息" class="headerlink" title="查询酒店详细信息"></a>查询酒店详细信息</h2><p>这个函数的实现很好的使用了Feign来跨服务调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HotelDetail <span class="title function_">getDetail</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">  <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> hotelMapper.selectById(id);</span><br><span class="line">  <span class="comment">//  酒店id</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">hotelId</span> <span class="operator">=</span> hotel.getId();</span><br><span class="line">  <span class="type">HotelDetail</span> <span class="variable">detail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDetail</span>(hotel);</span><br><span class="line">  <span class="comment">//  设置房间列表</span></span><br><span class="line">  ArrayList&lt;Room&gt; rooms = roomClient.roomsOfHotel(hotelId);</span><br><span class="line">  detail.setRooms(rooms);</span><br><span class="line">  <span class="comment">//  设置设施列表</span></span><br><span class="line">  ArrayList&lt;Facility&gt; facilities = facilityClient.facilitiesOfHotel(hotelId);</span><br><span class="line">  detail.setFacilities(facilities);</span><br><span class="line">  <span class="keyword">return</span> detail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计了一个dto来展示酒店详细信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDetail</span> &#123;</span><br><span class="line">  <span class="comment">//  酒店地址</span></span><br><span class="line">  <span class="keyword">private</span> String address;</span><br><span class="line">  <span class="comment">//  品牌</span></span><br><span class="line">  <span class="keyword">private</span> String brand;</span><br><span class="line">  <span class="comment">//  商圈</span></span><br><span class="line">  <span class="keyword">private</span> String businessDistrict;</span><br><span class="line">  <span class="comment">//  酒店id</span></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="comment">//  酒店简介</span></span><br><span class="line">  <span class="keyword">private</span> String introduction;</span><br><span class="line">  <span class="comment">//  酒店名称</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">//  联系方式</span></span><br><span class="line">  <span class="keyword">private</span> String phone;</span><br><span class="line">  <span class="comment">//  星级</span></span><br><span class="line">  <span class="keyword">private</span> Integer stars;</span><br><span class="line">  <span class="comment">//  设施</span></span><br><span class="line">  ArrayList&lt;Facility&gt; facilities;</span><br><span class="line">  <span class="comment">//  房间列表</span></span><br><span class="line">  ArrayList&lt;Room&gt; rooms;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HotelDetail</span><span class="params">(Hotel hotel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stars = hotel.getStars();</span><br><span class="line">    <span class="built_in">this</span>.phone = hotel.getPhone();</span><br><span class="line">    <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">    <span class="built_in">this</span>.introduction = hotel.getIntroduction();</span><br><span class="line">    <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">    <span class="built_in">this</span>.businessDistrict = hotel.getBusinessDistrict();</span><br><span class="line">    <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">    <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="订单业务"><a href="#订单业务" class="headerlink" title="订单业务"></a>订单业务</h1><h2 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h2><p>下单功能的设计和代码编写过程中都遭遇不少困难。</p><h2 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h2><p>首先是对于库存进行加锁来避免多线程下出现库存负数的情况，在设计方面目前考虑到单服务器部署下使用jvm的synchronized来解决。</p><p>其次是异步方面的设计，要求是“将耗时的操作放到后台，而界面可以显示提示信息，并且响应等的不耐烦的用户的取消操作。”</p><p>前端设计应该需要用到异步和回调，在响应到达之前进入一个正在下单的界面，并且可以选择取消，响应到达则关闭这个界面。针对此，后端需要设计的只是取消这个功能，所以我在数据库设计方面对订单状态增加了一个下单中的状态OrderStatus.CREATING，订单在插入数据库时默认是这个状态。在用户发送取消的请求后，取消服务的实现方面，我首先会对订单的状态进行查询，因为并不确认此时的下单业务是否完成，订单状态可能处于下单中，下单失败，待支付三种状态。如果处于下单中的状态，将其修改为取消状态，是有问题的，因为代表着下单服务中的检查库存、修改订单状态还没有发生，即使将其设置为取消状态，后续也会被覆盖。</p><p>因此我认为比较合理的设计是多次询问订单状态，直至变化为下单失败或待支付，如果多次询问仍为下单中，则抛出取消失败的异常返回给前端。</p><h2 id="Feign-1"><a href="#Feign-1" class="headerlink" title="Feign"></a>Feign</h2><p>在Feign的使用上，之前学习并没有学到参数传递方面的知识点，现在已经弄清楚了。结合上一篇酒店模块中的进行一个整理</p><h3 id="路径中的参数"><a href="#路径中的参数" class="headerlink" title="路径中的参数"></a>路径中的参数</h3><p>当请求路径中代有参数，并且想要将其提取出来，需要使用@PathVariable注解，同时参数名和类型与Controller中保持一致</p><p><strong>FeignClient</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rooms/&#123;id&#125;&quot;)</span></span><br><span class="line">Room <span class="title function_">findRoomById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>;</span><br></pre></td></tr></table></figure><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Room <span class="title function_">findRoomById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> roomService.findRoomById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法中的参数"><a href="#方法中的参数" class="headerlink" title="方法中的参数"></a>方法中的参数</h3><p>当接口方法中有参数时，使用@RequestParam注解，同时参数名和类型与Controller中保持一致，Controller中不需要@RequestParam注解</p><p><strong>FeignClient</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rooms/roomsOfHotel&quot;)</span></span><br><span class="line">ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(<span class="meta">@RequestParam(&quot;hotelId&quot;)</span> Integer hotelId)</span>;</span><br></pre></td></tr></table></figure><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;roomsOfHotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(Integer hotelId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> roomService.findRoomByHotel(hotelId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法中自定义类"><a href="#方法中自定义类" class="headerlink" title="方法中自定义类"></a>方法中自定义类</h3><p>当接口方法中想要传递可序列化类时，使用@RequestBody注解，同时参数名和类型与Controller中保持一致，Controller中<strong>需要@RequestBody注解</strong>，很重要，一定要加</p><p><strong>FeignClient</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rooms/updateRoom&quot;)</span></span><br><span class="line">JsonResult <span class="title function_">updateRoom</span><span class="params">(<span class="meta">@RequestBody</span> Room room)</span>;</span><br></pre></td></tr></table></figure><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;updateRoom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">updateRoom</span><span class="params">(<span class="meta">@RequestBody</span> Room room)</span> &#123;</span><br><span class="line">  roomService.updateRoom(room);</span><br><span class="line">  <span class="type">JsonResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(OK);</span><br><span class="line">  result.setMessage(<span class="string">&quot;更新房间信息成功&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="OrderService"><a href="#OrderService" class="headerlink" title="OrderService"></a>OrderService</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">  <span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> order.getCheckInDate();</span><br><span class="line">  <span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> order.getCheckOutDate();</span><br><span class="line">  <span class="type">long</span> <span class="variable">days</span> <span class="operator">=</span> ChronoUnit.DAYS.between(start, end);</span><br><span class="line">  <span class="comment">//  对预定日期合理性做检查</span></span><br><span class="line">  <span class="keyword">if</span>(days &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderDateException</span>(<span class="string">&quot;预定日期错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  计算价格</span></span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomClient.findRoomById(order.getRoomId());</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">roomNum</span> <span class="operator">=</span> order.getRoomNum();</span><br><span class="line">  <span class="type">Double</span> <span class="variable">price</span> <span class="operator">=</span> roomNum * days * room.getPrice();</span><br><span class="line">  order.setPrice(price);</span><br><span class="line">  <span class="comment">//  将订单状态设置为下单中并插入数据库</span></span><br><span class="line">  <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  order.setCreatedAt(date);</span><br><span class="line">  order.setUpdatedAt(date);</span><br><span class="line">  order.setStatus(OrderStatus.CREATING.ordinal());</span><br><span class="line">  <span class="comment">//  操作数据库</span></span><br><span class="line">  <span class="keyword">if</span>(orderMapper.insert(order) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AddOrderException</span>(<span class="string">&quot;创建订单失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  String result;</span><br><span class="line">  <span class="comment">//  对库存进行核验，如果库存满足则可以下单</span></span><br><span class="line">  <span class="keyword">if</span>(checkStorage(room.getId(), roomNum)) &#123;</span><br><span class="line">    <span class="comment">//  下单成功</span></span><br><span class="line">    order.setStatus(OrderStatus.UNPAID.ordinal());</span><br><span class="line">    result = <span class="string">&quot;订单待支付&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//  库存不满足,订单状态设置为失败</span></span><br><span class="line">    order.setStatus(OrderStatus.FAIL.ordinal());</span><br><span class="line">    result = <span class="string">&quot;下单失败，库存不足&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  对状态进行更新</span></span><br><span class="line">  <span class="keyword">if</span>(orderMapper.update(order) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UpdateOrderException</span>(<span class="string">&quot;更新订单状态失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">  <span class="comment">//  对订单状态进行检查</span></span><br><span class="line">  <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectById(id);</span><br><span class="line">  <span class="comment">//  仍处在下单中的无法进行取消，必须等待状态变为失败或未支付</span></span><br><span class="line">  <span class="keyword">while</span>(order.getStatus() == OrderStatus.CREATING.ordinal()) &#123;</span><br><span class="line">    order = orderMapper.selectById(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  跳出循环则订单状态理论上变为失败和未支付</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  下单成功处于未支付状态，取消订单需要还原库存</span></span><br><span class="line">  <span class="keyword">if</span>(order.getStatus() != OrderStatus.FAIL.ordinal()) &#123;</span><br><span class="line">    <span class="comment">//  不是失败也不是未支付，状态错误</span></span><br><span class="line">    <span class="keyword">if</span>(order.getStatus() != OrderStatus.UNPAID.ordinal()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderStatusException</span>(<span class="string">&quot;订单状态错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  未支付房间库存还原(这里应该使用事务)</span></span><br><span class="line">    <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomClient.findRoomById(order.getRoomId());</span><br><span class="line">    room.setNum(room.getNum() + order.getRoomNum());</span><br><span class="line">    roomClient.updateRoom(room);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  下单失败无需还原房间库存，状态设置为取消下单即可</span></span><br><span class="line">  order.setStatus(OrderStatus.CANCEL.ordinal());</span><br><span class="line">  <span class="keyword">if</span>(orderMapper.update(order) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UpdateOrderException</span>(<span class="string">&quot;取消订单失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Boolean <span class="title function_">checkStorage</span><span class="params">(Integer roomId, Integer roomNum)</span> &#123;</span><br><span class="line">  <span class="comment">//  绝对的低效率</span></span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomClient.findRoomById(roomId);</span><br><span class="line">  <span class="keyword">if</span>(room.getNum() &gt;= roomNum) &#123;</span><br><span class="line">    room.setNum(room.getNum() - roomNum);</span><br><span class="line">    <span class="type">JsonResult</span> <span class="variable">result</span> <span class="operator">=</span> roomClient.updateRoom(room);</span><br><span class="line">    <span class="comment">//  库存充足</span></span><br><span class="line">    <span class="keyword">return</span> result.getCode() == <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  库存不足</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能说都能达到想要的效果，但是效率都不够高，多次的访问数据库进行查询就意味着效率的低下。另外就是cancel中询问订单状态应该设置一定的重试次数，使用while循环是有死循环的风险的（我这里图省事了hhh）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端可以说完全没做，除了flask用了一些别人写好的模板，用了一下bootstrap和jQuery，可以说是很简陋。如果有机会的话想学习一下React，之前有过Vue的入门经历，还是想对这些东西都有个初步的认识（最好都能看懂），为了在以后的前后端沟通中更加方便吧</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p><strong>Java</strong></p><p>通过这个项目自主学习和实践了一下SpringCloud的基本用法，包括Nacos，Eureka，GateWay，Feign等。也在实践中理解了一些新的概念，像是负载均衡，反向代理等。</p><p>美中不足的是没有做服务熔断降级这一块，原计划是再对Sentinel进行一下学习然后使用到这个项目中的；同时MQ和Redis也没有用到，除了使用JVM处理并发以外的其他方法也没有尝试，像用Zookeeper的锁，用乐观锁悲观锁这些都没有尝试，有机会希望都能把这些知识补上</p><p><strong>Python</strong></p><p>通过这个项目也是把python开发实践了一下，之前只做过简单的爬虫，或者是小模型的训练，没有做过Web应用这方面的。Flask框架确实很方便，配合jinja2可以很快速的搭建一些简易的平台，在前端中直接使用Python语句确实很爽。但是现在主流还是前后端分离吧，专业的人干专业的事，前端还是掌握的太少了。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> Python </category>
          
          <category> Java </category>
          
          <category> 酒店管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask的基本概念与使用方法</title>
      <link href="/2023/09/13/038442bbfe74/"/>
      <url>/2023/09/13/038442bbfe74/</url>
      
        <content type="html"><![CDATA[<p>本文记录了一些关于Flask的基本概念与使用方法。Flask是一个轻量级的web框架，支持前后端整合，并且可在前端中直接使用相关的python语句。支持ORM（Object Relational Mapping），很好的结合mvc模式进行开发。</p><h1 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Flask依赖</span></span><br><span class="line">pip install Flask</span><br><span class="line"><span class="comment"># 与数据库交互</span></span><br><span class="line">pip install flask<span class="literal">-sqlalchemy</span></span><br><span class="line"><span class="comment"># 将已有数据库导入</span></span><br><span class="line">pip install sqlacodegen</span><br><span class="line"><span class="comment"># 注册发送邮件</span></span><br><span class="line">pip install flask<span class="literal">-mail</span></span><br><span class="line"><span class="comment"># 前端表单验证</span></span><br><span class="line">pip install wtforms</span><br></pre></td></tr></table></figure><h1 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h1><p>Jinja2是一个Python模板引擎，它提供一种将数据和模板结合在一起，以生成动态文本的方法。它能够生成具有清晰而简洁的结构、更易读取的网页代码</p><p>它的常用使用方法有：python变量、语句直接在模板中使用或执行</p><p>使用{ { } }来包含一个变量，在render_template中通过额外的参数传递变量至定位的模板中，在该模板中可以使用{ { var } }来使用传递的变量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> render_template(<span class="string">&quot;admin.html&quot;</span>, hotels=hotels, facilities=facilities)</span><br></pre></td></tr></table></figure><p>在admin.html中，可以使用来使用hotels变量</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-10&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;question-ul&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; left: 70px; top: 30px&quot;</span>&gt;</span></span><br><span class="line">                &#123;% for hotel in hotels %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hotel-main&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;question-title&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">                                &#123;&#123;hotel.name&#125;&#125;</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用{ % % }来使用python语句，例如上方的代码中想要使用python中的for循环，直接使用{ % for hotel in hotels % }即可</p><p>需要注意的是，jinja2中对于语句的使用，都需要有闭合。例如{ % if % }则需要在代码块结束之后以{ % endif % }结尾；{ % for % }则需要以{ % endfor% }结尾</p><p>更多的使用方法尚未学习🕊🕊🕊</p><h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><p>配置方面，和SpringBoot很相似，支持用一个config.py文件来进行数据库、发送邮件的smtp服务器以及密钥等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SECRET_KEY = <span class="string">&quot;Geo0426_xxxUniversity_xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机</span></span><br><span class="line">HOSTNAME = <span class="string">&quot;localhost&quot;</span></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line">PORT = <span class="number">3307</span></span><br><span class="line"><span class="comment"># 用户名</span></span><br><span class="line">USERNAME = <span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line">PASSWORD = <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment"># 数据库名称</span></span><br><span class="line">DATABASE = <span class="string">&quot;hms&quot;</span></span><br><span class="line"><span class="comment">#  uri</span></span><br><span class="line">DB_URI = <span class="string">f&quot;mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOSTNAME&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DATABASE&#125;</span>?charset=utf8mb4&quot;</span></span><br><span class="line"></span><br><span class="line">SQLALCHEMY_DATABASE_URI = DB_URI</span><br><span class="line"></span><br><span class="line"><span class="comment">#  邮箱服务</span></span><br><span class="line">MAIL_SERVER = <span class="string">&quot;smtp.163.com&quot;</span></span><br><span class="line">MAIL_USE_SSL = <span class="literal">True</span></span><br><span class="line">MAIL_PORT = <span class="number">465</span></span><br><span class="line">MAIL_USERNAME = <span class="string">&quot;xxx@163.com&quot;</span></span><br><span class="line">MAIL_PASSWORD = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">MAIL_DEFAULT_SENDER = <span class="string">&quot;xxx@163.com&quot;</span></span><br></pre></td></tr></table></figure><h1 id="app"><a href="#app" class="headerlink" title="app"></a>app</h1><p>Flask的核心（有点类似Vue的感觉），相当于一个主类，将相关的数据库、控制器（这里应该是blueprints）、配置进行管理，此外“钩子”函数（请求拦截器，上下文处理器）也定义在其中</p><h2 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h2><p>在每一个请求执行之前，都会先执行的函数。这里在请求发起之前先将浏览器中session的token取出来，如果存在token信息则表示完成了登录，可以给全局变量g.user设置信息；否则将其设置为空表示没有登录</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_before_request</span>():</span><br><span class="line">    user_id = session.get(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> user_id:</span><br><span class="line">        user = User.query.get(user_id)</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h2 id="上下文处理器"><a href="#上下文处理器" class="headerlink" title="上下文处理器"></a>上下文处理器</h2><p>用来处理一些所有页面都需要进行渲染的变量，比如登录信息，使用它就可以很好配合jinja2</p><p>例如我们将用户登录后的信息用一个user变量存储</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.context_processor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_context_processor</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user&quot;</span>: g.user&#125;</span><br></pre></td></tr></table></figure><p>它返回的是一个字典，接下里所有template中都可以使用这个键值来获取这个对象g.user</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if user %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span>&gt;</span>&#123;&#123; user.username &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;auth.logout&#x27;) &#125;&#125;&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br></pre></td></tr></table></figure><p>完整的代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, g</span><br><span class="line"><span class="keyword">from</span> ext <span class="keyword">import</span> db, mail</span><br><span class="line"><span class="keyword">from</span> blueprints.auth <span class="keyword">import</span> bp <span class="keyword">as</span> auth_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.users <span class="keyword">import</span> bp <span class="keyword">as</span> user_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.hotels <span class="keyword">import</span> bp <span class="keyword">as</span> hotel_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.rooms <span class="keyword">import</span> bp <span class="keyword">as</span> room_bp</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment">#  配置</span></span><br><span class="line">app.config.from_object(config)</span><br><span class="line"><span class="comment">#  解决循环引用的问题</span></span><br><span class="line">db.init_app(app)</span><br><span class="line"><span class="comment">#  注册蓝图</span></span><br><span class="line">app.register_blueprint(auth_bp)</span><br><span class="line">app.register_blueprint(user_bp)</span><br><span class="line">app.register_blueprint(hotel_bp)</span><br><span class="line">app.register_blueprint(room_bp)</span><br><span class="line">mail.init_app(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_before_request</span>():</span><br><span class="line">    user_id = session.get(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> user_id:</span><br><span class="line">        user = User.query.get(user_id)</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  上下文处理器，用来处理一些所有界面都需要用到的变量（可以用来对登录状态做一个保存）</span></span><br><span class="line"><span class="meta">@app.context_processor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_context_processor</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user&quot;</span>: g.user&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="models"><a href="#models" class="headerlink" title="models"></a>models</h1><p>models是Flask中ORM的核心部分，通过类定义的方式，与数据库中的表进行映射</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Facility</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;t_facility&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">255</span>, <span class="string">&#x27;utf8mb4_general_ci&#x27;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    created_at = Column(DateTime, nullable=<span class="literal">False</span>)</span><br><span class="line">    updated_at = Column(DateTime, nullable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>tablename设置为数据库中对映的表格名称，接着通过flask_sqlalchemy中的SQLAlchemy可以将models.py中定义完成的类，以表的形式在数据库中生成。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"><span class="comment"># 在完成了db.init_app(app)将app与db绑定后，执行create_all()生成数据库表</span></span><br><span class="line">db.create_all()</span><br></pre></td></tr></table></figure><p>如果想要对数据库中的表进行改动（增删字段等操作），也可以通过修改models.py中的模型，然后同步更新到数据库。</p><p>需要用到flask-migrate</p><p>安装依赖</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install flask<span class="literal">-migrate</span></span><br></pre></td></tr></table></figure><p>在app.py中引入Migrate</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">migrate = Migrate(app, db)</span><br></pre></td></tr></table></figure><p>大致可以分为三步：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  first step</span></span><br><span class="line">flask db init</span><br><span class="line"><span class="comment">#  second step</span></span><br><span class="line">flask db migrate</span><br><span class="line"><span class="comment">#  third step</span></span><br><span class="line">flask db upgrade</span><br></pre></td></tr></table></figure><p>在执行完第一步完成初始化之后，后续更新数据库的表只需要执行后两步即可，即flask db migrate和flask db upgrade</p><p>在Flask中不需要编写sql语句，可以通过db.session只通过对类进行操作来实现数据库的增删改查</p><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>大致步骤为创建一个实体类的对象对应数据库中表的一行数据；使用db.session添加并提交</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  创建Room对象</span></span><br><span class="line">room = Room(hotel_id=hotel_id, original_price=original_price, price=price, num=num, <span class="built_in">type</span>=room_type, created_at=now, updated_at=now)</span><br><span class="line"><span class="comment">#  将其在会话中插入</span></span><br><span class="line">db.session.add(room)</span><br><span class="line"><span class="comment">#  提交</span></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>查询一条数据，可以使用class.query.get()</p><p>根据条件查询数据集合，则需要用到filter进行过滤，可以得到一个集合</p><p>.all()可以获取全部的数据; .first()能够获得第一条数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  根据主键查询一行数据，并映射到实体类对象</span></span><br><span class="line">room = Room.query.get(room_id)</span><br><span class="line"><span class="comment">#  按照一定的条件查询（使用过滤器）</span></span><br><span class="line">hotel_facilities = HotelFacility.query.filter_by(hotel_id=hotel.<span class="built_in">id</span>).<span class="built_in">all</span>()</span><br><span class="line"><span class="comment">#  获取集合中第一个满足该条件的数据行</span></span><br><span class="line">user = User.query.filter_by(email=email).first()</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>先在数据库中查询到对应的数据映射到一个对象中；修改对象的属性；使用db.session完成commit</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">room = Room.query.get(room_id)</span><br><span class="line">room.original_price = <span class="built_in">float</span>(form.original_price.data)</span><br><span class="line">room.price = <span class="built_in">float</span>(form.price.data)</span><br><span class="line">room.num = <span class="built_in">int</span>(form.num.data)</span><br><span class="line">room.room_type = form.room_type.data</span><br><span class="line">now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">room.updated_at = now</span><br><span class="line"><span class="comment"># 数据库更新</span></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>删除需要先查询到该条记录，然后使用会话进行删除</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除设施记录  </span></span><br><span class="line">facility = Facility.query.get(<span class="number">1</span>)  </span><br><span class="line">db.session.delete(facility)  </span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h1 id="blueprints"><a href="#blueprints" class="headerlink" title="blueprints"></a>blueprints</h1><p>blueprints（蓝图）能够降低app.py中代码的复杂度，同时可以将功能模块进行拆解，便于维护，类似spring中的controller</p><p>只需要在app.py中注册该蓝图，然后在蓝图中编写请求url对应的前缀，路由以及请求方法等即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint, request, g, redirect, render_template, url_for</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Hotel</span><br><span class="line"><span class="keyword">from</span> ext <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> .form <span class="keyword">import</span> HotelForm</span><br><span class="line"></span><br><span class="line">bp = Blueprint(<span class="string">&quot;hotels&quot;</span>, __name__, url_prefix=<span class="string">&quot;/hotels&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加酒店</span></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&quot;/addHotel&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_hotel</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;add_hotel.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        form = HotelForm(request.form)</span><br><span class="line">        <span class="keyword">if</span> form.validate():</span><br><span class="line">            name = form.name.data</span><br><span class="line">            address = form.address.data</span><br><span class="line">            introduction = form.introduction.data</span><br><span class="line">            phone = form.phone.data</span><br><span class="line">            stars = form.stars.data</span><br><span class="line">            brand = form.brand.data</span><br><span class="line">            business_district = form.business_district.data</span><br><span class="line">            now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">            hotel = Hotel(name=name, address=address, introduction=introduction, phone=phone, stars=stars, brand=brand, business_district=business_district, created_at=now, updated_at=now)</span><br><span class="line">            db.session.add(hotel)</span><br><span class="line">            db.session.commit()</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;auth.index&#x27;</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(form.errors)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;添加酒店失败，检查填写信息是否正确&quot;</span></span><br></pre></td></tr></table></figure><hr><p>2024.3.13更新</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>Flask通过app.run(threaded&#x3D;True)开启的多线程处理，并不是指同一路由开启多个线程处理，而是不同路由使用多个线程处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(threaded=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>简单来说，threaded为True ，同时访问 &#x2F;t1 和 &#x2F;t2 路由 ，5秒后&#x2F;t1 和 &#x2F;t2 一起返回结果<br>threaded为False ，同时访问 &#x2F;t1 和 &#x2F;t2 路由 ，5秒后&#x2F;t1返回结果，10秒后&#x2F;t2返回结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/t1&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">t1</span>():</span><br><span class="line">   sleep(<span class="number">5</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;Hello World t1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/t2&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">t2</span>():</span><br><span class="line">   sleep(<span class="number">5</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;Hello World t2&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>希望有机会还能用到Flask😂😂😂</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud GateWay的基本概念与应用</title>
      <link href="/2023/09/02/0a3d673be179/"/>
      <url>/2023/09/02/0a3d673be179/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud GateWay的基本概念与应用。</p><h1 id="网关功能"><a href="#网关功能" class="headerlink" title="网关功能"></a>网关功能</h1><ol><li>身份认证，权限认证</li><li>服务路由，负载均衡</li><li>请求限流</li></ol><h1 id="搭建网关"><a href="#搭建网关" class="headerlink" title="搭建网关"></a>搭建网关</h1><ol><li>添加依赖，nacos服务发现以及网关的依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--网关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写路由配置以及nacos的地址</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由的id，自定义，唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址，lb是负载均衡的意思，后面跟着服务的名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路由断言，请求匹配规则，只要以user开头的就匹配</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着向网关所在端口发送请求信息，如<a href="http://localhost:10010/user/1%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0userService%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E3%80%82">http://localhost:10010/user/1，就可以得到userService服务的返回。</a></p><p>服务流程：</p><p><img src="https://s2.loli.net/2023/09/02/oTYa7EjHKGSqIVC.png" alt="image-20230902161302541"></p><h1 id="路由断言工厂"><a href="#路由断言工厂" class="headerlink" title="路由断言工厂"></a>路由断言工厂</h1><p>Spring提供了多种断言工厂，除了Path用来限制路径以外，还可以限制ip，限制时间等</p><p><img src="https://s2.loli.net/2023/09/02/z782hbNTxtBpIZS.png" alt="image-20230902162312852"></p><p>详情实例见SpringCloudGateway文档<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">路由断言工厂</a></p><h1 id="路由过滤器"><a href="#路由过滤器" class="headerlink" title="路由过滤器"></a>路由过滤器</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>对请求或者响应做加工处理，比如添加请求头</p><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>客户端向网关发起请求，请求经过多层过滤器到达服务端，服务端的响应也会经过过滤器再返回给客户端</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假如想要给请求头添加一个token</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由的id，自定义，唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 路由的目标地址，lb是负载均衡的意思，后面跟着服务的名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路由断言，请求匹配规则，只要以user开头的就匹配</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=token,</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=token,</span> <span class="string">xxx</span> <span class="comment"># 默认过滤器，会对所有请求都生效的过滤器</span></span><br></pre></td></tr></table></figure><p>SpringCloud官网提供了31种过滤器，详细可以参考<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">过滤器工厂</a></p><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>定义一个类并且实现GlobalFilter接口，并且重写函数filter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取参数</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span><br><span class="line">    <span class="comment">//  获取具体参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">    <span class="comment">//  判断身份信息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(authorization)) &#123;</span><br><span class="line">      <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">    <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">    <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">    response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response.setComplete();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Order(-1)注解是过滤器的执行顺序（或者说优先级），值越小优先级越高</p><p>@Component注解将过滤器注册为一个Bean</p><p><strong>总结步骤：</strong></p><ol><li>实现GlobalFilter接口</li><li>添加@Order和@Component注解至类</li><li>编写过滤处理逻辑</li></ol><h2 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h2><p>每个过滤器都有一个order值，根据order值进行排序</p><p>GlobalFilter是由我们自定义order的值的</p><p>路由过滤器与默认过滤器的order值由spring决定，spring默认按照声明顺序从1开始递增</p><p>当order值一样时，会按照默认过滤器&gt;路由过滤器&gt;全局过滤器的顺序执行</p><h1 id="跨域处理"><a href="#跨域处理" class="headerlink" title="跨域处理"></a>跨域处理</h1><p>只需要通过spring的配置就可以对网关的跨域进行处理</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">globalcors:</span></span><br><span class="line">    <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line"><span class="attr">corsConfigurations:</span></span><br><span class="line">  <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">    <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求，spring boot2.4以前的配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;http://localhost&quot;</span></span><br><span class="line"><span class="comment"># allowedOriginPatterns: &quot;*&quot; # spring boot2.4以后的配置  </span></span><br><span class="line"><span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#  是否允许带cookie</span></span><br><span class="line"><span class="attr">allowedMethods:</span> <span class="comment"># 跨域方法设置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">OPTIONS</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许携带的请求头信息</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">36000</span> <span class="comment"># 跨域检测的有效期,单位s</span></span><br></pre></td></tr></table></figure><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>接SpringCloud-Feign的题外话，果然有时候无法理解某个知识的时候，不妨继续学下去看看，后继拉动前驱了属于是</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> GateWay </tag>
            
            <tag> 权限认证 </tag>
            
            <tag> 服务路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Feign的基本概念与应用</title>
      <link href="/2023/09/02/0fa7d6cefe83/"/>
      <url>/2023/09/02/0fa7d6cefe83/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud Feign的基本概念与应用。</p><h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p>由于微服务架构，无法直接请求其他服务的service，需要远程调用，因此会用到RestTemplate来做远程调用。同时我们使用Ribbon结合RestTemplate来实现使用服务名称代替ip和端口以及负载均衡。Feign则是一种更加优雅的方式，不会需要像RestTemplate一样出现url</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>首先添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后主启动类上加上@EnableFeignClients注解，就像@EnableEurekaServer注解一样</p><p>在Service接口上添加@FeignClient注解，并且指定服务的名称（注册到服务注册中心的名称），因此这里就可以实现跨服务调用，只需要实现注册其他服务的名称的接口。使用起来的整体感觉像controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Feign配置"><a href="#Feign配置" class="headerlink" title="Feign配置"></a>Feign配置</h1><p><strong>方式一：</strong>通过修改yml文件对feign进行配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  OrderService</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span></span><br></pre></td></tr></table></figure><p><strong>方式二：</strong>通过配置类和注解</p><p>创建一个configuration类，配置Logger.Level这个Bean，加在指定服务的@FeignClient(value &#x3D; “userservice”)注解中，或者加在启动类的@EnableFeignClients( defaultConfiguration &#x3D; xxxconfiguration.class )注解中。</p><h1 id="Feign性能优化"><a href="#Feign性能优化" class="headerlink" title="Feign性能优化"></a>Feign性能优化</h1><p>Feign底层默认使用的URLConnection，不支持连接池，可以通过使用Apache HttpClient来支持连接池（减少连接的创建与释放）</p><h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><p>添加HttpClient依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置连接池</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 支持HttpClient的开关</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 单个路径的最大连接数</span></span><br></pre></td></tr></table></figure><h1 id="Feign-Api"><a href="#Feign-Api" class="headerlink" title="Feign-Api"></a>Feign-Api</h1><p>controller和FeignClient的重合度较高，可以通过采用定义接口，让二者都去继承这个接口，利用这种方式提供便捷。</p><p>存在的问题：紧耦合</p><p>我更偏向的方法是将FeignClient、POJO、Feign的默认配置封装到一个模块中，通过引入模块来供其他消费者使用。这样做也可以避免每个服务都要去实现一样的FeignClient，创建实体类等。</p><p>存在的问题：有的服务可能仅仅需要部分实体类和功能，有所冗余</p><h2 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h2><p>在其他服务的pom文件中引入该feign-api的依赖，这样就可以引入本模块中未创建的实体类，实现复用</p><p>在使用过程中会出现一个问题：对FeignClient的自动装配，@Autowired只能装配项目所在包目录下的Bean，因此需要在@EnableFeignClients注解上添加clients参数。</p><p>@EnableFeignClients( clients &#x3D; {UserClient.class, OrderClent.class}, defaultConfiguration &#x3D; xxxconfiguration.class ) clients参数可以是数组</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>流程梳理：</p><ol><li>服务模块不需要实现FeignClient来实现跨服务，不需要创建其他的实体</li><li>通过创建feign-api来对服务进行封装，为其他服务的跨服务调用提供接口，同时减少了实体类重复写的情况</li></ol><p>开发流程：</p><p>provider的服务相关内容按照springboot一样照常写，然后在provider-api中提供对服务controller的访问，其他服务需要跨服务调用时通过provider-api来从其它服务的controller中获取</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>昨晚一直在思考前端到底是如何调用有多个实例的后端服务，为此去了解了一下nginx的负载均衡和反向代理。</p><p>我的纠结点在于，我目前学到的springcloud内部的负载均衡都是服务之间的调用，可以通过其他服务的名称向注册中心进行请求，然后再根据返回的服务实例列表负载均衡。那如果这个服务本身我从前端向他发起请求，又应该怎么做才能不访问固定的端口号呢？</p><p>最初想到的方法是将对这台主机的http请求，全部向nacos寻找服务名称的这种方式，当然只是我的猜想。今天查资料，貌似是通过向网关发出请求，再由网关进行路由到具体服务。就我个人而言，从设计的角度感觉非常合理，前端的请求可以通过nginx的负载均衡向不同网关实例发送，网关又可以根据url的路径向具体的服务请求，服务则又被注册到了nacos，若存在多个实例也会在openfeign中实现负载均衡。</p><p>莫名其妙就串联起来了，学完网关再看看</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Feign </tag>
            
            <tag> RestTemplate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Nacos的基本概念与应用</title>
      <link href="/2023/09/01/0c0d4551479b/"/>
      <url>/2023/09/01/0c0d4551479b/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud Nacos的基本概念与应用。</p><h1 id="Nacos服务注册"><a href="#Nacos服务注册" class="headerlink" title="Nacos服务注册"></a>Nacos服务注册</h1><p>首先父模块的依赖控制处需要添加spring cloud alibaba</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringCloudAlibaba有关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着在服务模块的pom中添加spring-cloud-starter-alibaba-nacos-discovery依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更改配置，nacos是在springcloud配置中的</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><p>注：EnableDiscoveryClient注解现在是可选项了，只要依赖了以spring-cloud-starter-netflix为前缀的库(例如spring-cloud-starter-netflix-eureka-client)，就启用了<strong>服务注册发现</strong>功能；</p><h1 id="服务分层架构"><a href="#服务分层架构" class="headerlink" title="服务分层架构"></a>服务分层架构</h1><p>Nacos的服务按照服务-&gt;集群-&gt;实例来分层，优先调用本地集群内的实例，本地集群中实例不可用再调用其他集群的实例</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span> </span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HangZhou</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><p>如果想要配置优先调用本地集群内的实例，需要修改nacos的配置，例如订单服务想要优先调用本地用户服务的实例，需要使用nacos的负载均衡策略</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 规则类的名称</span></span><br></pre></td></tr></table></figure><p>NacosRule优先选择本地集群，集群内部随机选择；当本地集群健康服务数为0时，选择跨集群访问并警告</p><h1 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h1><p>控制台可以修改实例的权重，权重越高，用户请求更多的向该实例迁移。在服务升级中，可以通过将权重比例调为0然后进行升级，之后再调成小权重进行一段时间测试，稳定后恢复权重</p><h1 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h1><p>环境隔离，对相似的服务可以进行分组，如果不同组的服务也无法相互访问。每个namespace有唯一的id，需要在配置文件中修改它的值来设置环境</p><h1 id="Nacos和Eureka的区别"><a href="#Nacos和Eureka的区别" class="headerlink" title="Nacos和Eureka的区别"></a>Nacos和Eureka的区别</h1><h2 id="健康监测"><a href="#健康监测" class="headerlink" title="健康监测"></a>健康监测</h2><p>对于服务提供者的健康状态监测，nacos将服务实例分为临时实例和非临时实例</p><p>临时实例：</p><p>和Eureka一样，使用心跳检测，如果不在服务就会主动剔除（默认情况下如果不配置，实例都是临时的）</p><p>非临时实例：</p><p>非临时实例则会由nacos主动发起询问服务实例的健康状态，并且不会将不健康的服务实例清楚，会等待恢复</p><p>创建非临时实例只需要修改discovery的值</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span> </span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HangZhou</span> <span class="comment"># 集群名称</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 是否为临时实例</span></span><br></pre></td></tr></table></figure><h2 id="服务列表"><a href="#服务列表" class="headerlink" title="服务列表"></a>服务列表</h2><p>Eureka和Nacos都会定时拉取服务列表加到缓存中，提高效率。但是Nacos还采取了消息推送的形式，当服务发生变更，会主动推送消息给消费者</p><h1 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h1><h2 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h2><p>命名规则是 服务名-运行环境.yaml如userservice-dev.yaml</p><p>配置内容只设置有热更新需求的配置项，例如日期格式等；像数据库地址这种可以不放上去</p><h2 id="配置拉取"><a href="#配置拉取" class="headerlink" title="配置拉取"></a>配置拉取</h2><p>配置读取步骤：</p><p><img src="https://s2.loli.net/2023/09/01/iCF7szOZ6HVGjlS.png" alt="image-20230901202139446.png"></p><p>bootstap.yml配置的优先级较高，可以读取到nacos的地址，再读取nacos的配置文件，最后读取application.yml的配置文件</p><p>首先在<strong>微服务</strong>引入nacos-config依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos config依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着创建bootstrap.yml文件，引导配置文件，优先级高于application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 开发环境</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>三者结合发现就是在控制台创建的配置id即userservice-dev.yaml</p><p>同时，之前的application.yml中的重复配置可以删除了，如服务名称和nacos地址</p><p>注：nacos配置管理是按服务分的，因此写在<strong>微服务</strong>模块中</p><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>前置知识：</p><p>使用@Value(“${pattern.dateformat}”)注解可以获取配置项（改成NacosValue）</p><p>@ConfigurationProperties(prefix &#x3D; “xxx”) 约定大于配置，只要prefix前缀xxx与变量名进行拼接与配置一致，就可以注入</p><p>方法一：在Value注解所在类上加一个注解@RefreshScope，可以实现配置热更新，无需重启服务</p><p>方法二：使用@ConfigurationProperties(prefix &#x3D; “xxx”)注解</p><h1 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h1><p>浪费了近一个小时时间在处理依赖和配置的问题上。这里属于是对dependencymanagement不熟悉了。</p><p>使用dependencyManagement可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。</p><p>误解：以为在父模块中定义dependencyManagement之后，子模块就可以继承下来，但是在maven中发现子模块中并没有继承下来依赖。实际上是子模块中依然需要添加相关依赖但是不用加版本号。</p><p>解决方法：想要实现我的需求只需要将父模块的依赖标签dependencyManagement删除，仅使用dependencies即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mysql --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--web起步依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Ribbon的基本概念与应用</title>
      <link href="/2023/08/30/4064d644d905/"/>
      <url>/2023/08/30/4064d644d905/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud Ribbon的基本概念与应用。</p><h1 id="Ribbon负载均衡流程"><a href="#Ribbon负载均衡流程" class="headerlink" title="Ribbon负载均衡流程"></a>Ribbon负载均衡流程</h1><p>像这样的url：<a href="http://userservice/user/1">http://userservice/user/1</a> 是没有办法通过http访问的，因为实际上不存在这么一个网站，因此Ribbon起到一个请求拦截处理的作用</p><ol><li><p>收到请求后，向Eureka拉取服务</p></li><li><p>返回服务列表，进行负载均衡，轮询获取具体服务端口</p></li></ol><p>具体操作需要在xxx-service模块中的xxxServiceApplication中将RestTemplate注入spring容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ribbon底层"><a href="#Ribbon底层" class="headerlink" title="Ribbon底层"></a>Ribbon底层</h1><ol><li>LoadBalancerInterceptor拦截http请求，将请求解析得到服务名称</li><li>将服务名称交给RibbonLoadBalancerClient</li><li>RibbonLoadBalancerClient通过DynamicServerListLoadBalancer向eureka拉取服务列表</li><li>DynamicServerListLoadBalancer通过负载均衡策略IRule从服务列表中进行选择，提交给RibbonLoadBalancerClient</li><li>RibbonLoadBalancerClient对url进行修改，发起请求</li></ol><h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><p><img src="https://s2.loli.net/2023/08/30/Vc82tw4vB5gkmPi.png" alt="image-20230830184232870.png"></p><h2 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h2><ol><li>通过在相关服务中将IRule注入spring容器实现对负载均衡策略的修改，例如xxx-service模块中的xxxServiceApplication中（本身也算是配置类）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件的方式，在xxx-service模块中的yml配置中添加</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.magus.config.RandomRule</span> <span class="comment"># 规则类的名称</span></span><br></pre></td></tr></table></figure><h1 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h1><p>Ribbon默认是懒加载，第一次访问才会创建LoadBalancerClient，请求时间较长。使用饥饿加载可以在服务启动时就创建，减少请求时间</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment"># 单个服务</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="comment"># 多个服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">userservice</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orderservice</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Eureka的基本概念与应用</title>
      <link href="/2023/08/30/813ced141348/"/>
      <url>/2023/08/30/813ced141348/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud Eureka的基本概念与应用。</p><h1 id="Eureka角色"><a href="#Eureka角色" class="headerlink" title="Eureka角色"></a>Eureka角色</h1><p>服务端：EurekaServer，服务端，注册中心。负责心跳监控，记录服务信息</p><p>客户端：EurekaClient，分为消费者和提供者。</p><h1 id="Eureka的作用"><a href="#Eureka的作用" class="headerlink" title="Eureka的作用"></a>Eureka的作用</h1><p>eureka服务类似注册中心：</p><ol><li>服务消费者和提供者将服务信息注册到注册中心</li><li>消费者向注册中心拉取提供者的新消息</li><li>通过负载均衡进行选择</li><li>实现远程调用</li></ol><p>注册中心使用心跳续约，随时监控服务状态</p><h1 id="Eureka搭建"><a href="#Eureka搭建" class="headerlink" title="Eureka搭建"></a>Eureka搭建</h1><p>搭建服务步骤如下：</p><ol><li>创建模块，引入spring-cloud-starter-netflix-eureka-server依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka服务端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果父工程中已经选好了springcloud的版本以及相关依赖，这里不需要填写版本号</p><ol start="2"><li>编写启动类，并添加@EnableEurekaServer注解</li><li>编写yml配置文件，服务端口、服务名称、地址信息（用于eureka集群通信）</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tomcat</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9099</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 应用名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hms_eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">sevice-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:$&#123;server.port&#125;/eureka</span></span><br><span class="line">    <span class="comment"># 这里选择不将自己注册 </span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><p>在依赖中引入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时在application.yml中配置eureka相关信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9099/eureka</span></span><br></pre></td></tr></table></figure><p>注：启动类上要加上@EnableEurekaServer注解</p><p>一直遇到一个问题，日志内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023-08-30 16:57:34.306  INFO 1076 --- [           main] com.magus.UserServiceApplication         : No active profile <span class="built_in">set</span>, falling back to default profiles: default</span><br><span class="line">2023-08-30 16:57:34.580  INFO 1076 --- [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory <span class="built_in">id</span>=24ae86d6-4a71-3421-838c-868a60323ef7</span><br><span class="line">2023-08-30 16:57:34.621  INFO 1076 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">&#x27;org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration&#x27;</span> of <span class="built_in">type</span> [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$9adaa148</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2023-08-30 16:57:34.632  INFO 1076 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">&#x27;org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration&#x27;</span> of <span class="built_in">type</span> [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$b6f4a445</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2023-08-30 16:57:34.644  WARN 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span><br><span class="line">2023-08-30 16:57:34.644  INFO 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : To <span class="built_in">enable</span> URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span><br><span class="line">2023-08-30 16:57:34.649  WARN 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span><br><span class="line">2023-08-30 16:57:34.649  INFO 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : To <span class="built_in">enable</span> URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span><br><span class="line">2023-08-30 16:57:36.516  INFO 1076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine <span class="built_in">local</span> hostname</span><br><span class="line">2023-08-30 16:57:38.145  INFO 1076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine <span class="built_in">local</span> hostname</span><br><span class="line">2023-08-30 16:57:38.203  INFO 1076 --- [           main] o.s.c.n.eureka.InstanceInfoFactory       : Setting initial instance status as: STARTING</span><br><span class="line">2023-08-30 16:57:38.224  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Initializing Eureka <span class="keyword">in</span> region us-east-1</span><br><span class="line">2023-08-30 16:57:38.855  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON encoding codec LegacyJacksonJson</span><br><span class="line">2023-08-30 16:57:38.855  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON decoding codec LegacyJacksonJson</span><br><span class="line">2023-08-30 16:57:38.928  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML encoding codec XStreamXml</span><br><span class="line">2023-08-30 16:57:38.929  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML decoding codec XStreamXml</span><br><span class="line">2023-08-30 16:57:39.042  INFO 1076 --- [           main] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2023-08-30 16:57:39.460  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Disable delta property : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null</span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application is null : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : <span class="literal">true</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application version is -1: <span class="literal">true</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server</span><br><span class="line">2023-08-30 16:57:39.535  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : The response status is 200</span><br><span class="line">2023-08-30 16:57:39.536  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 30</span><br><span class="line">2023-08-30 16:57:39.538  INFO 1076 --- [           main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4</span><br><span class="line">2023-08-30 16:57:39.541  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1693385859540 with initial instances count: 0</span><br><span class="line">2023-08-30 16:57:39.542  INFO 1076 --- [           main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application USER-SERVICE with eureka with status UP</span><br><span class="line">2023-08-30 16:57:39.543  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Saw <span class="built_in">local</span> status change event StatusChangeEvent [timestamp=1693385859543, current=UP, previous=STARTING]</span><br><span class="line">2023-08-30 16:57:39.544  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999: registering service...</span><br><span class="line">2023-08-30 16:57:39.554  INFO 1076 --- [           main] com.magus.UserServiceApplication         : Started UserServiceApplication <span class="keyword">in</span> 9.058 seconds (JVM running <span class="keyword">for</span> 10.165)</span><br><span class="line">2023-08-30 16:57:39.556  INFO 1076 --- [       Thread-5] o.s.c.n.e.s.EurekaServiceRegistry        : Unregistering application USER-SERVICE with eureka with status DOWN</span><br><span class="line">2023-08-30 16:57:39.557  WARN 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Saw <span class="built_in">local</span> status change event StatusChangeEvent [timestamp=1693385859557, current=DOWN, previous=UP]</span><br><span class="line">2023-08-30 16:57:39.561  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Shutting down DiscoveryClient ...</span><br><span class="line">2023-08-30 16:57:39.602  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - registration status: 204</span><br><span class="line">2023-08-30 16:57:39.603  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999: registering service...</span><br><span class="line">2023-08-30 16:57:39.614  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - registration status: 204</span><br><span class="line">2023-08-30 16:57:39.615  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Unregistering ...</span><br><span class="line">2023-08-30 16:57:39.630  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - deregister  status: 200</span><br><span class="line">2023-08-30 16:57:39.637  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Completed shut down of DiscoveryClient</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> Eureka客户端（服务提供者&#x2F;消费者）没有成功引入web的starter（头疼了半小时）。</p><h2 id="注册多个实例"><a href="#注册多个实例" class="headerlink" title="注册多个实例"></a>注册多个实例</h2><p>可以对服务的配置进行复制然后在VM设置中添加参数-Dserver.port&#x3D;xxxx</p><h1 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h1><ol><li>同注册，引入依赖，配置eureka地址。</li><li>给ResTemplate添加@LoadBanlanced注解（负载均衡）</li><li>用服务提供者的注册服务名称代替url中的一部分进行远程调用，例如 <a href="http://userservice/user/1">http://userservice/user/1</a> (restful)</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Eureka起到为服务之间提供远程调用的作用，来实现将服务分离又能交互</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Eureka </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My First Blog</title>
      <link href="/2023/08/29/3ed187a62f30/"/>
      <url>/2023/08/29/3ed187a62f30/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h1><p>2023年8月29日正式搭建属于我的博客，希望有一天我也能写出像hexo一样能被万人使用的project</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
