<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见聚类方法与朴素贝叶斯</title>
      <link href="/2025/01/04/cc49a10a70da/"/>
      <url>/2025/01/04/cc49a10a70da/</url>
      
        <content type="html"><![CDATA[<p>本文整理了最近学习（来自NJUSE的数据仓库课程）的一些常见聚类方法，包括K-Means、凝聚层次、DBSCAN方法，以及概率统计中的朴素贝叶斯方法（贝叶斯公式的拓展）和拉普拉斯修正。</p><h1 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h1><p>K - Means算法是一种划分式聚类算法，目标是将数据集划分为 K 个不同的聚类。它的基本思想是通过不断地迭代，使得同一聚类中的数据点尽可能相似（距离较近），不同聚类中的数据点尽可能不同（距离较远）。</p><p><strong>举例说明：</strong></p><ul><li><p>假设我们有一群学生，他们的考试成绩包括语文、数学和英语三门科目，我们想根据成绩把学生分成 3 个小组（这里的 K &#x3D; 3）。</p></li><li><p>第一步：选择初始聚类中心</p><ul><li>随机挑选 3 名学生的成绩作为初始的聚类中心。比如学生 A（语文 80，数学 70，英语 75）、学生 B（语文 60，数学 80，英语 65）、学生 C（语文 90，数学 90，英语 80）。这三个点就代表了三个初始的聚类中心。</li></ul></li><li><p>第二步：分配数据点到聚类</p><ul><li><p>计算其他每个学生的成绩与这三个聚类中心的距离。距离的计算可以使用欧几里得距离公式，比如对于学生 D（语文 70，数学 75，英语 70），与学生 A 的距离是：<br>$$<br>d_{AD}&#x3D;\sqrt{(70 - 80)^2+(75 - 70)^2+(70 - 75)^2}&#x3D;\sqrt{100 + 25+ 25}&#x3D;\sqrt{150}<br>$$</p></li><li><p>同样地，计算与学生 B 和学生 C 的距离。假设经过计算，学生 D 离学生 A 的距离最近，那么就把学生 D 分配到以学生 A 为中心的聚类中。</p></li><li><p>对所有学生都进行这样的操作，这样所有学生就被分配到了三个聚类中的一个。</p></li></ul></li><li><p>第三步：更新聚类中心</p><ul><li>对于每个聚类，重新计算聚类中心。比如在以学生 A 为中心的聚类中，把所有分配到这个聚类中的学生成绩相加，然后除以这个聚类中的学生数量，得到新的聚类中心。</li><li>假设在这个聚类中有 5 个学生，他们的语文成绩总和是 380，数学成绩总和是 360，英语成绩总和是 370。那么新的聚类中心（语文成绩）就是 $380\div5&#x3D;76$，数学成绩是$ 360\div5 &#x3D; 72$，英语成绩是$370\div5 &#x3D; 74$。</li></ul></li><li><p>第四步：重复第二步和第三步，直到收敛</p><ul><li>不断重复分配数据点和更新聚类中心的步骤，直到聚类中心不再发生明显变化（收敛）。例如，经过多次迭代后，发现聚类中心的位置变化很小，比如每次更新后，语文、数学和英语成绩的变化都在一个很小的范围内（比如小于 0.1），此时就认为算法收敛，聚类完成。</li></ul></li></ul><p>在实际应用中，K - 均值算法可以用于客户细分。例如，一家电商公司可以根据客户的购买频率、购买金额和购买商品的类别等属性，将客户分成不同的群体，以便更好地制定营销策略。</p><p>#凝聚层次</p><p>凝聚式层次聚类是一种自底向上的聚类方法。它最初将每个数据点看作是一个单独的聚类，然后在每一步中，合并最相似（距离最近）的两个聚类，直到满足某个停止条件，比如达到预定的聚类数量或者所有聚类之间的距离超过某个阈值。</p><p><strong>举例说明：</strong></p><ul><li>假设我们要对一些动物进行聚类，这些动物包括猫、狗、马、牛、鸡、鸭。</li><li>初始状态<ul><li>开始时，我们把每一种动物都看作是一个单独的聚类。所以有 6 个聚类：{猫}、{狗}、{马}、{牛}、{鸡}、{鸭}。</li></ul></li><li>计算相似度（距离）并合并聚类<ul><li>我们可以通过一些特征来衡量动物之间的相似度，比如生活习性、体型等。假设我们以生活习性为主要衡量标准。</li><li>我们发现猫和狗都是宠物，它们的生活习性比较相似，比如都生活在人类的住所周围，所以我们把 {猫} 和 {狗} 合并成一个新的聚类 {猫，狗}。现在还剩下 5 个聚类：{猫，狗}、{马}、{牛}、{鸡}、{鸭}。</li></ul></li><li>继续合并<ul><li>接着我们发现马和牛都是大型家畜，它们的生活习性也比较相似，比如都在牧场生活，所以我们把 {马} 和 {牛} 合并成一个聚类 {马，牛}。现在有 4 个聚类：{猫，狗}、{马，牛}、{鸡}、{鸭}。</li></ul></li><li>进一步合并<ul><li>再看鸡和鸭，它们都是家禽，生活习性类似，都在农场的禽类养殖区域生活，于是我们把 {鸡} 和 {鸭} 合并成 {鸡，鸭}。现在剩下 3 个聚类：{猫，狗}、{马，牛}、{鸡，鸭}。</li></ul></li><li>停止条件<ul><li>如果我们设定聚类数量为 3 个就停止，那么此时聚类过程就结束了。如果没有设定这样的停止条件，聚类过程会继续，比如再考虑 {猫，狗} 和 {马，牛} 的相似度，看是否要合并它们等，直到所有聚类之间的距离超过一个我们设定的阈值。</li></ul></li></ul><p>在实际应用中，凝聚式层次算法可以用于文档聚类。例如，将许多新闻文章进行聚类，最初每篇文章是一个聚类，然后根据文章内容的相似性（如主题、关键词等）逐步合并聚类，最后得到不同主题的新闻文章聚类，帮助用户快速了解新闻的主题分布情况。</p><h1 id="DBSCAN"><a href="#DBSCAN" class="headerlink" title="DBSCAN"></a>DBSCAN</h1><p>DBSCAN（Density - Based Spatial Clustering of Applications with Noise）是一种基于密度的空间聚类算法。它将数据点分为三类：核心点、边界点和噪声点。核心点是在其邻域内包含足够多的数据点的点；边界点是在核心点的邻域内但自身邻域内数据点数量不足的点；噪声点是既不是核心点也不是边界点的点。</p><p><strong>核心概念：</strong></p><ul><li><strong>$\epsilon$-邻域</strong>：对于样本集中的样本$x_j$，其$\epsilon$-邻域包含样本集中与$x_j$的距离小于等于$\epsilon$的样本，即$N_{\epsilon}(x_j)&#x3D;{x_i\in D|d(x_i,x_j)\leq\epsilon}$，其中$D$是数据集，$d$是距离度量（如欧几里得距离）。     </li><li><strong>核心点</strong>：若样本$x_j$的$\epsilon$-邻域内至少包含$MinPts$个样本（包括$x_j$本身），则$x_j$是核心点，即$|N_{\epsilon}(x_j)|\geq MinPts$。     </li><li><strong>边界点</strong>：若样本$x_i$不是核心点，但它在某个核心点的$\epsilon$-邻域内，则$x_i$是边界点。     </li><li><strong>噪声点</strong>：既不是核心点也不是边界点的样本是噪声点。</li></ul><p><strong>举例说明：</strong></p><ul><li>假设我们有一群人分布在一个操场上，这些人就是我们的数据点。</li><li>确定$\epsilon$-邻域和密度阈值$MinPts$<ul><li>我们先定义一个距离（比如 2 米）作为邻域范围，密度阈值（比如 3 个人）。也就是说，如果一个人周围 2 米范围内有至少 3 个人，那么这个人就是一个核心点。</li></ul></li><li>寻找核心点<ul><li>比如有一群人在操场的一个角落聊天，他们彼此之间的距离都小于 2 米，人数超过 3 个。那么这个小群体中的每个人都是核心点。</li></ul></li><li>确定边界点和噪声点<ul><li>现在有一个人，他距离这个聊天群体比较近，大概在 2 米左右的位置，但是他周围（2 米范围内）没有达到 3 个人，那这个人就是边界点。因为他靠近一个密集的群体，但自己所在的小区域密度不够。</li><li>而在操场的另一个很远的地方，有一个人孤零零地站着，他周围 2 米范围内根本没有其他人，那这个人就是噪声点。</li></ul></li><li>形成聚类<ul><li>所有的核心点以及和它们邻域内的边界点就构成了一个聚类。在这个例子中，聊天的那群人以及旁边的边界点就形成了一个聚类，表示操场上的一个人群聚集区域。</li></ul></li></ul><p>在实际应用中，DBSCAN 算法常用于分析空间数据、客户细分等场景，例如分析城市中店铺的分布，找出店铺聚集的商圈（聚类）以及孤立的店铺（噪声）。</p><p><strong>计算方法：</strong></p><p>这里我们定义$MinPts$为2，相似度阈值为0.8（$\epsilon$-邻域距离计算时取距离小于阈值的点，相似度计算时取相似度大于阈值的点，本质方法一样）。表格表示点P1到P5之间的相似度。</p><table><thead><tr><th align="center"></th><th align="center">P1</th><th align="center">P2</th><th align="center">P3</th><th align="center">P4</th><th align="center">P5</th></tr></thead><tbody><tr><td align="center"><strong>P1</strong></td><td align="center">1</td><td align="center">0.1</td><td align="center">0.41</td><td align="center">0.55</td><td align="center">0.35</td></tr><tr><td align="center"><strong>P2</strong></td><td align="center">0.10</td><td align="center">1</td><td align="center">0.64</td><td align="center">0.47</td><td align="center">0.98</td></tr><tr><td align="center"><strong>P3</strong></td><td align="center">0.41</td><td align="center">0.64</td><td align="center">1</td><td align="center">0.44</td><td align="center">0.85</td></tr><tr><td align="center"><strong>P4</strong></td><td align="center">0.55</td><td align="center">0.47</td><td align="center">0.44</td><td align="center">1</td><td align="center">0.76</td></tr><tr><td align="center"><strong>P5</strong></td><td align="center">0.35</td><td align="center">0.98</td><td align="center">0.85</td><td align="center">0.76</td><td align="center">1</td></tr></tbody></table><p>根据表格，P2与P5的相似度为0.98＞0.8，P3与P5的相似度为0.85＞0.8，因此可以判定P2，P3，P5为一类，其中P5是<strong>核心点</strong>，P2和P3是<strong>边界点</strong>，P1和P4是<strong>噪点</strong>。</p><h1 id="朴素贝叶斯方法"><a href="#朴素贝叶斯方法" class="headerlink" title="朴素贝叶斯方法"></a>朴素贝叶斯方法</h1><p> <strong>朴素贝叶斯</strong>是一种基于贝叶斯定理的分类算法。<strong>贝叶斯定理</strong>公式为：<br>$$<br>P(A|B)&#x3D;\frac{P(B|A)P(A)}{P(B)}<br>$$<br>在分类问题中，假设我们要分类的类别是$C$（比如是垃圾邮件或者不是垃圾邮件），特征向量是$X &#x3D; (x_1,x_2,\cdots,x_n)$（比如邮件中的单词、短语等特征）。我们的目标是计算$P(C|X)$，即给定特征向量$X$，属于类别$C$的概率。</p><p>根据贝叶斯定理，$P(C|X)&#x3D;\frac{P(X|C)P(C)}{P(X)}$，由于$P(X)$对于所有类别来说是相同的，所以我们主要关注$P(X|C)P(C)$。</p><p>朴素贝叶斯假设特征之间相互独立，所以有<br>$$<br>P(X|C)&#x3D;P(x_1|C)P(x_2|C)\cdots P(x_n|C)<br>$$<br>即X包含的子事件X1，X2 … Xn都是独立发生的。</p><p><strong>举例说明：</strong></p><p>假设我们要判断一封邮件是否是垃圾邮件。类别$C$有两种情况：$C_1$表示是垃圾邮件，$C_2$表示不是垃圾邮件。特征向量$X$是邮件中出现的单词，假设只考虑两个单词“赚钱”和“优惠”。   </p><ul><li><p>我们先统计一些数据来计算概率。假设我们有100封邮件，其中60封是垃圾邮件（$P(C_1) &#x3D; 0.6$），40封不是垃圾邮件（$P(C_2)&#x3D;0.4$）</p></li><li><p>在60封垃圾邮件中，“赚钱”这个单词出现了30次，所以$P(x_1 &#x3D;“赚钱”|C_1)&#x3D;\frac{30}{60}&#x3D;0.5$；“优惠”这个单词在垃圾邮件中出现了20次，所以$P(x_2 &#x3D;“优惠”|C_1)&#x3D;\frac{20}{60}&#x3D;\frac{1}{3}$</p></li><li><p>在40封非垃圾邮件中，“赚钱”这个单词出现了10次，所以$P(x_1 &#x3D;“赚钱”|C_2)&#x3D;\frac{10}{40}&#x3D;0.25$；“优惠”这个单词在非垃圾邮件中出现了20次，所以$P(x_2 &#x3D;“优惠”|C_2)&#x3D;\frac{20}{40}&#x3D;0.5$。</p></li></ul><p>现在有一封新邮件，里面出现了“赚钱”和“优惠”这两个单词。我们来计算它是垃圾邮件的概率$P(C_1|X)$</p><p>$$<br>P(X|C_1)&#x3D;P(x_1 &#x3D;“赚钱”|C_1)P(x_2 &#x3D;“优惠”|C_1)&#x3D;0.5\times\frac{1}{3}&#x3D;\frac{1}{6}<br>$$</p><p>$$<br>P(X|C_2)&#x3D;P(x_1 &#x3D;“赚钱”|C_2)P(x_2 &#x3D;“优惠”|C_2)&#x3D;0.25\times0.5&#x3D;\frac{1}{8}<br>$$</p><p>$$<br>P(C_1|X)&#x3D;\frac{P(X|C_1)P(C_1)}{P(X|C_1)P(C_1)+P(X|C_2)P(C_2)}&#x3D;\frac{\frac{1}{6}\times0.6}{\frac{1}{6}\times0.6+\frac{1}{8}\times0.4}&#x3D;\frac{\frac{1}{10}}{\frac{1}{10}+\frac{1}{20}}&#x3D;\frac{\frac{1}{10}}{\frac{3}{20}}&#x3D;\frac{2}{3}<br>$$</p><p>所以这封邮件有$\frac{2}{3}$的概率是垃圾邮件。</p><h1 id="拉普拉斯修正"><a href="#拉普拉斯修正" class="headerlink" title="拉普拉斯修正"></a>拉普拉斯修正</h1><p>在朴素贝叶斯算法中，可能会出现某个特征在某个类别下概率为0的情况。比如在判断邮件是否为垃圾邮件时，如果在非垃圾邮件中从未出现过“抽奖”这个单词，那么$P(x &#x3D;“抽奖”|C_2)&#x3D;0$，这会导致整个$P(X|C_2)$为0，进而影响分类结果。拉普拉斯修正就是为了解决这个问题。   </p><p>拉普拉斯修正公式为：<br>$$<br>P(x_i|C_j)&#x3D;\frac{N_{x_i,C_j}+1}{N_{C_j}+|V|}<br>$$<br>其中$N_{x_i,C_j}$是特征$x_i$在类别$C_j$中出现的次数，$N_{C_j}$是类别$C_j$的总数，$|V|$是特征空间的大小（也就是所有可能特征的数量）。 </p><p><strong>举例说明：</strong></p><ul><li><p>假设我们还是判断邮件是否是垃圾邮件，特征向量还是考虑“赚钱”和“优惠”两个单词，现在新增一个单词“抽奖”。我们还是有100封邮件，60封垃圾邮件，40封非垃圾邮件。</p></li><li><p>在垃圾邮件中，“赚钱”出现30次，“优惠”出现20次，“抽奖”出现0次。在非垃圾邮件中，“赚钱”出现10次，“优惠”出现20次，“抽奖”出现0次。   - 假设特征空间大小$|V| &#x3D; 3$（就是“赚钱”“优惠”“抽奖”这3个单词）。</p></li><li><p>对于垃圾邮件类别，根据拉普拉斯修正：</p><p>$P(x_1 &#x3D;“赚钱”|C_1)&#x3D;\frac{30 + 1}{60+3}&#x3D;\frac{31}{63}$，$P(x_2 &#x3D;“优惠”|C_1)&#x3D;\frac{20 + 1}{60+3}&#x3D;\frac{21}{63}$，$P(x_3 &#x3D;“抽奖”|C_1)&#x3D;\frac{0 + 1}{60+3}&#x3D;\frac{1}{63}$</p></li><li><p>对于非垃圾邮件类别，根据拉普拉斯修正：</p><p>$P(x_1 &#x3D;“赚钱”|C_2)&#x3D;\frac{10 + 1}{40+3}&#x3D;\frac{11}{43}$ ，$P(x_2 &#x3D;“优惠”|C_2)&#x3D;\frac{20 + 1}{40+3}&#x3D;\frac{21}{43}$ ，$P(x_3 &#x3D;“抽奖”|C_2)&#x3D;\frac{0 + 1}{40+3}&#x3D;\frac{1}{43}$</p></li></ul><p>现在有一封新邮件，里面出现了“抽奖”这个单词，我们来计算它是垃圾邮件的概率$P(C_1|X)$<br>$$<br>P(X|C_1)&#x3D;P(x_1 &#x3D;“抽奖”|C_1)&#x3D;\frac{1}{63}<br>$$</p><p>$$<br>P(X|C_2)&#x3D;P(x_1 &#x3D;“抽奖”|C_2)&#x3D;\frac{1}{43}<br>$$</p><p>$$<br>P(C_1|X)&#x3D;\frac{P(X|C_1)P(C_1)}{P(X|C_1)P(C_1)+P(X|C_2)P(C_2)}&#x3D;\frac{\frac{1}{63}\times0.6}{\frac{1}{63}\times0.6+\frac{1}{43}\times0.4}&#x3D;\frac{\frac{1}{105}}{\frac{1}{105}+\frac{2}{215}}&#x3D;\frac{43}{86}<br>$$</p><p>可以看到拉普拉斯修正避免了因为某个特征概率为0而导致的不合理结果。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>感谢泰姆埃洛斯，伟大，无需多言</p><p><a href="https://zhuanlan.zhihu.com/p/677631759">[1] 南京大学软件学院-2023-数据仓库（研究生）期末复习参考</a></p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中常见的STL组件及相关函数</title>
      <link href="/2024/11/19/d5d029fa1dbc/"/>
      <url>/2024/11/19/d5d029fa1dbc/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了例如map、set等常见STL组件的基本使用方法与相关函数。</p><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><p>本质上是一个红黑树，能够保障有序性</p><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt; my_map</span><br><span class="line"><span class="comment">// 插入使用pair&lt;int,string&gt;</span></span><br><span class="line">my_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">1</span>,<span class="string">&quot;first&quot;</span>));</span><br><span class="line">my_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,string&gt;(<span class="number">2</span>,<span class="string">&quot;second&quot;</span>));</span><br></pre></td></tr></table></figure><p>或者使用数组方式赋值</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>,string&gt; my_map;</span><br><span class="line">my_map[<span class="number">1</span>]=<span class="string">&quot;first&quot;</span>;</span><br><span class="line">my_map[<span class="number">2</span>]=<span class="string">&quot;second&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>map&lt;&gt;.count函数只能判断是否存在这个键，返回值只有0和1</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map&lt;string,<span class="type">int</span>&gt; my_map;</span><br><span class="line">my_map[<span class="string">&quot;first&quot;</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 输出1；</span></span><br><span class="line">cout&lt;&lt;my_map.<span class="built_in">count</span>(<span class="string">&quot;first&quot;</span>)&lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>用find函数查找map中的位置，返回的是迭代器；如果map中没有这个键，则返回的是.end()</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt; my_map;  </span><br><span class="line">my_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;student_one&quot;</span>));  </span><br><span class="line">my_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;student_two&quot;</span>));  </span><br><span class="line">my_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;student_three&quot;</span>));  </span><br><span class="line">map&lt;<span class="type">int</span>, string&gt;::iterator it;  </span><br><span class="line">it = my_map.<span class="built_in">find</span>(<span class="number">1</span>);  </span><br><span class="line"><span class="keyword">if</span>(it != my_map.<span class="built_in">end</span>())  </span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;Find, the value is &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;      </span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">   cout&lt;&lt;<span class="string">&quot;Do not Find&quot;</span>&lt;&lt;endl;  </span><br></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>迭代器的定义方式</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt;::iterator it;  </span><br></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>使用迭代器删除，先通过find找到迭代器，然后删除</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">   map&lt;<span class="type">int</span>, string&gt; my_map;  </span><br><span class="line">   my_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">1</span>, <span class="string">&quot;one&quot;</span>));  </span><br><span class="line">   my_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">2</span>, <span class="string">&quot;two&quot;</span>));  </span><br><span class="line">   my_map.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, string&gt;(<span class="number">3</span>, <span class="string">&quot;three&quot;</span>));</span><br><span class="line">   map&lt;<span class="type">int</span>, string&gt;::iterator it;  </span><br><span class="line">   it = my_map.<span class="built_in">find</span>(<span class="number">1</span>);  </span><br><span class="line"><span class="comment">// 使用迭代器删除</span></span><br><span class="line">   my_map.<span class="built_in">erase</span>(it);</span><br><span class="line">   <span class="comment">// 用迭代器，成片的删除</span></span><br><span class="line">   my_map.<span class="built_in">erase</span>( my_map.<span class="built_in">begin</span>(), my_map.<span class="built_in">end</span>() ); </span><br></pre></td></tr></table></figure><p>或者直接使用key删除</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果删除了会返回1，否则返回0</span></span><br><span class="line"><span class="type">int</span> result = my_map.<span class="built_in">erase</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>map本身就是按照key的值升序排序的（从小到大），如果想要对value的值进行排序，可以通过vector然后调用sort</p><p>因为sort本身无法直接对map进行排序</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;string,<span class="type">int</span>&gt; a, pair&lt;string,<span class="type">int</span>&gt; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.second &lt; b.second;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; ma;</span><br><span class="line">ma[<span class="string">&quot;Alice&quot;</span>] = <span class="number">86</span>;</span><br><span class="line">ma[<span class="string">&quot;Bob&quot;</span>] = <span class="number">78</span>;</span><br><span class="line">ma[<span class="string">&quot;Zip&quot;</span>] = <span class="number">92</span>;</span><br><span class="line">ma[<span class="string">&quot;Stdevn&quot;</span>] = <span class="number">88</span>;</span><br><span class="line"><span class="comment">// 构造直接使用头迭代器和尾迭代器</span></span><br><span class="line">vector&lt; pair&lt;string,<span class="type">int</span>&gt; &gt; <span class="built_in">vec</span>(ma.<span class="built_in">begin</span>(),ma.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),cmp);</span><br></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p>map的key可以用first获取，value可以用second(pair同理)</p></blockquote><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">map&lt;<span class="type">int</span>, string&gt;::iterator it;  </span><br><span class="line">it = my_map.<span class="built_in">find</span>(<span class="number">1</span>);  </span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Find, the value is &quot;</span>&lt;&lt;it-&gt;second&lt;&lt;endl;</span><br></pre></td></tr></table></figure><h1 id="unordered-map"><a href="#unordered-map" class="headerlink" title="unordered_map"></a>unordered_map</h1><p>适用于查找，本质上是一个哈希表，因此查找速度很快</p><p>相关函数使用方法与map相同，头文件不同</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br></pre></td></tr></table></figure><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><p>性质：自动升序排列，按照从小到大的顺序</p><h2 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;<span class="comment">//定义 </span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">1</span>);<span class="comment">//插入元素1 </span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">3</span>);<span class="comment">//插入元素3</span></span><br></pre></td></tr></table></figure><h2 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h2><p>判断是否存在该元素</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">count</span>(<span class="number">2</span>)==<span class="number">1</span>  <span class="comment">//即包含元素2</span></span><br></pre></td></tr></table></figure><p>查找迭代器</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">find</span>(<span class="number">2</span>)   <span class="comment">//查找某个指定元素的迭代器</span></span><br></pre></td></tr></table></figure><h2 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erase()</span><br></pre></td></tr></table></figure><h1 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h1><p>优先队列，也就是堆，头文件：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>默认状态下是大顶堆，只需要填入类型即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br></pre></td></tr></table></figure><p>完整的定义有三个参数，第一个参数是类型，第二个参数是容器，第三个参数是排序方式</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此状态下为大顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; big_heap;</span><br><span class="line"><span class="comment">// 第三个参数更换为greater&lt;int&gt;可以转换为小顶堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; small_heap;</span><br></pre></td></tr></table></figure><p>重载 <code>operator()</code>是 C++ 中实现函数对象（Functor）的典型方法。它的设计是为了让结构体实例可以像函数一样被调用。</p><p>优先队列（<code>priority_queue</code>）的模板定义如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;, <span class="keyword">class</span> Compare = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure><p>其中，<code>Compare</code> 是一个比较器类型，它需要是一个可调用对象（即可以像函数一样使用）。</p><ul><li>如果 <code>Compare</code> 是一个普通函数，那么它的类型是函数指针。</li><li>如果 <code>Compare</code> 是一个结构体或类，那么它需要重载 <code>operator()</code>，使得实例可以像函数一样被调用。</li></ul><p>因此，重载 <code>operator()</code> 是为了让结构体 <code>cmp</code> 的实例可以像函数一样被调用，从而满足优先队列对比较器的要求。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义比较结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp1</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a &gt; b;<span class="comment">//最小值优先</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="type">int</span> &amp;a, <span class="type">int</span> &amp;b)</span></span></span><br><span class="line"><span class="function">     </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> a &lt; b;<span class="comment">//最大值优先</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp1&gt; small_heap;</span><br><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp2&gt; big_heap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体内定义比较方法</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">number1</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="type">int</span> x;</span><br><span class="line">     <span class="type">bool</span> <span class="keyword">operator</span> &lt; (<span class="type">const</span> number1 &amp;a) <span class="type">const</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">return</span> x &gt; a.x;<span class="comment">//最小值优先</span></span><br><span class="line">     &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;number1&gt; small_heap</span><br></pre></td></tr></table></figure><h2 id="添加"><a href="#添加" class="headerlink" title="添加"></a>添加</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// q.push(x);</span></span><br><span class="line">q.<span class="built_in">emplace</span>(x);</span><br></pre></td></tr></table></figure><h2 id="查看堆顶元素"><a href="#查看堆顶元素" class="headerlink" title="查看堆顶元素"></a>查看堆顶元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">q.top();</span><br></pre></td></tr></table></figure><h2 id="移除元素"><a href="#移除元素" class="headerlink" title="移除元素"></a>移除元素</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 移除优先级最高的元素（堆顶）</span></span><br><span class="line">q.<span class="built_in">pop</span>();</span><br></pre></td></tr></table></figure><h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><p>向量，类似数组的标准模板</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 8个元素均为0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">8</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode日常刷题总结</title>
      <link href="/2024/10/09/3158dd3ea568/"/>
      <url>/2024/10/09/3158dd3ea568/</url>
      
        <content type="html"><![CDATA[<p>本文记录了在LeetCode练习中针对部分题目的思路与题解。</p><h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&envId=2024-spring-sprint-100">48 旋转图像</a></h2><h3 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h3><p>给定一个 <em>n</em> × <em>n</em> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。</p><p>你必须在**<a href="https://baike.baidu.com/item/%E5%8E%9F%E5%9C%B0%E7%AE%97%E6%B3%95"> 原地</a>** 旋转图像，这意味着你需要直接修改输入的二维矩阵。<strong>请不要</strong> 使用另一个矩阵来旋转图像。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]</span><br><span class="line">输出：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/08/28/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]]</span><br><span class="line">输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]]</span><br></pre></td></tr></table></figure><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>问题转换成矩阵左上角进行旋转，每一次交换4个数据的位置，增加一个中间临时变量来完成交换。</p><p>问题关键在于左上角的定义，偶数不用赘述；矩阵边长为奇数时，取前n &#x2F; 2行，前(n + 1) &#x2F; 2列。以示例1为例，即(1, 2)视作左上角的矩阵。</p><p><strong>细节</strong></p><p>实现时要思考清楚矩阵中的交换元素，可以结合实例去验证判断。最终是交换matrix [i] [j]和matrix [n - j -1] [i]，接下来把n - j -1代入i，i代入j得到后续的交换下标即可。</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> row = n / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> col = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j <span class="number">-1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i <span class="number">-1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i <span class="number">-1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i <span class="number">-1</span>];</span><br><span class="line">            matrix[j][n - i <span class="number">-1</span>]= temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="402-移掉k位数字"><a href="#402-移掉k位数字" class="headerlink" title="402 移掉k位数字"></a><a href="https://leetcode.cn/problems/remove-k-digits/description/?envType=study-plan-v2&envId=2024-spring-sprint-100">402 移掉k位数字</a></h2><h3 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h3><p>给你一个以字符串表示的非负整数 <code>num</code> 和一个整数 <code>k</code> ，移除这个数中的 <code>k</code> 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><p><strong>示例 1 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;1432219&quot;, k = 3</span><br><span class="line">输出：&quot;1219&quot;</span><br><span class="line">解释：移除掉三个数字 4, 3, 和 2 形成一个新的最小的数字 1219 。</span><br></pre></td></tr></table></figure><p><strong>示例 2 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;10200&quot;, k = 1</span><br><span class="line">输出：&quot;200&quot;</span><br><span class="line">解释：移掉首位的 1 剩下的数字为 200. 注意输出不能有任何前导零。</span><br></pre></td></tr></table></figure><p><strong>示例 3 ：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：num = &quot;10&quot;, k = 2</span><br><span class="line">输出：&quot;0&quot;</span><br><span class="line">解释：从原数字移除所有的数字，剩余为空就是 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= num.length &lt;= 105</code></li><li><code>num</code> 仅由若干位数字（0 - 9）组成</li><li>除了 <strong>0</strong> 本身之外，<code>num</code> 不含任何前导零</li></ul><h3 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>数字或者字母排序可以构建单调栈来保持顺序，遍历整个字符串，当遇到字符小于栈顶字符时弹栈直至栈空或大于栈顶字符。移除过程中可能会出现移除的字母数小于k，但字符串已经是从小到大排序的了，此时仅需要取字符串的前num.size() - k位并删除前导0即可。</p><p><strong>细节</strong></p><p>循环条件是重点，while(k !&#x3D; 0 &amp;&amp; !s.empty() &amp;&amp; s[s.size()-1]  &gt;  c)即还有字符没有删除、栈不为空、当前字符小于栈顶字符时执行弹栈。</p><p>另外string可以用来当栈使用，pop_back()函数可实现stack.pop()一样的效果</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeKdigits</span><span class="params">(string num, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = num.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = n - k;</span><br><span class="line">        <span class="keyword">if</span>(res == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string s = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : num) &#123;</span><br><span class="line">            <span class="keyword">while</span>(k!=<span class="number">0</span> &amp;&amp; !s.<span class="built_in">empty</span>() &amp;&amp; s[s.<span class="built_in">size</span>()<span class="number">-1</span>] &gt; c) &#123;</span><br><span class="line">                s.<span class="built_in">pop_back</span>();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            s += c;</span><br><span class="line">        &#125;</span><br><span class="line">        s = s.<span class="built_in">substr</span>(<span class="number">0</span>, res);</span><br><span class="line">        <span class="comment">// 消除前导0</span></span><br><span class="line">        <span class="keyword">while</span>(s[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; s.<span class="built_in">size</span>()!=<span class="number">1</span>) &#123;</span><br><span class="line">            s.<span class="built_in">erase</span>(s.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=2024-spring-sprint-100">94 二叉树的中序遍历</a></h2><h3 id="题干-2"><a href="#题干-2" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉树的根节点 <code>root</code> ，返回 <em>它的 <strong>中序</strong> 遍历</em> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/inorder_1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,null,2,3]</span><br><span class="line">输出：[1,3,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><h3 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>递归；迭代需要依托栈，入栈直到为空，出栈并添加到返回向量中</p><p><strong>实现</strong></p><p>若输出方式是ACM模式，不需要额外创建中间函数，在inorderTraversal函数中调用标准输出流即可；若输出方式是核心代码模式，则需要另外创建一个向量存储返回结果，并创建一个中间函数用于更新结果向量。</p><p><strong>代码</strong></p><p>递归：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),</span></span><br><span class="line"><span class="comment"> * right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorderTraversal</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>迭代：</p><p>迭代的第一个循环条件是当前节点为空或者栈为空则结束循环。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">    stack&lt;TreeNode*&gt; s;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="comment">// 当前处理节点不为空或者待处理节点不为空</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 找到最左</span></span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur -&gt; left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = s.<span class="built_in">top</span>();</span><br><span class="line">        res.<span class="built_in">push_back</span>(cur -&gt; val);</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        cur = cur -&gt; right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><h3 id="题干-3"><a href="#题干-3" class="headerlink" title="题干"></a>题干</h3><p>给你一个二叉树的根节点 <code>root</code> ，判断其是否是一个有效的二叉搜索树。</p><p><strong>有效</strong> 二叉搜索树定义如下：</p><ul><li><p>节点的左</p><p>子树</p><p>只包含</p><p> 小于 </p><p>当前节点的数。</p></li><li><p>节点的右子树只包含 <strong>大于</strong> 当前节点的数。</p></li><li><p>所有左子树和右子树自身必须也是二叉搜索树。</p></li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/12/01/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围在<code>[1, 104]</code> 内</li><li><code>-231 &lt;= Node.val &lt;= 231 - 1</code></li></ul><h3 id="题解-3"><a href="#题解-3" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，因此可以通过判断中序遍历的结果是否升序来判断是不是BST</li><li></li></ul><p><strong>细节</strong></p><p>上下界的递归，基本框架就是<code>return judge(root, (long) INT_MIN - 1, (long) INT_MAX + 1)</code>，这一部分很容易想。难点在于上下界的界定，左子树无下界，只有上界；右子树无下界，只有上届。</p><p><strong>代码</strong></p><ol><li><strong>中序遍历</strong>判断是否递增</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// -(2^31+1) 宏是INT_MIN</span></span><br><span class="line">    <span class="comment">// long prev = (long) (1&lt;&lt;31) - 1;</span></span><br><span class="line">    <span class="type">long</span> prev = (<span class="type">long</span>) INT_MIN - <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= prev) &#123;</span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> prev = root-&gt;val;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>[!Note]</p><p><strong>INT_MIN</strong>是CPP中的最小整数值-2147483648的宏，也可以用1&lt;&lt;31表示，但是要做减法运算需要转换为<strong>long</strong>类型</p></blockquote><ol start="2"><li><strong>上下界</strong>递归</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(TreeNode* root, <span class="type">long</span> low, <span class="type">long</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &lt;= low || root-&gt;val &gt;= high) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(root-&gt;left, low, root-&gt;val) &amp;&amp; <span class="built_in">judge</span>(root-&gt;right, root-&gt;val, high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">judge</span>(root, (<span class="type">long</span>) INT_MIN - <span class="number">1</span>, (<span class="type">long</span>) INT_MAX + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="230-二叉搜索树中第-K-小的元素"><a href="#230-二叉搜索树中第-K-小的元素" class="headerlink" title="230. 二叉搜索树中第 K 小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第 K 小的元素</a></h2><h3 id="题干-4"><a href="#题干-4" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 小的元素（从 1 开始计数）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,null,1], k = 3</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中的节点数为 <code>n</code> 。</li><li><code>1 &lt;= k &lt;= n &lt;= 104</code></li><li><code>0 &lt;= Node.val &lt;= 104</code></li></ul><h3 id="题解-4"><a href="#题解-4" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>BST的中序遍历是递增的，符合题目要求</p><p><strong>细节</strong></p><p>用数组存储中序遍历结果即可，看清楚k的定义，这里选取<code>array[k-1]</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; array;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left);</span><br><span class="line">        array.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode* root, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">inorder</span>(root);</span><br><span class="line">        <span class="keyword">return</span> array[k<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><h3 id="题干-5"><a href="#题干-5" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉树的 <strong>根节点</strong> <code>root</code>，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><p><strong>示例 1：</strong></p><p><strong>输入：</strong>root &#x3D; [1,2,3,null,5,null,4]</p><p><strong>输出：</strong>[1,3,4]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpd5jn43fs-1.png" alt="img"></p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>root &#x3D; [1,2,3,4,null,null,null,5]</p><p><strong>输出：</strong>[1,3,4,5]</p><p><strong>解释：</strong></p><p><img src="https://assets.leetcode.com/uploads/2024/11/24/tmpkpe40xeh-1.png" alt="img"></p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>root &#x3D; [1,null,3]</p><p><strong>输出：</strong>[1,3]</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>root &#x3D; []</p><p><strong>输出：</strong>[]</p><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,100]</code></li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题解-5"><a href="#题解-5" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>参照题目意思，右视图的定义应该使用<strong>层序遍历</strong>去解决，每一层节点直接有优先级，优先级关系为：<code>右右&gt;右左&gt;左右&gt;左左</code></p><p><strong>细节</strong></p><p>层序遍历使用<strong>队列</strong>实现，内循环条件基于队列的大小，本题中队列末尾对应最右侧的节点</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 顺序 右右 右左 左右 左左 层序遍历 队列</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            queue&lt;TreeNode*&gt; q;</span><br><span class="line">            q.<span class="built_in">push</span>(root);</span><br><span class="line">            TreeNode* cur = <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                len = q.<span class="built_in">size</span>();</span><br><span class="line">                cur = q.<span class="built_in">back</span>();</span><br><span class="line">                ans.<span class="built_in">emplace_back</span>(cur-&gt;val);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                    cur = q.<span class="built_in">front</span>();</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><h3 id="题干-6"><a href="#题干-6" class="headerlink" title="题干"></a>题干</h3><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code> 。</li><li>展开后的单链表应该与二叉树 <a href="https://baike.baidu.com/item/%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86/6442839?fr=aladdin"><strong>先序遍历</strong></a> 顺序相同。</li></ul><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="题解-6"><a href="#题解-6" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>不考虑空间限制的情况下，按照<strong>先序遍历</strong>的方式将节点指针用数组存储，再迭代数组替换为右节点并清空左节点即可</p><p><strong>细节</strong></p><p>先序遍历时根节点也会被加入到vec中，进行展开链表的构建时需要跳过它</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flattenHelper</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">emplace_back</span>(root);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">flattenHelper</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">flattenHelper</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">flatten</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">flattenHelper</span>(root);</span><br><span class="line">        TreeNode* cur = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            cur-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            cur-&gt;right = vec[i];</span><br><span class="line">            cur = cur-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><h3 id="题干-7"><a href="#题干-7" class="headerlink" title="题干"></a>题干</h3><p>给定两个整数数组 <code>preorder</code> 和 <code>inorder</code> ，其中 <code>preorder</code> 是二叉树的<strong>先序遍历</strong>， <code>inorder</code> 是同一棵树的<strong>中序遍历</strong>，请构造二叉树并返回其根节点。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/02/19/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">输出: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: preorder = [-1], inorder = [-1]</span><br><span class="line">输出: [-1]</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= preorder.length &lt;= 3000</code></li><li><code>inorder.length == preorder.length</code></li><li><code>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</code></li><li><code>preorder</code> 和 <code>inorder</code> 均 <strong>无重复</strong> 元素</li><li><code>inorder</code> 均出现在 <code>preorder</code></li><li><code>preorder</code> <strong>保证</strong> 为二叉树的前序遍历序列</li><li><code>inorder</code> <strong>保证</strong> 为二叉树的中序遍历序列</li></ul><h3 id="题解-7"><a href="#题解-7" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>思路1是通过递归拆分成左子树和右子树的构建，进而转化为<code>preorder</code>和<code>inorder</code>子数组的划分，缺点是<code>cpp</code>实现不方便</p><p>思路2不划分子数组，而是通过明确子数组的边界来代替切分，缺点是参数多，容易混淆</p><p><strong>细节</strong></p><p><code>python</code>数组切片冒号前面的包括，后面的不包括；另外需要判断<code>preorder</code>和<code>inorder</code>是否为空，若为空则表示无法构建子树，返回<code>None</code></p><p><code>cpp</code>实现可以建立一个哈希表，便于查找根节点在<code>inorder</code>数组中的下标；左子树的size可以根据<code>inorder</code>根节点的下标与<code>inorder</code>左边界进行计算</p><p><strong>代码</strong></p><ol><li>子数组&#x2F;数组切片递归，<code>python</code>子数组实现更方便</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTreeHelper</span>(<span class="params">self, preorder, inorder</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> preorder <span class="keyword">or</span> <span class="keyword">not</span> inorder:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">            </span><br><span class="line">        root = TreeNode(preorder[<span class="number">0</span>])</span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> left &lt; <span class="built_in">len</span>(inorder):</span><br><span class="line">            <span class="keyword">if</span> inorder[left] == preorder[<span class="number">0</span>]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            left = left + <span class="number">1</span>  </span><br><span class="line"></span><br><span class="line">        right = <span class="built_in">len</span>(inorder) - <span class="number">1</span> - left</span><br><span class="line">        <span class="comment"># pre:[1, left+1] in:[0, left]</span></span><br><span class="line">        root.left = self.buildTreeHelper(preorder[<span class="number">1</span>:left+<span class="number">1</span>], inorder[<span class="number">0</span>:left])</span><br><span class="line">        <span class="comment"># pre:[left+1, end] in:[left+1, end]</span></span><br><span class="line">        root.right = self.buildTreeHelper(preorder[left+<span class="number">1</span>:], inorder[left+<span class="number">1</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buildTree</span>(<span class="params">self, preorder, inorder</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        :type preorder: List[int]</span></span><br><span class="line"><span class="string">        :type inorder: List[int]</span></span><br><span class="line"><span class="string">        :rtype: Optional[TreeNode]</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.buildTreeHelper(preorder, inorder)</span><br></pre></td></tr></table></figure><ol start="2"><li><code>cpp</code>解法，通过明确先序数组和中序数组的边界来代替数组切片</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTreeHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> preLeft, <span class="type">int</span> preRight, <span class="type">int</span> inLeft,</span></span></span><br><span class="line"><span class="params"><span class="function">                              <span class="type">int</span> inRight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (inRight &lt; inLeft)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preLeft]);</span><br><span class="line">        <span class="type">int</span> rootIndex = index[preorder[preLeft]];</span><br><span class="line">        <span class="type">int</span> leftSize = rootIndex - inLeft;</span><br><span class="line">        <span class="comment">// 先序边界[preLeft + 1, preLeft + leftSize] 中序边界[inLeft, rootIndex - 1]  </span></span><br><span class="line">        root-&gt;left =</span><br><span class="line">            <span class="built_in">buildTreeHelper</span>(preorder, inorder, preLeft + <span class="number">1</span>,</span><br><span class="line">                            preLeft + leftSize, inLeft, rootIndex - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 先序边界[preLeft + 1 + leftSize, preRight] 中序边界[rootIndex + 1, inRight]</span></span><br><span class="line">        root-&gt;right =</span><br><span class="line">            <span class="built_in">buildTreeHelper</span>(preorder, inorder, preLeft + <span class="number">1</span> + leftSize,</span><br><span class="line">                            preRight, rootIndex + <span class="number">1</span>, inRight);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildTreeHelper</span>(preorder, inorder, <span class="number">0</span>, preorder.<span class="built_in">size</span>() - <span class="number">1</span>, <span class="number">0</span>,</span><br><span class="line">                               inorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2><h3 id="题干-8"><a href="#题干-8" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉树的根节点 <code>root</code> ，和一个整数 <code>targetSum</code> ，求该二叉树里节点值之和等于 <code>targetSum</code> 的 <strong>路径</strong> 的数目。</p><p><strong>路径</strong> 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/04/09/pathsum3-1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [10,5,-3,3,2,null,11,3,-2,null,1], targetSum = 8</span><br><span class="line">输出：3</span><br><span class="line">解释：和等于 8 的路径有 3 条，如图所示。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li>二叉树的节点个数的范围是 <code>[0,1000]</code></li><li><code>-109 &lt;= Node.val &lt;= 109</code> </li><li><code>-1000 &lt;= targetSum &lt;= 1000</code></li></ul><h3 id="题解-8"><a href="#题解-8" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>根据题目意思容易想到搜索每一条路径，统计和为<code>targetsum</code>的路径。使用递归的思想先构建辅助函数，求出以指定节点作为根节点时，经过该根节点同时节点值和为<code>targetsum</code>的路径数目，再双重递归将每一个节点作为根节点并求和</p><p><strong>细节</strong></p><p>双重递归很容易混淆，需要理清思路和结构；</p><p><code>pathSumHelper</code>函数中的<code>targetSum</code>参数要使用<code>long</code>类型，因为<code>root-&gt;val</code>的范围是<code>-10^9 &lt;= Node.val &lt;= 10^9</code> ，超过了<code>int</code>的范围</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSumHelper</span><span class="params">(TreeNode* root, <span class="type">long</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val == targetSum) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pathSumHelper</span>(root-&gt;left, targetSum - root-&gt;val) +</span><br><span class="line">                   <span class="built_in">pathSumHelper</span>(root-&gt;right, targetSum - root-&gt;val) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">pathSumHelper</span>(root-&gt;left, targetSum - root-&gt;val) +</span><br><span class="line">                   <span class="built_in">pathSumHelper</span>(root-&gt;right, targetSum - root-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">pathSumHelper</span>(root, targetSum);</span><br><span class="line">        ans += <span class="built_in">pathSum</span>(root-&gt;left, targetSum);</span><br><span class="line">        ans += <span class="built_in">pathSum</span>(root-&gt;right, targetSum);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><h3 id="题干-9"><a href="#题干-9" class="headerlink" title="题干"></a>题干</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p><a href="https://baike.baidu.com/item/%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/8918834?fr=aladdin">百度百科</a>中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（<strong>一个节点也可以是它自己的祖先</strong>）。”</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2018/12/14/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 <code>[2, 105]</code> 内。</li><li><code>-109 &lt;= Node.val &lt;= 109</code></li><li>所有 <code>Node.val</code> <code>互不相同</code> 。</li><li><code>p != q</code></li><li><code>p</code> 和 <code>q</code> 均存在于给定的二叉树中。</li></ul><h3 id="题解-9"><a href="#题解-9" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>两个节点分别位于左右子树时，说明当前节点是最近祖先；递归的终止条件：如果当前节点为空或者为<code>p</code> 或 <code>q</code>，则返回当前节点，如果只有一方为空则说明两个节点都位于这个子树，返回它的递归结果即可。</p><blockquote><p>[!Note]</p><p>根据递归终止条件，实际上结果是自底向上的，因此满足<strong>深度尽可能大</strong>这一要求</p></blockquote><p><strong>细节</strong></p><p>比较特别的递归终止条件，需要结合理解去记忆</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 两个节点分别位于左右子树时 说明当前节点是最近祖先</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        TreeNode* left = <span class="built_in">lowestCommonAncestor</span>(root-&gt;left, p, q);</span><br><span class="line">        TreeNode* right = <span class="built_in">lowestCommonAncestor</span>(root-&gt;right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left &amp;&amp; right) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left? left:right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><h3 id="题干-10"><a href="#题干-10" class="headerlink" title="题干"></a>题干</h3><p>二叉树中的 <strong>路径</strong> 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/13/exx2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 104]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="题解-10"><a href="#题解-10" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>递归搜索，计算经过每个节点的路径，若当前路径大于最长路径则更新最长路径</p><p><strong>细节</strong></p><p>辅助函数的返回值并不是经过当前节点的<code>左路</code>+<code>右路</code>+<code>val</code>，而应该是<code>左路和右路的最大值</code>+<code>val</code>，这样才符合更新答案的部分需要的返回值，以最后一个示例为例，路径经过节点<code>20</code>向下搜索时不可能既走左边又走右边，应当择最大值；考虑到递归的返回是自底向上的，因此当前的<code>左子值</code>和<code>右子值</code>都是最优解。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// dfs 返回最大 统计</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1001</span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        left = <span class="built_in">max</span>(<span class="number">0</span>, left);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        right = <span class="built_in">max</span>(<span class="number">0</span>, right);</span><br><span class="line">        <span class="type">int</span> val = root-&gt;val + <span class="built_in">max</span>(left, right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val + left + right &gt; ans) ans = root-&gt;val + left + right;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><h3 id="题干-11"><a href="#题干-11" class="headerlink" title="题干"></a>题干</h3><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和&#x2F;或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul><h3 id="题解-11"><a href="#题解-11" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>参考了题解<a href="https://leetcode.cn/problems/number-of-islands/solutions/211211/dao-yu-lei-wen-ti-de-tong-yong-jie-fa-dfs-bian-li-">“岛屿类问题的通用解法、DFS 遍历框架”</a></p><p>将树中搜索从对左右子节点递归搜索改成对矩阵周围元素的搜索</p><ul><li>需要有边界检查</li><li>需要避免重复搜索即搜索之后做标记</li></ul><p><strong>细节</strong></p><p>边界判断方面可以基于函数实现，代码会更优雅清晰一些，边界检查的上限要通常是≥时不符合</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inArea</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">inArea</span>(grid.<span class="built_in">size</span>(), grid[<span class="number">0</span>].<span class="built_in">size</span>(), i, j)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                <span class="built_in">update</span>(grid, i - <span class="number">1</span>, j);</span><br><span class="line">                <span class="built_in">update</span>(grid, i + <span class="number">1</span>, j);</span><br><span class="line">                <span class="built_in">update</span>(grid, i, j - <span class="number">1</span>);</span><br><span class="line">                <span class="built_in">update</span>(grid, i, j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="built_in">update</span>(grid, i, j);</span><br><span class="line">                    ++ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h2><h3 id="题干-12"><a href="#题干-12" class="headerlink" title="题干"></a>题干</h3><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 <strong>周围 4 个方向上相邻</strong> 的新鲜橘子都会腐烂。</p><p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p><p><strong>示例 1：</strong></p><p><strong><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/02/16/oranges.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[1,1,0],[0,1,1]]</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[2,1,1],[0,1,1],[1,0,1]]</span><br><span class="line">输出：-1</span><br><span class="line">解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：grid = [[0,2]]</span><br><span class="line">输出：0</span><br><span class="line">解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><h3 id="题解-12"><a href="#题解-12" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>首先需要统计新鲜橘子数目，并且不断更新，才能判断最后是否全部腐烂</li><li>其次需要BFS&#x2F;层序，贴合题目中的一轮一轮的模拟</li><li>最后在层序遍历的同时更新矩阵，避免重复感染好橘子</li></ul><p><strong>细节</strong></p><ul><li>因为橘子向上下左右四个方向感染，因此可以创建一个辅助数组来便于感染部分代码实现</li><li>层序遍历的模板一般是外循环判断队列是否为空，内循环根据队列当前大小（动态变化因此需要一个变量存储当前大小）决定循环次数</li><li>可能会出现的问题：1. 只有坏橘子，没有好橘子； 2. 最后一次内循环，已经全是坏橘子了，并没有传染给其他橘子<ul><li>在<code>while</code>循环中添加一个<code>fresh</code>辅助判断，可以有效解决两个问题</li><li>不改变外循环条件，则在循环前进行<code>fresh</code>数目判断，可解决问题1；增加一个布尔变量记录是否发生感染放在内循环，用于更新<code>ans</code></li></ul></li></ul><p><strong>代码</strong></p><ol><li>自己写的，不是很优雅，效率也低了点</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inGrid</span><span class="params">(<span class="type">int</span> row, <span class="type">int</span> col, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= row || j &lt; <span class="number">0</span> || j &gt;= col)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 感染橘子辅助数组</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="comment">// 坏橘子队列</span></span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 好橘子计数</span></span><br><span class="line">        <span class="type">int</span> fresh = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 坏橘子入队列 好橘子计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    ++fresh;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 队列大小</span></span><br><span class="line">        <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 分钟数</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (fresh &amp;&amp; !q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cur = q.<span class="built_in">front</span>();</span><br><span class="line">                <span class="comment">// 感染其他橘子</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> dir : dirs) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">inGrid</span>(grid.<span class="built_in">size</span>(), grid[<span class="number">0</span>].<span class="built_in">size</span>(), cur.first + dir[<span class="number">0</span>],</span><br><span class="line">                               cur.second + dir[<span class="number">1</span>]) &amp;&amp;</span><br><span class="line">                        grid[cur.first + dir[<span class="number">0</span>]][cur.second + dir[<span class="number">1</span>]] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[cur.first + dir[<span class="number">0</span>]][cur.second + dir[<span class="number">1</span>]] = <span class="number">2</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;cur.first + dir[<span class="number">0</span>], cur.second + dir[<span class="number">1</span>]&#125;);</span><br><span class="line">                        --fresh;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有剩余的好橘子</span></span><br><span class="line">        <span class="keyword">if</span> (fresh)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>请gpt优化过的，思路没换</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">inGrid</span><span class="params">(<span class="type">int</span> rows, <span class="type">int</span> cols, <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; directions = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="type">int</span> fresh = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化队列和计数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    ++fresh;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">emplace</span>(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fresh == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 没有好橘子，直接返回</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> minutes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">bool</span> hasRotten = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; size; ++k) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [x, y] = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dx, dy] : directions) &#123;</span><br><span class="line">                    <span class="type">int</span> nx = x + dx, ny = y + dy;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">inGrid</span>(grid.<span class="built_in">size</span>(), grid[<span class="number">0</span>].<span class="built_in">size</span>(), nx, ny) &amp;&amp; grid[nx][ny] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[nx][ny] = <span class="number">2</span>; <span class="comment">// 感染橘子</span></span><br><span class="line">                        q.<span class="built_in">emplace</span>(nx, ny);</span><br><span class="line">                        --fresh;</span><br><span class="line">                        hasRotten = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasRotten) ++minutes; <span class="comment">// 只有感染发生时才增加时间</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fresh == <span class="number">0</span> ? minutes : <span class="number">-1</span>; <span class="comment">// 剩余好橘子返回 -1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表*"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表*</a></h2><h3 id="题干-13"><a href="#题干-13" class="headerlink" title="题干"></a>题干</h3><p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p><p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p><ul><li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li></ul><p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numCourses &lt;= 2000</code></li><li><code>0 &lt;= prerequisites.length &lt;= 5000</code></li><li><code>prerequisites[i].length == 2</code></li><li><code>0 &lt;= ai, bi &lt; numCourses</code></li><li><code>prerequisites[i]</code> 中的所有课程对 <strong>互不相同</strong></li></ul><h3 id="题解-13"><a href="#题解-13" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>先后关系&#x2F;依赖关系 转换为有向图，若能构成包含所有节点的<strong>有向无环图</strong>则能完成所有课程。将有向无环图转化为线性排序即为<strong>拓扑排序</strong>。</p><p>有向图有<strong>入度</strong>&#x2F;出度的概念，通过队列保存当前入度为0的节点，然后按照bfs的思想搜索并不断更新完成课程的数目，直至队列为空。</p><p><strong>细节</strong></p><p>通过哈希表存储从当前节点出发的边，可以快速对依赖关系做更新</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 有向图的思想 计算入度 当入度为0说明没有前置条件 使用队列进行bfs</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(numCourses)</span></span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : prerequisites) &#123;</span><br><span class="line">            ++count[item[<span class="number">0</span>]];</span><br><span class="line">            mp[item[<span class="number">1</span>]].<span class="built_in">emplace_back</span>(item[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;numCourses; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(count[i] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="type">int</span> unfinish = numCourses;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            --unfinish;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : mp[cur]) &#123;</span><br><span class="line">                <span class="keyword">if</span>(count[item] &gt; <span class="number">0</span>) --count[item];</span><br><span class="line">                <span class="keyword">if</span>(count[item] == <span class="number">0</span>) q.<span class="built_in">emplace</span>(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(unfinish) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><h3 id="题干-14"><a href="#题干-14" class="headerlink" title="题干"></a>题干</h3><p>**<a href="https://baike.baidu.com/item/%E5%AD%97%E5%85%B8%E6%A0%91/9825209?fr=aladdin">Trie</a>**（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。</p><p>请你实现 Trie 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入</span><br><span class="line">[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</span><br><span class="line">[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, true, false, true, null, true]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">Trie trie = new Trie();</span><br><span class="line">trie.insert(&quot;apple&quot;);</span><br><span class="line">trie.search(&quot;apple&quot;);   // 返回 True</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 False</span><br><span class="line">trie.startsWith(&quot;app&quot;); // 返回 True</span><br><span class="line">trie.insert(&quot;app&quot;);</span><br><span class="line">trie.search(&quot;app&quot;);     // 返回 True</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数 <strong>总计</strong> 不超过 <code>3 * 104</code> 次</li></ul><h3 id="题解-14"><a href="#题解-14" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ol><li>用集合或者哈希表，查找效率高，查找前缀效率低</li><li>使用字典树，26叉树列举出现过的字符，查找即搜索</li></ol><p><strong>细节</strong></p><p>cpp初始化成员变量的方式：<code>Trie() : children(26), isEnd(false) &#123;&#125;</code></p><p>迭代搜索时使用临时变量<code>node</code>进行，初始化为<code>Trie* node = this;</code>，迭代<code>node = node-&gt;children[c];</code></p><p><strong>代码</strong></p><ol><li>自己写的，效率略低</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    set&lt;string&gt; s;</span><br><span class="line">    <span class="built_in">Trie</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">insert</span>(word);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">count</span>(word)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;str : s) &#123;</span><br><span class="line">            <span class="type">bool</span> ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;prefix.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i] != prefix[i]) &#123;</span><br><span class="line">                    ans = <span class="literal">false</span>; </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>26叉树&#x2F;字典树</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 26个子节点</span></span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="comment">// 当前节点是否为某个字符串的结尾</span></span><br><span class="line">    <span class="type">bool</span> isEnd;</span><br><span class="line">    <span class="comment">// 若prefix存在，返回结尾节点；若不存在，返回NULL</span></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : prefix) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 初始化 子节点全为空 不是结尾</span></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将对应位置的子节点初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word) &#123;</span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[c] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                node-&gt;children[c] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 前缀返回值不为空同时要求当前节点为结尾</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">if</span> (node &amp;&amp; node-&gt;isEnd)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 前缀返回值不为空则表示有该前缀</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">searchPrefix</span>(prefix) == <span class="literal">NULL</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><h3 id="题干-15"><a href="#题干-15" class="headerlink" title="题干"></a>题干</h3><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0,1]</span><br><span class="line">输出：[[0,1],[1,0]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[[1]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li></ul><h3 id="题解-15"><a href="#题解-15" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>回溯与深度优先搜索雷同，递归思路相似；</li><li>通过循环遍历的方式依次固定位置，从0开始到<code>nums.size()-1</code>例如<code>[1, 2, 3]</code>的全排列可以转化为<code>1+[2, 3]</code>、<code>2+[1, 3]</code>、<code>3+[1, 2]</code>的全排列，依次类推</li></ul><p><strong>细节</strong></p><p>递归终止条件即固定到最后一位，无需遍历，此时将当前<code>nums</code>添加到结果集中</p><p><strong>代码</strong></p><ol><li>解法一：<code>nums</code>作为参数不传递引用，易理解、代码简单</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]); <span class="comment">// 交换，将 nums[i] 固定在第 x 位</span></span><br><span class="line">            <span class="built_in">dfs</span>(nums, x + <span class="number">1</span>);       <span class="comment">// 开启固定第 x + 1 位元素</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>解法二：<code>nums</code>的引用传参，<code>nums</code>在递归返回后会与递归前不一致，从而影响结果，因此需要撤销交换</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums); <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]); <span class="comment">// 交换，将 nums[i] 固定在第 x 位</span></span><br><span class="line">            <span class="built_in">dfs</span>(nums, x + <span class="number">1</span>);       <span class="comment">// 开启固定第 x + 1 位元素</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]); <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><h3 id="题干-16"><a href="#题干-16" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的</p><p>子集</p><p>（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul><h3 id="题解-16"><a href="#题解-16" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>子集数目是2^n，可以使用二进制来考虑每一个元素是否加入当前集合，作为子集之一</li><li>对于<code>cur</code>位置，我们需要考虑<code>a[cur]</code>取或者不取，如果取，我们需要把<code>a[cur]</code>放入一个临时的答案数组中，再执行 <code>dfs(cur+1,n)</code>，执行结束后需要对临时数组进行回溯；如果不取，则直接执行<code> dfs(cur+1,n)</code>。在整个递归调用的过程中，<code>cur</code> 是从小到大递增的，当<code>cur</code> 增加到<code>n</code>的时候，记录答案并终止递归。</li></ul><p><strong>细节</strong></p><ul><li>第一层循环是0到2^n-1，第二层循环是0到size，使用当前掩码<code>mask</code>和<code>1 &lt;&lt; i</code>做<code>&amp;</code>运算</li><li>递归终止条件是cur &#x3D;&#x3D; nums.size()，表示所有位置都已经确定</li></ul><p><strong>代码</strong></p><ol><li>使用二进制掩码来判断是否添加到当前集合作为子集</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 子集数目是2^n 可以使用二进制来表示子集(空集和全集都纳入了考虑)</span></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; <span class="number">1</span> &lt;&lt; n; ++mask) &#123;</span><br><span class="line">            temp.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask &amp; <span class="number">1</span> &lt;&lt; i) &#123;</span><br><span class="line">                    temp.<span class="built_in">emplace_back</span>(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>回溯，添加当前元素，递归考虑cur+1之后的情况；回溯撤回添加，递归考虑cur+1之后的情况</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">        t.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h2><h3 id="题干-17"><a href="#题干-17" class="headerlink" title="题干"></a>题干</h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。答案可以按 <strong>任意顺序</strong> 返回。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png" alt="img"></p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;23&quot;</span><br><span class="line">输出：[&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;&quot;</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：digits = &quot;2&quot;</span><br><span class="line">输出：[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= digits.length &lt;= 4</code></li><li><code>digits[i]</code> 是范围 <code>[&#39;2&#39;, &#39;9&#39;]</code> 的一个数字。</li></ul><h3 id="题解-17"><a href="#题解-17" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>每个位置选择对应的每个字母，排列组合；</li><li>递归返回条件是当<code>cur == digits.size()</code>，说明每一位都已经确定了；</li><li>使用哈希表做映射，能够快速遍历每个数字对应的字母列表。</li></ul><p><strong>细节</strong></p><ul><li><code>digits</code>作为参数传递时使用引用，减小开销；</li><li><code>string</code>没有<code>emplace_back()</code>，但是有<code>pop_back()</code>；</li><li>成员变量<code>mp</code>的初始化通过函数进行。</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    string s;</span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, string&gt; mp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, string&amp; digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == digits.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(s);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; mp[digits[cur]].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            s += mp[digits[cur]][i];</span><br><span class="line">            <span class="built_in">dfs</span>(cur + <span class="number">1</span>, digits);</span><br><span class="line">            s.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        mp[<span class="string">&#x27;2&#x27;</span>] = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;3&#x27;</span>] = <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;4&#x27;</span>] = <span class="string">&quot;ghi&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;5&#x27;</span>] = <span class="string">&quot;jkl&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;6&#x27;</span>] = <span class="string">&quot;mno&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;7&#x27;</span>] = <span class="string">&quot;pqrs&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;8&#x27;</span>] = <span class="string">&quot;tuv&quot;</span>;</span><br><span class="line">        mp[<span class="string">&#x27;9&#x27;</span>] = <span class="string">&quot;wxyz&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!digits.<span class="built_in">empty</span>()) <span class="built_in">dfs</span>(<span class="number">0</span>, digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><h3 id="题干-18"><a href="#题干-18" class="headerlink" title="题干"></a>题干</h3><p>给你一个 <strong>无重复元素</strong> 的整数数组 <code>candidates</code> 和一个目标整数 <code>target</code> ，找出 <code>candidates</code> 中可以使数字和为目标数 <code>target</code> 的 所有 <strong>不同组合</strong> ，并以列表形式返回。你可以按 <strong>任意顺序</strong> 返回这些组合。</p><p><code>candidates</code> 中的 <strong>同一个</strong> 数字可以 <strong>无限制重复被选取</strong> 。如果至少一个数字的被选数量不同，则两种组合是不同的。 </p><p>对于给定的输入，保证和为 <code>target</code> 的不同组合数少于 <code>150</code> 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：candidates = [2,3,6,7], target = 7</span><br><span class="line">输出：[[2,2,3],[7]]</span><br><span class="line">解释：</span><br><span class="line">2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。</span><br><span class="line">7 也是一个候选， 7 = 7 。</span><br><span class="line">仅有这两种组合。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2,3,5], target = 8</span><br><span class="line">输出: [[2,2,2,2],[2,3,3],[3,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: candidates = [2], target = 1</span><br><span class="line">输出: []</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= candidates.length &lt;= 30</code></li><li><code>2 &lt;= candidates[i] &lt;= 40</code></li><li><code>candidates</code> 的所有元素 <strong>互不相同</strong></li><li><code>1 &lt;= target &lt;= 40</code></li></ul><h3 id="题解-18"><a href="#题解-18" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>看到可选重复的我以为确认每一位的方法不可行了，实际上依旧可以套用这个模板，只需要在此基础上更改递归的选择思路，选择当前元素后可以再选当前元素，递归修改为<code>dfs(cur)</code>，回溯后跳过该元素进行下一个位置的确定<code>dfs(cur+1)</code>。这样可以保障每个元素都可以出现n次。</p><p><strong>细节</strong></p><ul><li>递归终止条件除了<code>cur == candidates.size()</code>表示所有位置都已经确定了，还要增加<code>target == 0</code>，并且在此时将<code>t</code>添加到<code>ans</code>中</li><li><code>target - candidates[cur] &gt;= 0</code> 表示还能继续容纳，<code>target == 0</code>作为终止条件比<code>candidates[cur] == target</code>更符合逻辑</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == candidates.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择当前</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[cur] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            t.<span class="built_in">emplace_back</span>(candidates[cur]);</span><br><span class="line">            <span class="built_in">dfs</span>(cur, candidates, target - candidates[cur]);</span><br><span class="line">            t.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, candidates, target);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, candidates, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><h3 id="题干-19"><a href="#题干-19" class="headerlink" title="题干"></a>题干</h3><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[&quot;()&quot;]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h3 id="题解-19"><a href="#题解-19" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>因为要求是<strong>有效括号</strong>组合，因此在元素选择时要先选左括号，再选右括号；</p><p>左右括号的选择条件不同，<code>open</code>的上限是<code>n</code>，而<code>close</code>的上限是<code>open</code></p><p><strong>细节</strong></p><p>基于添加右括号的条件<code>close &lt; open</code>，达到递归终止条件时的t一定是有效括号组合</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backTrace</span><span class="params">(vector&lt;string&gt;&amp; ans, string&amp; t, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t.<span class="built_in">size</span>() == <span class="number">2</span> * n) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">            t += <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">            <span class="built_in">backTrace</span>(ans, t, open + <span class="number">1</span>, close, n);</span><br><span class="line">            t.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            t += <span class="string">&#x27;)&#x27;</span>;</span><br><span class="line">            <span class="built_in">backTrace</span>(ans, t, open, close + <span class="number">1</span>, n);</span><br><span class="line">            t.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        string t;</span><br><span class="line">        <span class="built_in">backTrace</span>(ans, t, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h2><h3 id="题干-20"><a href="#题干-20" class="headerlink" title="题干"></a>题干</h3><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n = board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 6</code></li><li><code>1 &lt;= word.length &lt;= 15</code></li><li><code>board</code> 和 <code>word</code> 仅由大小写英文字母组成</li></ul><h3 id="题解-20"><a href="#题解-20" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>查找字符串，从起点开始向上下左右四个方向进行搜索，同时每个点都应作为起点进行搜索；</li><li>搜索中，访问过的应当标记避免二次访问，搜索结束后还原；</li></ul><p><strong>细节</strong></p><p>终止条件包括<code>ans</code>已经为<code>true</code>，<code>cur == word.size()</code>即搜索完成，以及超出边界或者字符不匹配；</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> cur, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string&amp; word,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">bool</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ans)</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 终止条件：已经找到单词</span></span><br><span class="line">        <span class="keyword">if</span> (cur == word.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.<span class="built_in">size</span>() || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].<span class="built_in">size</span>() ||</span><br><span class="line">            board[i][j] != word[cur]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">char</span> temp = board[i][j];</span><br><span class="line">        board[i][j] = <span class="string">&#x27;#&#x27;</span>; <span class="comment">// 标记访问</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(i + <span class="number">1</span>, j, cur + <span class="number">1</span>, board, word, ans);</span><br><span class="line">        <span class="built_in">dfs</span>(i - <span class="number">1</span>, j, cur + <span class="number">1</span>, board, word, ans);</span><br><span class="line">        <span class="built_in">dfs</span>(i, j + <span class="number">1</span>, cur + <span class="number">1</span>, board, word, ans);</span><br><span class="line">        <span class="built_in">dfs</span>(i, j - <span class="number">1</span>, cur + <span class="number">1</span>, board, word, ans);</span><br><span class="line"></span><br><span class="line">        board[i][j] = temp; <span class="comment">// 恢复</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">        <span class="type">bool</span> ans = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> rows = board.<span class="built_in">size</span>(), cols = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == word[<span class="number">0</span>]) &#123;</span><br><span class="line">                    <span class="built_in">dfs</span>(i, j, <span class="number">0</span>, board, word, ans);</span><br><span class="line">                    <span class="keyword">if</span> (ans)</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h2><h3 id="题干-21"><a href="#题干-21" class="headerlink" title="题干"></a>题干</h3><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h3 id="题解-21"><a href="#题解-21" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>对于有序数组中的查找，不断迭代更新上限和下限直至查找完成或不再满足循环条件<code>l &lt;= r</code></p><p><strong>细节</strong></p><p>循环条件是<code>l &lt;= r</code></p><p><strong>代码</strong></p><ol><li>二分查找模板</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            cur = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[cur] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[cur] &gt; target) &#123;</span><br><span class="line">                r = cur - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = cur + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>递归做太多，下意识用递归写了一份</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">div</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[l + (r - l) / <span class="number">2</span>] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l + (r - l) / <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">div</span>(l, l + (r - l) / <span class="number">2</span> - <span class="number">1</span>, nums, target);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">div</span>(l + (r - l) / <span class="number">2</span> + <span class="number">1</span>, r, nums, target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">div</span>(<span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>, nums, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h2><h3 id="题干-22"><a href="#题干-22" class="headerlink" title="题干"></a>题干</h3><p>给你一个满足下述两条属性的 <code>m x n</code> 整数矩阵：</p><ul><li>每行中的整数从左到右按非严格递增顺序排列。</li><li>每行的第一个整数大于前一行的最后一个整数。</li></ul><p>给你一个整数 <code>target</code> ，如果 <code>target</code> 在矩阵中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/05/mat.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/mat2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 100</code></li><li><code>-104 &lt;= matrix[i][j], target &lt;= 104</code></li></ul><h3 id="题解-22"><a href="#题解-22" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>将一维有序数组更换为二维有序矩阵，只需要找到下标之间的对应关系即可转换为一维有序数组的查找</p><p><strong>细节</strong></p><p>无</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 将线性排列对应到矩阵下标即可</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = matrix.<span class="built_in">size</span>() * matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> i, j;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            i = l + (r - l) / <span class="number">2</span> / matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            j = l + (r - l) / <span class="number">2</span> % matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                r = l + (r - l) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><h3 id="题干-23"><a href="#题干-23" class="headerlink" title="题干"></a>题干</h3><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出：[3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [], target = 0</span><br><span class="line">输出：[-1,-1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 105</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-109 &lt;= target &lt;= 109</code></li></ul><h3 id="题解-23"><a href="#题解-23" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>在找到target数值时更新答案边界，并且设置为二分的新边界</p><p><strong>细节</strong></p><p>循环中不需要break跳出，因为找到target后需要设置新的边界并进行下一步迭代</p><p><strong>代码</strong></p><ol><li><code>logn</code>复杂度的解法，两次二分找到左边界和右边界</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> first = <span class="number">-1</span>, last = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                first = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span>;</span><br><span class="line">        r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                last = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(first);</span><br><span class="line">        ans.<span class="built_in">emplace_back</span>(last);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>非<code>logn</code>复杂度的解法，找到target之后向两侧拓展，测试用例没设置好估计，时长超过100%了…</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 查找到对应的target之后向两侧拓展更新答案即可</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l + (r - l) / <span class="number">2</span>] == target) &#123;</span><br><span class="line">                l = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[l + (r - l) / <span class="number">2</span>] &gt; target) &#123;</span><br><span class="line">                r = l + (r - l) / <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = l + (r - l) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">            <span class="comment">// 找到左边界</span></span><br><span class="line">            <span class="type">int</span> left = l;</span><br><span class="line">            <span class="keyword">while</span> (left &gt; <span class="number">0</span> &amp;&amp; nums[left - <span class="number">1</span>] == target) &#123;</span><br><span class="line">                --left;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(left);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到右边界</span></span><br><span class="line">            <span class="type">int</span> right = l;</span><br><span class="line">            <span class="keyword">while</span> (right &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; nums[right + <span class="number">1</span>] == target) &#123;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(right);</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; ans = &#123;<span class="number">-1</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><h3 id="题干-24"><a href="#题干-24" class="headerlink" title="题干"></a>题干</h3><p>整数数组 <code>nums</code> 按升序排列，数组中的值 <strong>互不相同</strong> 。</p><p>在传递给函数之前，<code>nums</code> 在预先未知的某个下标 <code>k</code>（<code>0 &lt;= k &lt; nums.length</code>）上进行了 <strong>旋转</strong>，使数组变为 <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 <strong>从 0 开始</strong> 计数）。例如， <code>[0,1,2,4,5,6,7]</code> 在下标 <code>3</code> 处经旋转后可能变为 <code>[4,5,6,7,0,1,2]</code> 。</p><p>给你 <strong>旋转后</strong> 的数组 <code>nums</code> 和一个整数 <code>target</code> ，如果 <code>nums</code> 中存在这个目标值 <code>target</code> ，则返回它的下标，否则返回 <code>-1</code> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 5000</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 中的每个值都 <strong>独一无二</strong></li><li>题目数据保证 <code>nums</code> 在预先未知的某个下标上进行了旋转</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h3 id="题解-24"><a href="#题解-24" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>数组局部有序，将数组分成两段意味着一定有一段是有序的，若target在有序数组中则二分查找；若不在则继续缩小范围</p><p><strong>细节</strong></p><ul><li>nums数量为0和1时可以单独考虑</li><li>判断数组是否有序时条件一使用<code>nums[mid] &gt;= nums[l]</code>而不是<code>nums[mid] &gt; nums[l]</code>，当数组大小为2时，可能会出现<code>mid == l</code>的情况，前半部分已经有序（只有一个数），但是没有被考虑进去。</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> n == target ? <span class="number">0</span> : <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= nums[l]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt;= target &amp;&amp; target &lt; nums[mid]) &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[r]) &#123;</span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><h3 id="题干-25"><a href="#题干-25" class="headerlink" title="题干"></a>题干</h3><p>已知一个长度为 <code>n</code> 的数组，预先按照升序排列，经由 <code>1</code> 到 <code>n</code> 次 <strong>旋转</strong> 后，得到输入数组。例如，原数组 <code>nums = [0,1,2,4,5,6,7]</code> 在变化后可能得到：</p><ul><li>若旋转 <code>4</code> 次，则可以得到 <code>[4,5,6,7,0,1,2]</code></li><li>若旋转 <code>7</code> 次，则可以得到 <code>[0,1,2,4,5,6,7]</code></li></ul><p>注意，数组 <code>[a[0], a[1], a[2], ..., a[n-1]]</code> <strong>旋转一次</strong> 的结果为数组 <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code> 。</p><p>给你一个元素值 <strong>互不相同</strong> 的数组 <code>nums</code> ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 <strong>最小元素</strong> 。</p><p>你必须设计一个时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,4,5,1,2]</span><br><span class="line">输出：1</span><br><span class="line">解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [4,5,6,7,0,1,2]</span><br><span class="line">输出：0</span><br><span class="line">解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [11,13,15,17]</span><br><span class="line">输出：11</span><br><span class="line">解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 5000</code></li><li><code>-5000 &lt;= nums[i] &lt;= 5000</code></li><li><code>nums</code> 中的所有整数 <strong>互不相同</strong></li><li><code>nums</code> 原来是一个升序排序的数组，并进行了 <code>1</code> 至 <code>n</code> 次旋转</li></ul><h3 id="题解-25"><a href="#题解-25" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>旋转数组若进行奇数次旋转则数组被分为两段，后半段的最大值小于前半段的最小值；</li><li>当中间值比当前<code>min</code>小时，说明中间值与当前<code>min</code>一定不在同一段，查找后半段即可；</li><li>当中间值大于<code>min</code>时，只需要搜索<code>mid+1</code>之后的序列即可；</li></ul><p><strong>细节</strong></p><p>使用<code>min = nums[mid];</code>来更新答案，这样更新右边界时就应该是<code>r = mid - 1;</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> mid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; min) &#123;</span><br><span class="line">                min = nums[mid];</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="316-去除重复字母"><a href="#316-去除重复字母" class="headerlink" title="316 去除重复字母"></a><a href="https://leetcode.cn/problems/remove-duplicate-letters/?envType=study-plan-v2&envId=2024-spring-sprint-100">316 去除重复字母</a></h2><h3 id="题干-26"><a href="#题干-26" class="headerlink" title="题干"></a>题干</h3><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的</strong></p><p><strong>字典序</strong></p><p><strong>最小</strong>（要求不能打乱其他字符的相对位置）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;cbacdcbc&quot;</span><br><span class="line">输出：&quot;acdb&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h3 id="题解-26"><a href="#题解-26" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>316与402是同一种题型，循环条件中删除k个数字变成对于栈顶字符剩余数目的考量，需要先建立一个map来映射各个字母的出现次数</p><p><strong>细节</strong></p><p>循环条件变为while (!res.empty() &amp;&amp; i &lt; res[res.size() - 1] &amp;&amp; m[res[res.size() - 1]] &gt; 0)，即栈不为空、栈顶字符剩余数目大于0、当前字符小于栈顶字符</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m.<span class="built_in">count</span>(c)) &#123;</span><br><span class="line">                m[c] += <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                m[c] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">find</span>(i) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!res.<span class="built_in">empty</span>() &amp;&amp; i &lt; res[res.<span class="built_in">size</span>() - <span class="number">1</span>] &amp;&amp;</span><br><span class="line">                       m[res[res.<span class="built_in">size</span>() - <span class="number">1</span>]] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    res.<span class="built_in">pop_back</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                res += i;</span><br><span class="line">            &#125;</span><br><span class="line">            m[i] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="321-拼接最大数"><a href="#321-拼接最大数" class="headerlink" title="321 拼接最大数"></a><a href="https://leetcode.cn/problems/create-maximum-number/">321 拼接最大数</a></h2><h3 id="题干-27"><a href="#题干-27" class="headerlink" title="题干"></a>题干</h3><p>给你两个整数数组 <code>nums1</code> 和 <code>nums2</code>，它们的长度分别为 <code>m</code> 和 <code>n</code>。数组 <code>nums1</code> 和 <code>nums2</code> 分别代表两个数各位上的数字。同时你也会得到一个整数 <code>k</code>。</p><p>请你利用这两个数组中的数字中创建一个长度为 <code>k &lt;= m + n</code> 的最大数，在这个必须保留来自同一数组的数字的相对顺序。</p><p>返回代表答案的长度为 <code>k</code> 的数组。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5</span><br><span class="line">输出：[9,8,6,5,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [6,7], nums2 = [6,0,4], k = 5</span><br><span class="line">输出：[6,7,6,0,4]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums1 = [3,9], nums2 = [8,9], k = 3</span><br><span class="line">输出：[9,8,9]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>1 &lt;= m, n &lt;= 500</code></li><li><code>0 &lt;= nums1[i], nums2[i] &lt;= 9</code></li><li><code>1 &lt;= k &lt;= m + n</code></li></ul><h3 id="题解-27"><a href="#题解-27" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>在完成了402与316后，这道题的思路很清晰，将问题转化为两个“移掉k位数字”，即在nums1中保留i位数字，nums2中保留k-i位数字（与移除类似），并且保障两个数组分别最大顺序，再通过归并算法的合并部分进行整合得到最终结果。看了其他人的题解，感觉Python的归并比Cpp简单好多，Cpp我努力过了还是写错了</p><p><strong>细节</strong></p><p>实现一个maxNumber函数针对单个数组排序，实现一个merge函数将两个数组进行相对位置不改变的最大排序。</p><p>merge的实现过程中当两个数组当前字符相等时，需要判断两个字符串后续的字典序，基于compare函数。</p><p>compare函数的实现思路是，比较a和b直至出现两个不相等或者a和b遍历完成，如果b遍历完成，则a的长度≥b的长度，a的后续字典序大于b；如果b没有遍历完，a遍历完成，则a的长度＜b的长度，a的后续字典序小于b；如果a和b都没有遍历结束但是出现了字符不相同的情况，返回当前字符的比较结果即可。</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, vector&lt;<span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>() || j &lt; b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; a.<span class="built_in">size</span>() &amp;&amp; (j &gt;= b.<span class="built_in">size</span>() || a[i] &gt; b[j] ||</span><br><span class="line">                                 (a[i] == b[j] &amp;&amp; <span class="built_in">compare</span>(a, i, b, j)))) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(a[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(b[j++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; a, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; b, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; a.<span class="built_in">size</span>() &amp;&amp; j &lt; b.<span class="built_in">size</span>() &amp;&amp; a[i] == b[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == b.<span class="built_in">size</span>() || (i &lt; a.<span class="built_in">size</span>() &amp;&amp; a[i] &gt; b[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (res.<span class="built_in">size</span>() != <span class="number">0</span> &amp;&amp; s[i] &gt; res[res.<span class="built_in">size</span>() - <span class="number">1</span>] &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                res.<span class="built_in">pop_back</span>();</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">max</span><span class="params">(k, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> len1 = i;</span><br><span class="line">            <span class="type">int</span> len2 = k - i;</span><br><span class="line">            <span class="keyword">if</span> (len1 &lt;= nums1.<span class="built_in">size</span>() &amp;&amp; len2 &lt;= nums2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len1 == <span class="number">0</span>) &#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; s2 = <span class="built_in">maxNumber</span>(nums2, nums2.<span class="built_in">size</span>() - len2);</span><br><span class="line">                    <span class="keyword">if</span> (s2 &gt; max) &#123;</span><br><span class="line">                        max = s2;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len2 == <span class="number">0</span>) &#123;</span><br><span class="line">                    vector&lt;<span class="type">int</span>&gt; s1 = <span class="built_in">maxNumber</span>(nums1, nums1.<span class="built_in">size</span>() - len1);</span><br><span class="line">                    <span class="keyword">if</span> (s1 &gt; max) &#123;</span><br><span class="line">                        max = s1;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; s1 = <span class="built_in">maxNumber</span>(nums1, nums1.<span class="built_in">size</span>() - len1);</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; s2 = <span class="built_in">maxNumber</span>(nums2, nums2.<span class="built_in">size</span>() - len2);</span><br><span class="line">                vector&lt;<span class="type">int</span>&gt; <span class="keyword">final</span> = <span class="built_in">merge</span>(s1, s2);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">final</span> &gt; max) &#123;</span><br><span class="line">                    max = <span class="keyword">final</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈*"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈*</a></h2><h3 id="题干-28"><a href="#题干-28" class="headerlink" title="题干"></a>题干</h3><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p><p>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素val推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]</span><br><span class="line">[[],[-2],[0],[-3],[],[],[],[]]</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line">[null,null,null,null,-3,null,0,-2]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.getMin();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.getMin();   --&gt; 返回 -2.</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>-231 &lt;= val &lt;= 231 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 <strong>非空栈</strong> 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, and <code>getMin</code>最多被调用 <code>3 * 104</code> 次</li></ul><h3 id="题解-28"><a href="#题解-28" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>没想出什么好方法，想用<code>stack</code>来实现<code>MinStack</code>，一看题解还真是…</li><li>栈后进先出的性质可以理解为展示最新的，因此一个正常栈用于存储数据，另一个栈陪跑记录最新的最小值</li></ul><p><strong>细节</strong></p><p>在<code>push</code>时陪跑栈的<code>top</code>值取出来与当前值对比，选择压入陪跑栈新的值或者继续压入<code>top</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; minStack;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123; minStack.<span class="built_in">push</span>(INT_MAX); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (val &lt; minStack.<span class="built_in">top</span>())</span><br><span class="line">            minStack.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            minStack.<span class="built_in">push</span>(minStack.<span class="built_in">top</span>());    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        minStack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> s.<span class="built_in">top</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> minStack.<span class="built_in">top</span>(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><h3 id="题干-29"><a href="#题干-29" class="headerlink" title="题干"></a>题干</h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><p>编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。</p><p>此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a]2[bc]&quot;</span><br><span class="line">输出：&quot;aaabcbc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;3[a2[c]]&quot;</span><br><span class="line">输出：&quot;accaccacc&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;2[abc]3[cd]ef&quot;</span><br><span class="line">输出：&quot;abcabccdcdcdef&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：s = &quot;abc3[cd]xyz&quot;</span><br><span class="line">输出：&quot;abccdcdcdxyz&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 30</code></li><li><code>s</code> 由小写英文字母、数字和方括号 <code>&#39;[]&#39;</code> 组成</li><li><code>s</code> 保证是一个 <strong>有效</strong> 的输入。</li><li><code>s</code> 中所有整数的取值范围为 <code>[1, 300]</code></li></ul><h3 id="题解-29"><a href="#题解-29" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li><strong>思路一</strong><ul><li>基本思路是识别字符序列，识别数字并重复；</li><li>考虑到括号嵌套，可以使用栈来处理，入栈直至遇到右括号，弹栈至左括号获取字符串，弹栈至栈空或者不为数字取出重复次数；</li><li>重复完当前字符串后压栈，可以有效解决嵌套；</li></ul></li><li>思路二<ul><li>字符和数字分开处理；</li><li>非括号元素时更新<code>currentString</code>和<code>currentNum</code>，基于规则可以得知没有括号的情况下不可能出现两个<code>currentString</code>或者<code>currentNum</code>；</li><li>遇到左括号时，即遇到新的一层，将当前字符串和数字压入栈；</li><li>遇到右括号时，即当前层结束，从栈中弹出数字，重复当前字符串，再从字符串栈中弹出前缀并拼接（若无前缀则与空串拼接）</li></ul></li></ul><p><strong>细节</strong></p><ul><li>可以使用<code>isdigit()</code>函数判断字符是否为数字;</li><li>进行字符串数字的处理方式见代码1；</li></ul><p><strong>代码</strong></p><ol><li>数字栈和字符串两个栈，代码更简洁</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;string&gt; charStack; <span class="comment">// 存储字符串片段</span></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; numStack;     <span class="comment">// 存储数字</span></span><br><span class="line">        string currentString;    <span class="comment">// 当前处理的字符串</span></span><br><span class="line">        <span class="type">int</span> currentNum = <span class="number">0</span>;      <span class="comment">// 当前处理的数字</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                <span class="comment">// 处理多位数</span></span><br><span class="line">                currentNum = currentNum * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 将当前字符串和数字压入栈中，并重置</span></span><br><span class="line">                charStack.<span class="built_in">push</span>(currentString);</span><br><span class="line">                numStack.<span class="built_in">push</span>(currentNum);</span><br><span class="line">                currentString = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                currentNum = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 弹出数字和字符串，重复当前字符串并拼接</span></span><br><span class="line">                <span class="type">int</span> repeatTimes = numStack.<span class="built_in">top</span>();</span><br><span class="line">                numStack.<span class="built_in">pop</span>();</span><br><span class="line">                string prevString = charStack.<span class="built_in">top</span>();</span><br><span class="line">                charStack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 使用 string 构造函数生成重复字符串</span></span><br><span class="line">                string repeatedString;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; repeatTimes; ++i) &#123;</span><br><span class="line">    repeatedString += currentString;</span><br><span class="line">&#125;</span><br><span class="line">                currentString = prevString + repeatedString;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通字符，直接添加到当前字符串</span></span><br><span class="line">                currentString += c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> currentString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>自己写的，一个栈，思路如上所述</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; decodeStack;</span><br><span class="line">        string ans;</span><br><span class="line">        string temp;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">int</span> digit;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                temp.<span class="built_in">clear</span>();</span><br><span class="line">                n = <span class="number">0</span>;</span><br><span class="line">                digit = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 弹栈直至遇到 &#x27;[&#x27;</span></span><br><span class="line">                <span class="keyword">while</span> (decodeStack.<span class="built_in">top</span>() != <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                    temp = decodeStack.<span class="built_in">top</span>() + temp;</span><br><span class="line">                    decodeStack.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 弹出&#x27;[&#x27;</span></span><br><span class="line">                decodeStack.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// 循环次数，空栈则不需要压栈，否则压栈</span></span><br><span class="line">                <span class="keyword">while</span> (!decodeStack.<span class="built_in">empty</span>() &amp;&amp; decodeStack.<span class="built_in">top</span>() &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp;</span><br><span class="line">                       decodeStack.<span class="built_in">top</span>() &gt;= <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    <span class="keyword">switch</span> (digit) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                        n += decodeStack.<span class="built_in">top</span>() - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                        n += (decodeStack.<span class="built_in">top</span>() - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                        n += (decodeStack.<span class="built_in">top</span>() - <span class="string">&#x27;0&#x27;</span>) * <span class="number">100</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    decodeStack.<span class="built_in">pop</span>();</span><br><span class="line">                    ++digit;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 返回答案</span></span><br><span class="line">                <span class="keyword">if</span> (decodeStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                        ans += temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 循环temp,压栈</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    string copy = temp;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">                        temp += copy;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> tempChar : temp) &#123;</span><br><span class="line">                        decodeStack.<span class="built_in">push</span>(tempChar);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                decodeStack.<span class="built_in">push</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">while</span>(!decodeStack.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            temp = decodeStack.<span class="built_in">top</span>() + temp;</span><br><span class="line">            decodeStack.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        ans += temp;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><h3 id="题干-30"><a href="#题干-30" class="headerlink" title="题干"></a>题干</h3><p>给定一个整数数组 <code>temperatures</code> ，表示每天的温度，返回一个数组 <code>answer</code> ，其中 <code>answer[i]</code> 是指对于第 <code>i</code> 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 <code>0</code> 来代替。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [73,74,75,71,69,72,76,73]</span><br><span class="line">输出: [1,1,4,2,1,1,0,0]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,40,50,60]</span><br><span class="line">输出: [1,1,1,0]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: temperatures = [30,60,90]</span><br><span class="line">输出: [1,1,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= temperatures.length &lt;= 105</code></li><li><code>30 &lt;= temperatures[i] &lt;= 100</code></li></ul><h3 id="题解-30"><a href="#题解-30" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>建立单调递减栈，当遇到更高的气温时，会一路弹栈并更新之前的答案，契合要求；</li><li>遍历数组进行入栈，可以保证当前元素大于栈顶元素时一定是<strong>第一个大于栈顶元素值的元素</strong>。</li></ul><p><strong>细节</strong></p><p>栈仅用于存储下标，数值比较只需要取出下标基于<code>temperatures</code>数组进行比较，同时在更新距离时下标之差正好是距离</p><p><strong>代码</strong></p><ol><li>暴力，超时</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(temperatures.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;temperatures.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=i; j&lt;temperatures.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span>(temperatures[j] &gt; temperatures[i]) &#123;</span><br><span class="line">                    ans[i] = j - i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>单调（递减）栈</li></ol><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(temperatures.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[s.<span class="built_in">top</span>()] &lt; temperatures[i]) &#123;</span><br><span class="line">                ans[s.<span class="built_in">top</span>()] = i - s.<span class="built_in">top</span>();</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形*"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形*</a></h2><h3 id="题干-31"><a href="#题干-31" class="headerlink" title="题干"></a>题干</h3><p>给定 <em>n</em> 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：heights = [2,1,5,6,2,3]</span><br><span class="line">输出：10</span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 10</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入： heights = [2,4]</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= heights.length &lt;=105</code></li><li><code>0 &lt;= heights[i] &lt;= 104</code></li></ul><h3 id="题解-31"><a href="#题解-31" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>每日温度的变体，每日温度是寻找第一个<strong>“大于”</strong>，最大矩形是寻找第一个<strong>“小于”</strong>；</p><p><strong>细节</strong></p><p>更新右边界应该正向循环，更新左边界应该逆向循环，可以保障弹栈更新时一定是第一个<strong>“小于”</strong>自身值的元素；</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; leftStack;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; rightStack;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(heights.size(), <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">r</span><span class="params">(heights.size(), heights.size())</span></span>;</span><br><span class="line">        <span class="comment">// 正向遍历更新右边界，构建单调递增栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 当前元素小于栈顶时，弹栈更新对应位置的右边界</span></span><br><span class="line">            <span class="keyword">while</span> (!rightStack.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                   heights[i] &lt; heights[rightStack.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                r[rightStack.<span class="built_in">top</span>()] = i;</span><br><span class="line">                rightStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            rightStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反向遍历更新左边界，构建单调递增栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = heights.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="comment">// 当前元素小于栈顶时，弹栈更新对应位置的左边界</span></span><br><span class="line">            <span class="keyword">while</span> (!leftStack.<span class="built_in">empty</span>() &amp;&amp;</span><br><span class="line">                   heights[i] &lt; heights[leftStack.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                l[leftStack.<span class="built_in">top</span>()] = i;</span><br><span class="line">                leftStack.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            leftStack.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; heights.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, heights[i] * (r[i] - l[i] - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><h3 id="题干-32"><a href="#题干-32" class="headerlink" title="题干"></a>题干</h3><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例 1：</strong></p><p><strong>输入：</strong>s &#x3D; “()”</p><p><strong>输出：</strong>true</p><p><strong>示例 2：</strong></p><p><strong>输入：</strong>s &#x3D; “()[]{}”</p><p><strong>输出：</strong>true</p><p><strong>示例 3：</strong></p><p><strong>输入：</strong>s &#x3D; “(]”</p><p><strong>输出：</strong>false</p><p><strong>示例 4：</strong></p><p><strong>输入：</strong>s &#x3D; “([])”</p><p><strong>输出：</strong>true</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h3 id="题解-32"><a href="#题解-32" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>左括号入栈，右括号对比弹栈</p><p><strong>细节</strong></p><p>可能会出现全是左括号的情况，或者全是右括号的情况，因此需要使用<code>open.empty()</code>来解决这两种情况</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; open;</span><br><span class="line">        <span class="type">char</span> cur;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">                open.<span class="built_in">push</span>(c); <span class="comment">// 左括号入栈</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果栈为空，说明没有匹配的左括号</span></span><br><span class="line">                <span class="keyword">if</span> (open.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = open.<span class="built_in">top</span>(); <span class="comment">// 获取栈顶元素</span></span><br><span class="line">                <span class="comment">// 检查括号是否匹配</span></span><br><span class="line">                <span class="keyword">if</span> ((c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; cur != <span class="string">&#x27;(&#x27;</span>) || (c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; cur != <span class="string">&#x27;[&#x27;</span>) ||</span><br><span class="line">                    (c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; cur != <span class="string">&#x27;&#123;&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                open.<span class="built_in">pop</span>(); <span class="comment">// 弹出栈顶元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果栈为空，说明所有括号都匹配</span></span><br><span class="line">        <span class="keyword">return</span> open.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215 数组中的第K个最大元素</a></h2><h3 id="题干-33"><a href="#题干-33" class="headerlink" title="题干"></a>题干</h3><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>**k**</code> 个最大的元素。</p><p>请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4], k = 2</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: [3,2,3,1,2,4,5,5,6], k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li></ul><h3 id="题解-33"><a href="#题解-33" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>快速排序的思想，直到确认的元素位置在<code>target</code>则表示它是第k大的数，同时根据等比数列它的平均时间是<code>O(N)</code></p><p><code>partition</code>返回随机哨兵最终的下标，根据该下标更新左边界和右边界</p><p><code>partition</code>函数采用双路快排，可以保证在出现大量与哨兵相等的元素时返回下标也在中间的位置，避免出现$N^2$的情况</p><p><strong>细节</strong></p><p><code>partition</code>函数哨兵设置选取随机下标执行效率会更高</p><p><code>partition</code>函数的循环跳出条件是<code>le &gt;= ge</code>，最终返回下标是<code>ge</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left], nums[left + <span class="built_in">rand</span>() % (right - left + <span class="number">1</span>)]);</span><br><span class="line">        <span class="type">int</span> le = left + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ge = right;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (le &lt;= ge &amp;&amp; nums[le] &lt; nums[left])</span><br><span class="line">                ++le;</span><br><span class="line">            <span class="keyword">while</span> (le &lt;= ge &amp;&amp; nums[ge] &gt; nums[left])</span><br><span class="line">                --ge;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (le &gt;= ge)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="built_in">swap</span>(nums[le], nums[ge]);</span><br><span class="line">            ++le;</span><br><span class="line">            --ge;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[left], nums[ge]);</span><br><span class="line">        <span class="keyword">return</span> ge;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> target = n - k;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> pivot = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            pivot = <span class="built_in">partition</span>(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (pivot == target)</span><br><span class="line">                <span class="keyword">return</span> nums[target];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pivot &gt; target)</span><br><span class="line">                right = pivot - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = pivot + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><h3 id="题干-34"><a href="#题干-34" class="headerlink" title="题干"></a>题干</h3><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1,1,1,2,2,3], k = 2</span><br><span class="line">输出: [1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [1], k = 1</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><p><strong>进阶：</strong>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><h3 id="题解-34"><a href="#题解-34" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>构建哈希表统计词频，排序哈希表的<code>value</code>取出前k个即可</p><p><strong>细节</strong></p><ul><li>注意优先队列的STL模板以及使用方法</li><li>使用大顶堆则不需要对堆元素进行删除，但是最终维护堆的成本较高；使用小顶堆可以一直将堆的大小控制在k</li></ul><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 推排序比较方式</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; a, pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 小顶堆</span></span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 统计频率创建一个哈希表</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hashMap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            ++hashMap[num];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对哈希表进行排序，取出前k个元素的key</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; pair : hashMap) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() == k) &#123;</span><br><span class="line">                <span class="keyword">if</span> (q.<span class="built_in">top</span>().second &lt; pair.second) &#123;</span><br><span class="line">                    q.<span class="built_in">pop</span>();</span><br><span class="line">                    q.<span class="built_in">emplace</span>(pair);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                q.<span class="built_in">emplace</span>(pair);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; ++i) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h1><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><h3 id="题干-35"><a href="#题干-35" class="headerlink" title="题干"></a>题干</h3><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：[7,1,5,3,6,4]</span><br><span class="line">输出：5</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 105</code></li><li><code>0 &lt;= prices[i] &lt;= 104</code></li></ul><h3 id="题解-35"><a href="#题解-35" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>动态维护最小值，非最小值时尝试更新答案，<code>O(n)</code>时间内可以完成利润计算</p><p><strong>细节</strong></p><p><code>prices</code>本身是按照时间顺序递进的，因此正向遍历时动态更新最小值符合时间顺序</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> min = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; min) &#123;</span><br><span class="line">                min = prices[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, prices[i] - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2><h3 id="题干-36"><a href="#题干-36" class="headerlink" title="题干"></a>题干</h3><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [2,3,1,1,4]</span><br><span class="line">输出：true</span><br><span class="line">解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：nums = [3,2,1,0,4]</span><br><span class="line">输出：false</span><br><span class="line">解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h3 id="题解-36"><a href="#题解-36" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><p>根据题干，每个元素代表<strong>可以</strong>跳跃的最大长度；</p><p>依次遍历每个位置并且实时更新可以到达的最大长度，如果元素代表跳跃距离就无法贪心；</p><p><strong>细节</strong></p><p><code>reach</code>可以初始化为<code>nums[0]</code></p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> reach = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; reach)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            reach = <span class="built_in">max</span>(reach, i + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reach &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2><h3 id="题干-37"><a href="#题干-37" class="headerlink" title="题干"></a>题干</h3><p>给定一个长度为 <code>n</code> 的 <strong>0 索引</strong>整数数组 <code>nums</code>。初始位置为 <code>nums[0]</code>。</p><p>每个元素 <code>nums[i]</code> 表示从索引 <code>i</code> 向后跳转的最大长度。换句话说，如果你在 <code>nums[i]</code> 处，你可以跳转到任意 <code>nums[i + j]</code> 处:</p><ul><li><code>0 &lt;= j &lt;= nums[i]</code> </li><li><code>i + j &lt; n</code></li></ul><p>返回到达 <code>nums[n - 1]</code> 的最小跳跃次数。生成的测试用例可以到达 <code>nums[n - 1]</code>。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,1,1,4]</span><br><span class="line">输出: 2</span><br><span class="line">解释: 跳到最后一个位置的最小跳跃数是 2。</span><br><span class="line">     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: nums = [2,3,0,1,4]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 1000</code></li><li>题目保证可以到达 <code>nums[n-1]</code></li></ul><h3 id="题解-37"><a href="#题解-37" class="headerlink" title="题解"></a>题解</h3><p><strong>思路</strong></p><ul><li>根据当前位置<code>cur</code>以及当前可跳距离<code>nums[cur]</code>可以得到当前可达位置范围，同时根据可达位置范围以及<code>nums</code>数组就可以知道哪一个可达位置能让你下一步的可达范围最大化。</li><li>听起来似乎有点绕，仔细阅读可以理解，跳跃是区间范围选择的，因此每次选择最远范围的即可，因为它的区间一定能覆盖其他选择，不理解的时候可以画图（借用一下官图）</li><li><img src="https://assets.leetcode.cn/solution-static/45/45_fig1.png" alt="fig1"></li></ul><p><strong>细节</strong></p><p><code>cur</code>不需要遍历到<code>nums.size() - 1</code>，避免重复计算跳跃次数</p><p><strong>代码</strong></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当前位置</span></span><br><span class="line">        <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 能达到的范围</span></span><br><span class="line">        <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最远</span></span><br><span class="line">        <span class="type">int</span> maxPos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (cur &lt; nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算能达到的范围</span></span><br><span class="line">            next = cur + nums[cur];</span><br><span class="line">            <span class="comment">// 达到则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (next &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">                ++ans;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最远的位置必然大于cur</span></span><br><span class="line">            maxPos = cur;</span><br><span class="line">            <span class="comment">// 当前位置到能达到的范围遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = cur + <span class="number">1</span>; i &lt;= next &amp;&amp; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="comment">// 最远的选择为落点</span></span><br><span class="line">                <span class="keyword">if</span> (i + nums[i] &gt; maxPos) &#123;</span><br><span class="line">                    <span class="comment">// 更新最远范围</span></span><br><span class="line">                    maxPos = i + nums[i];</span><br><span class="line">                    <span class="comment">// 更新落点选择</span></span><br><span class="line">                    cur = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 跳一次</span></span><br><span class="line">            ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C#常见概念与常用语法</title>
      <link href="/2024/06/06/439ed6e98726/"/>
      <url>/2024/06/06/439ed6e98726/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于C#的常见概念与常用语法。</p><h1 id="C-脚本生命周期"><a href="#C-脚本生命周期" class="headerlink" title="C#脚本生命周期"></a>C#脚本生命周期</h1><ul><li>Awake：初始化。</li><li>Enable：渲染启用时调用，初始化方法不能写在里面。</li><li>Start：第一次Enable后调用。</li><li>Update：每一帧调用一次。</li><li>LateUpdate：update执行完lateupdate就会执行。</li><li>FixedUpdate：类似定时器，定期执行，与机器性能帧数无关，仅和时间有关。默认0.02s。</li><li>UnDisable：非激活状态调用。</li><li>OnDestroy：销毁时调用。</li></ul><h1 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h1><ul><li><p>上一帧到下一帧的游戏时间Time.deltaTime。</p></li><li><p>时间缩放值Time.timeScale。</p></li></ul><h1 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h1><ul><li><p>游戏数据文件夹路径（只读，加密压缩）Applicants.dataPath。</p></li><li><p>持久化文件夹路径（可写）Applicants.persistentDataPath。</p></li><li><p>StreamingAssets文件夹路径（只读，不加密）Application.streamingAssetsPath。</p></li><li><p>临时文件夹Application.temporaryCachePath。</p></li><li><p>后台运行Application.runInBackground。</p></li><li><p>打开url Application.OpenURL。</p></li><li><p>退出游戏Application.Quit()。</p></li></ul><h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><ul><li><p>SceneManager.CreateScene()创建场景。</p></li><li><p>SceneManager.LoadScene(“场景名称（编号）”)加载场景；LoadSceneMode参数设置为Single时只加载当前场景，设置为Additive时叠加场景。</p></li><li><p>SceneManager.LoadSceneAsync()异步加载场景，当场景很大时加载速度较慢。</p></li><li><p>SceneManager.UnloadSceneAsync()卸载场景。</p></li><li><p>SceneManager.GetActiveScene()获取当前场景。</p></li><li><p>Scene.GetRootGameObjects()获取场景中的所有游戏物体。</p></li></ul><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><ul><li><p>AsyncOperation作为异步加载场景SceneManager.LoadSceneAsync()的返回值，使用yield return返回一个协程IEnumerator，并使用StartCoroutine启动协程。</p></li><li><p>operation.progress可以查看加载进度，在UI制作时可以做进度条。</p></li><li><p>operation.allowSceneActivation可以控制场景是否跳转，设置为False不会自动跳转。</p></li></ul><h1 id="Transform"><a href="#Transform" class="headerlink" title="Transform"></a>Transform</h1><ul><li><p>transform.position是世界坐标系里的位置。</p></li><li><p>transform.localPosition是相对父物体的位置。</p></li><li><p>transform.LookAt(点坐标)看向某个点。</p></li><li><p>transform.Rotate(轴, 旋转度数)；transform.RotateAround(点，轴，旋转度数)。</p></li><li><p>transform.Translate()移动。</p></li><li><p>transform.parent.gameObject获取父物体。</p></li><li><p>transform.DetachChildren()解除所有子物体。</p></li><li><p>transform.GetChild(0)根据下标获取子物体；transform.Find(“子物体名称”)根据名称获得子物体。</p></li><li><p>SetParent()设置父物体。</p></li></ul><h1 id="键鼠操作"><a href="#键鼠操作" class="headerlink" title="键鼠操作"></a>键鼠操作</h1><ul><li><p>input.GetMouseButtonDown()按下鼠标；input.GetKeyDown(KeyCode)按下键盘。</p></li><li><p>input.GetMouseButton()按住鼠标；input.GetKey(KeyCode)按住键盘。</p></li><li><p>input.GetMouseButtonUP()松开鼠标；input.GetKeyUp(KeyCode)松开键盘。</p></li></ul><h1 id="触摸操作"><a href="#触摸操作" class="headerlink" title="触摸操作"></a>触摸操作</h1><p>判断触摸点数目使用Input.touchCount。判断触摸阶段，类似键鼠操作中的抬起按下，基于touch.phase。</p><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Input.touchCount == <span class="number">1</span>) &#123;</span><br><span class="line">    Touch touch = Input.touches[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">switch</span>(touch.phase) &#123;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Began:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Moved:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Stationary:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Ended:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> TouchPhase.Cancled:</span><br><span class="line">            <span class="keyword">break</span>;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  开启多点触摸</span></span><br><span class="line">Input.multiTouchEnabled = True;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(Input.touchCount == <span class="number">2</span>) &#123;</span><br><span class="line">    Touch touch0 = Input.touches[<span class="number">0</span>];</span><br><span class="line">    Touch touch1 = Input.touches[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="虚拟轴"><a href="#虚拟轴" class="headerlink" title="虚拟轴"></a>虚拟轴</h1><ul><li><p>Input.GetAxis(“Horizontal”)表示水平虚拟轴，由ad或者左右控制，或者摇杆。</p></li><li><p>Input.GetAxis(“Vertical”)表示垂直虚拟轴，由ws或者前后控制，或者摇杆。</p></li><li><p>CharacterController.SimpleMove(向量)会朝着向量方向移动，向量dir设置为Vector3(horizontal, 0, vertical)，可以完成简单角色方向控制。</p></li></ul><h1 id="碰撞检测"><a href="#碰撞检测" class="headerlink" title="碰撞检测"></a>碰撞检测</h1><ul><li><p>OnCollisionEnter监听发生碰撞；OnCollisionStay监听碰撞持续中；OnCollisionExit监听碰撞结束。</p></li><li><p>Collision类里包含了碰撞的信息，可以用于查看碰撞物体名称等。</p></li></ul><h1 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h1><ul><li><p>OnTriggerEnter监听触发发生；OnCollisionStay监听触发持续中；OnCollisionExit监听触发结束。</p></li><li><p>勾选是触发器选项后，不一样的地方在于，它不受物理影响，可以直接穿透而不会有碰撞体积，但同时可以检测到碰撞。</p></li></ul><hr><p>2024.8.29</p><p>很久没写，我决定重启我的blog，最近基本都在使用Unity和编写C#脚本，然后就是用Python搭模型调参数…</p>]]></content>
      
      
      <categories>
          
          <category> C# </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unity </tag>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DWA path planning algorithm</title>
      <link href="/2023/11/21/bcabc54fc9a6/"/>
      <url>/2023/11/21/bcabc54fc9a6/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了关于动态窗口算法(Dynamic Window Approaches, DWA)的一些基本概念与算法步骤。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>动态窗口算法(Dynamic Window Approaches, DWA)，核心思想是根据无人设备当前的位置状态和速度状态在速度空间 (v,ω) 中确定一个满足无人设备硬件约束的采样速度空间，然后计算无人设备在这些速度情况下移动一定时间内的轨迹，并通过评价函数对该轨迹进行评价，最后选出评价最优的轨迹所对应的速度作为无人设备运动速度，如此循环直至移动无人设备到达目标点。</p><p>系统设计过程中对动态窗口算法的实现主要从三个方面出发，速度采样、轨迹预测、轨迹评价。</p><h1 id="速度采样"><a href="#速度采样" class="headerlink" title="速度采样"></a>速度采样</h1><p>现实中不同型号的无人设备所具有的硬件和结构不同，在物理层面上存在一定的限制，例如马力和重量会导致其最大加速度和最大转向加速度受到限制，反映在运动上的限制是运行速度的改变和方向变换的及时性。</p><p>在系统的仿真模拟中，不同模型的无人船也会设置不同的加速度参数，动态窗口算法的速度采样空间<strong>V</strong>s会收到约束。</p><p>速度范围约束：由于真实环境中阻力等物理因素的存在，针对无人船进行建模时根据它的型号对线速度和角速度范围进行了限制，v∈[vmin ,vmax ]，ω∈[ωmin ,ωmax ]。在此条件下可采样的速度空间Vm的限定范围：</p>$${V}_m=\lbrace(v,ω)∣v∈[v_{min} ,v_{max} ],ω∈[ω_{min} ,ω_{max} ]\rbrace$$<p>加速度约束：针对某一时间点，忽略加速度变化所需时间，线加速度和角加速度的范围被约束在av∈[-avmax ,avmax]，aω∈[-aωmax ,aωmax]，假定vc、ωc 分别为无人船当前时刻的线速度和角速度，在极短的时间Δt内，可采样的速度空间<strong>V</strong>d也被限定：</p>$${V}_d=\lbrace(v,ω)∣v∈[v_c−a_{vmax}⋅Δt,v_c+a_{vmax}·Δt], ω∈[ω_c−a_{ωmax}·Δt,ω_c+a_{ωmax}·Δt]\rbrace$$<p>障碍物安全距离约束：当无人船与障碍物之间的距离缩小到达一定程度时，此时即使采用最大加速度进行减速，也无法避免的发生碰撞，基于此对速度采样空间也进行了限制：</p>$${V}_a=\lbrace(v,ω)∣v∈[v_{min} ,2·dist·a_{vmax} ],ω∈[ω_{min} ,2·dist·a_{ωmax} ]\rbrace$$<p>其中，dist表示当前无人设备的位置与障碍物的最近距离。综合以上三个速度空间的限制，通过取交集获取最终的速度采样空间，即：</p>$$V_s=V_m∩V_d∩V_a$$<h1 id="轨迹预测"><a href="#轨迹预测" class="headerlink" title="轨迹预测"></a>轨迹预测</h1><p>在完成了速度采样空间<strong>V</strong>s的确认之后，根据动态窗口算法设置的采样率来对采样空间进行拆分组合。分别用<strong>Ev</strong>和<strong>Ew</strong>表示表示线速度和角速度的采样频率，即每间隔<strong>Ev</strong>进行一次速度采样，根据排列组合能够组成的线速度与角速度组数：</p>$$n=[(v_{high}−v_{low})/E_v]⋅[(w_{high}−w_{low})/E_w]$$<p>每一组(v,ω)按照设置的无人船运动模型，计算其在设置的预测时间内运动轨迹并保存，系统采用的运动模型是差分驱动模型：</p>$$\left\{\begin{aligned}x_k & = x_{k−1}+v⋅\cos(θ_{k−1})Δt \\y_k & = y_{k−1}+v⋅\sin(θ_{k−1})Δt \\θ_k & = θ_{k-1}+ωΔt\end{aligned}\right.$$<p>其中，(x,y,θ)代表无人船的位置状态，k代表采样时刻，Δt代表采样间隔。</p><h1 id="轨迹评价"><a href="#轨迹评价" class="headerlink" title="轨迹评价"></a>轨迹评价</h1><p>经过轨迹预测后得到的n组轨迹，需要经过评价函数来选择最优的轨迹作为无人船接下来的运动轨迹。轨迹评价考虑三个方面：方位角评价，评估轨迹末端位置方向与目标点连线的夹角误差，引导无人船朝向目标；距离评价，计算当前速度下轨迹与障碍物之间的最近距离，避免无人船与障碍物发生碰撞；速度评价，表示当前的速度大小，鼓励无人船保持较高的速度以提高导航效率。</p><p>评价函数量化表现为：</p>$$G(v,ω)=σ(α⋅heading(v,ω)) + σ(β⋅dist(v,ω)) + σ(γ⋅velocity(v,ω))$$<p>其中，heading(v, ω)是方位角的评价函数，轨迹终点方向与目标终点的夹角为Δθ，用heading(v, ω) &#x3D; π – Δθ作为方位角的评价函数，则夹角越小评分越高。dist(v,ω)是距离的评价函数，表示当前状态下无人船与障碍物的最小距离，距离越远越安全，评分越高。velocity(v,ω)是速度评价函数，直接用当前线速度大小作为函数值，在当前方向上的速度越快意味着轨迹越优。</p><p>α、β 、γ均为评价函数的系数，当我们对哪一部分的评分更加看重时可以通过调节评价系数来调整对轨迹的选择。σ则是对评价函数的归一化处理：</p>$$\left\{\begin{aligned}σ⋅ heading(v,ω) &=normalize\_heading(i)= \frac{heading(i)}{\sum_{i=1}^nheading(i)}  \\σ⋅dist(v,ω) &= normalize\_dist (i)= \frac{dist (i)}{\sum_{i=1}^ndist (i)} \\σ⋅velocity(v,ω) &= normalize\_velocity (i)= \frac{velocity (i)}{\sum_{i=1}^nvelocity (i)}\end{aligned}\right.$$<p>其中，n是采样速度空间的组合数目即轨迹数目。</p><p>经过速度采样、轨迹预测、轨迹评价后，得到当前无人船的运动仿真轨迹，如下图所示:</p><p><img src="https://s2.loli.net/2024/08/29/TevJR5LUgKdczEO.gif" alt="image13.gif"></p><p>图中蓝色曲线是通过评价函数选定的最优（仅针对动态窗口算法的评价标准）路径，绿色区域是由n条待评价轨迹组合成的，表示无人船可能的轨迹。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 无人船仿真系统 </category>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A* path planning algorithm</title>
      <link href="/2023/11/21/4f6190916ab7/"/>
      <url>/2023/11/21/4f6190916ab7/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了关于A*路径规划算法的一些基本概念与算法步骤。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>G：起点A到网格中的指定点所花费的代价</p><p>H：指定点到终点所花费的代价</p><p>F：F &#x3D; G + H，起点到终点经过指定点的总代价</p><p>open_list：用来寻找最短的路径的中间点</p><p>closed_list：不会被考虑的点</p><p>结束条件：1. 终点出现在open_list；2. open_list为空</p><h1 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h1><ol><li>从起点S开始，把S作为一个等待检查的方格，放入到open_list中</li><li>寻找起点S周围可以到达的方格(最多八个) ，将它们放入到open_list，并设置它们的父方格为S</li><li>从open_list中删除起点S，并将放入到closed_list中(closed_list存放的是不再需要检查的方格)</li><li>计算每个周围方格的F值</li><li>从open_list中选择F值最低的方格，将它从open_list中移除，并且把它可达的方格（障碍和closed_list中的方格舍弃）加入到open_list</li><li>如果可达方格不在open_list中，则父方格设置为当前方格；如果可达方格已经在open_list中，已当前方格为中间点得到的G值比原来的更小，则更新父节点为当前节点，F &#x3D; G’ + H，否则不变</li><li>循环从open_list中找F值最小的点来更新，直到结束条件</li></ol><h1 id="算法示例"><a href="#算法示例" class="headerlink" title="算法示例"></a>算法示例</h1><p>关于最终代价的计算，首先需要将地图进行网格化如图所示，每个方格视作为一个节点，蓝色方格是障碍物，白色方格是可通过区域，绿色方格是起点，红色方格是终点。</p><p>​    <img src="https://s2.loli.net/2024/08/29/yaJpxu1tvNFEQjD.png#pic_center" alt="素材1.png">                           </p><p>其次需要添加一些约束，针对一个节点，可以选择朝其周围的8个方向移动一个方格，其中朝上、下、左、右移动的成本为 10，朝左上、右上、左下、右下移动的成本为 14（10√2 近似值），蓝色区域也就是障碍物区域表示不可移动。</p><p>实际代价的计算可以由待检查节点向八个方向出发并计算代价，而预计代价的计算则只考虑横纵向的移动，然后把总数乘以 10，通过实际代价与预计代价的叠加来进行启发，如下图的A*算法代价计算示例。<br><img src="https://s2.loli.net/2024/08/29/5vp8xhZaCeODyob.png#pic_center" alt="素材2.png"></p><p>每个方格都标上了综合代价，实际代价，预计代价的值，方格左上角表示综合代价，左下角即从起点到当前节点的实际代价，右下角即由当前节点到终点的预计代价 。最终通过A*算法得到的路径代价计算值为68，按照下图中的方式进行回溯得到路径。</p><p> <img src="https://s2.loli.net/2024/08/29/vc4kDKmgu187wYp.png#pic_center" alt="素材3.png"></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 无人船仿真系统 </category>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见船舶局部路径规划算法</title>
      <link href="/2023/11/20/b6efb589d40f/"/>
      <url>/2023/11/20/b6efb589d40f/</url>
      
        <content type="html"><![CDATA[<p>本文是一篇综述，从<strong>路径搜索</strong>和<strong>轨迹优化</strong>这两个层面来对目前的路径规划算法进行总结。</p><h1 id="路径搜索"><a href="#路径搜索" class="headerlink" title="路径搜索"></a>路径搜索</h1><p><img src="https://s2.loli.net/2023/11/21/J6virsL3NZtRhn1.jpg" alt="img"></p><h2 id="Astar"><a href="#Astar" class="headerlink" title="Astar*"></a>Astar*</h2><p>文章提到了两种Astar的改进算法：一种稀疏Astar算法，对转角的最大增量做了限制，得到的曲线更加平滑；一种结合自适应替换缓存（ARC）策略与基于Astar算法的Theta star算法——<a href="https://www.sciencedirect.com/science/article/abs/pii/S0029801814001292?via=ihub">Angular rate-constrained path planning algorithm for unmanned surface vehicles</a>，考虑了角速度约束得到了更符合其运动特性的规划路径（我认为比较符合我们的需求）</p><p><img src="https://s2.loli.net/2023/11/21/xUPiMm4nuDg5HQo.jpg" alt="img"></p><p>另外除了海域内的障碍，还需要考虑到船只，以及船舶安全领域、国际海上避碰规则等真实因素限制。</p><h2 id="虚拟势场法"><a href="#虚拟势场法" class="headerlink" title="虚拟势场法"></a>虚拟势场法</h2><p>包含人工势场法和快速行进法</p><h3 id="人工势场法"><a href="#人工势场法" class="headerlink" title="人工势场法*"></a>人工势场法*</h3><p>人工势场APF借鉴了电势场的概念，目标点产生引力，而障碍物产生斥力，引力场与斥力场叠加形成包含引导USV到达目标点及避障信息的人工势场。传统APF针对动态避障效果较差，集群运动需要考虑到船舶之间的距离。</p><p><a href="https://www.sciencedirect.com/science/article/pii/S002980182100144X">The hybrid path planning algorithm based on improved A* and artificial potential field for unmanned surface vehicle formations</a>这篇论文中提出的改进APF方法，在结合Astar算法的前提下，对集群编队采用了优先策略，设置一个领队，一个跟随者，一个副跟随者。通过检测船舶之间的距离对速度进行控制来避免集群之间碰撞：跟随者与副跟随者距离靠近时，副跟随者减速，反之加速。形成队形后再按照Astar规划的路径前行。</p><p><img src="https://s2.loli.net/2023/11/21/K4IfGyRlWCZpvok.jpg" alt="img"></p><h3 id="快速进行法"><a href="#快速进行法" class="headerlink" title="快速进行法"></a>快速进行法</h3><p>$|∇(T(s))|W(s)&#x3D;1$</p><p>利用二值栅格法进行环境建模，将障碍物区域设为$W(i, j)&#x3D;0$，将可通行区域设为。$W(i, j)&#x3D;1$通过数值求解程函方程，得到地图中各网格点的<em>T</em>值，将其视为势场值，从而建立虚拟势场</p><p>与APF法相比，FMM法构建势场唯一的极小值点便是起点，不存在路径陷入局部极小值问题（暂时不考虑）</p><h2 id="智能算法"><a href="#智能算法" class="headerlink" title="智能算法"></a>智能算法</h2><h3 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h3><p>GA算法的实时性较差，一般不用于实时规划，用于离线规划，暂不考虑</p><h3 id="粒子群算法"><a href="#粒子群算法" class="headerlink" title="粒子群算法"></a>粒子群算法</h3><p>通过最优解的位置启发其它粒子朝着最优解方向前进，从而实现粒子群整体朝着最优解的方向收敛，本文中提到的算法年代久远了需要重新调研</p><p><img src="https://s2.loli.net/2023/11/13/yQ9gjscvZRGKYDr.png" alt="image-20231113111655572"></p><p>$v_{i,d}$为当前代数下粒子运动速度；$x_{i,d}$为当前代数下粒子位置；$P_{i,d}$为当前代数下的最优解；$P_{g,d}$为历史（全局）最优解；$ω$为惯性权重；$c_1$和$c_2$为学习因子；$r_1$和$r_2$为[0 1]区间内的随机小数；<em>t</em>为当前迭代数。PSO算法首先初始化一群随机粒子，再通过上式进行迭代和进化，从而找到最优解</p><blockquote><p><strong>TODO</strong> 这篇文章提到的智能算法感觉不是很满意，暂时跳过，后续调研寻找新的算法补充上来</p></blockquote><h1 id="轨迹优化"><a href="#轨迹优化" class="headerlink" title="轨迹优化"></a>轨迹优化</h1><h2 id="Dubins"><a href="#Dubins" class="headerlink" title="Dubins"></a>Dubins</h2><p>直线与圆弧组合的曲线，简便易行、计算量小；曲率变化不连续，在直线段与圆弧段的交点处曲率发生突变</p><h2 id="Reeds-Shepp"><a href="#Reeds-Shepp" class="headerlink" title="Reeds-Shepp"></a>Reeds-Shepp</h2><p>针对可以倒退的模型可以规划出更短的路径</p><h2 id="三次样条曲线"><a href="#三次样条曲线" class="headerlink" title="三次样条曲线"></a>三次样条曲线</h2><p>把区间[a,b]分成n个区间，每个小区间的曲线是一个三次方程，路径连续平滑，适合用于优化折线路径</p><h2 id="贝塞尔曲线"><a href="#贝塞尔曲线" class="headerlink" title="贝塞尔曲线"></a>贝塞尔曲线</h2><p>由起点，终点，控制点组成，调整控制点，贝塞尔曲线的形状会发生变化。计算速度和曲线形状控制方面优于三次样条曲线</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>只是初步的调研，目标是寻找一个能够考虑到物理约束（最大角速度）的算法，或者对给出的路径进行较好的轨迹优化</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> 仿真系统 </category>
          
          <category> 路径规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 路径规划 </tag>
            
            <tag> 曲线优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Flask与SpringCloud的酒店管理系统</title>
      <link href="/2023/09/13/5e9fd62c1bea/"/>
      <url>/2023/09/13/5e9fd62c1bea/</url>
      
        <content type="html"><![CDATA[<p>本项目用于辅助SpringCloud相关技术的学习，通过代码实践进行学习。</p><h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>经过对SpringCloud的基础知识学习后，希望将它应用到酒店管理系统这个项目中去。我的规划如下：</p><ul><li>在功能需求已知的情况下，分析并将业务拆解成多个模块实现微服务架构</li><li>进行初步的实体类设计，数据库设计</li><li>优先使用已掌握技能完成基础功能模块，如处理秒杀库存暂时不考虑使用分布式锁，目前计划使用synchronized解决</li></ul><p>当前阻力：</p><ul><li>前端设计</li><li>用户权限控制管理这块没有系统的学习，只能基础的使用JWT进行token解析</li><li>Flask框架并没有实际上手写过，也并没有使用Python进行过与数据库交互的项目开发，没有编写过脚本</li><li>消息中间件没有过多实际编码经验，尚无法确认能否顺利投入到项目使用中</li></ul><p>理想状态：</p><ul><li><input checked="" disabled="" type="checkbox"> 能够熟练的使用SpringCloud对项目各个服务模块进行开发</li><li><input disabled="" type="checkbox"> 引入消息中间件来实现对高并发的支持，引入redis缓存来提高秒杀效率</li><li><input disabled="" type="checkbox"> 补充SpringSecurity知识，对权限认证进行完善</li></ul><hr><p>2023.09.13</p><p>redis和SpringSecurity在后续学习的时候再用于这个项目</p><p>2024.11.22</p><p>把我自己都看笑了，太能🕊了</p><h2 id="模块设计"><a href="#模块设计" class="headerlink" title="模块设计"></a>模块设计</h2><p>仅针对Java部分的SpringCloud微服务设计</p><ol><li>用户管理模块：负责处理用户的注册、登录、基本信息维护等功能。</li><li>酒店信息管理模块：负责处理酒店列表、基本信息、细节信息的维护等功能。</li><li>订单管理模块：负责处理用户预定的订单，包括浏览订单等功能。</li><li>管理员客户管理模块：负责帮助客户重置密码，生成新的随机密码，删除用户</li></ol><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>针对酒店管理系统的业务进行数据库设计和类图的设计</p><h3 id="数据库设计"><a href="#数据库设计" class="headerlink" title="数据库设计"></a>数据库设计</h3><p><strong>t_user</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">用户id</td></tr><tr><td align="center">username</td><td align="center">varchar</td><td align="center">255</td><td align="center">用户名</td></tr><tr><td align="center">password</td><td align="center">varchar</td><td align="center">255</td><td align="center">密码</td></tr><tr><td align="center">salt</td><td align="center">varchar</td><td align="center">255</td><td align="center">盐值</td></tr><tr><td align="center">sex</td><td align="center">int</td><td align="center"></td><td align="center">性别(女0，男1)</td></tr><tr><td align="center">type</td><td align="center">int</td><td align="center"></td><td align="center">类型(0未成年人，1成年人)</td></tr><tr><td align="center">identity</td><td align="center">int</td><td align="center"></td><td align="center">身份(0为普通用户，1为用户管理员，2为酒店管理人员，3为酒店管理员)</td></tr><tr><td align="center">idcn</td><td align="center">char</td><td align="center">18</td><td align="center">身份证号码</td></tr><tr><td align="center">real_name</td><td align="center">varchar</td><td align="center">255</td><td align="center">真实姓名</td></tr><tr><td align="center">phone</td><td align="center">varchar</td><td align="center">255</td><td align="center">电话号码</td></tr><tr><td align="center">email</td><td align="center">varchar</td><td align="center">255</td><td align="center">邮箱</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_hotel</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">用户id</td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center">255</td><td align="center">酒店名称</td></tr><tr><td align="center">address</td><td align="center">varchar</td><td align="center">255</td><td align="center">酒店地址</td></tr><tr><td align="center">introduction</td><td align="center">varchar</td><td align="center">255</td><td align="center">酒店介绍</td></tr><tr><td align="center">phone</td><td align="center">varchar</td><td align="center"></td><td align="center">联系方式</td></tr><tr><td align="center">stars</td><td align="center">int</td><td align="center"></td><td align="center">星级</td></tr><tr><td align="center">brand</td><td align="center">varchar</td><td align="center">255</td><td align="center">品牌</td></tr><tr><td align="center">business_district</td><td align="center">varchar</td><td align="center">255</td><td align="center">所属商圈</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_order</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">订单id</td></tr><tr><td align="center">user_id</td><td align="center">int</td><td align="center">255</td><td align="center">用户id</td></tr><tr><td align="center">room_id</td><td align="center">int</td><td align="center">255</td><td align="center">房间id</td></tr><tr><td align="center">check_in_date</td><td align="center">datetime</td><td align="center">255</td><td align="center">入住日期</td></tr><tr><td align="center">check_out_date</td><td align="center">datetime</td><td align="center"></td><td align="center">退房日期</td></tr><tr><td align="center">room_num</td><td align="center">int</td><td align="center"></td><td align="center">房间数量</td></tr><tr><td align="center">expected_guest_num</td><td align="center">int</td><td align="center"></td><td align="center">预期入住人数</td></tr><tr><td align="center">has_children</td><td align="center">int</td><td align="center">18</td><td align="center">是否有儿童（0无1有）</td></tr><tr><td align="center">status</td><td align="center">int</td><td align="center">255</td><td align="center">订单状态（0未支付，1已支付，2已取消）</td></tr><tr><td align="center">price</td><td align="center">decimal</td><td align="center">255</td><td align="center">订单价格</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_room</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">房间id</td></tr><tr><td align="center">hotel_id</td><td align="center">int</td><td align="center"></td><td align="center">所属酒店id</td></tr><tr><td align="center">num</td><td align="center">int</td><td align="center"></td><td align="center">剩余数量</td></tr><tr><td align="center">type</td><td align="center">varchar</td><td align="center">255</td><td align="center">房间类型（0单人间，1双床房，2大床房）</td></tr><tr><td align="center">original_price</td><td align="center">decimal</td><td align="center"></td><td align="center">原价</td></tr><tr><td align="center">price</td><td align="center">decimal</td><td align="center"></td><td align="center">当前价格</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_facilities</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center">设施id</td></tr><tr><td align="center">name</td><td align="center">varchar</td><td align="center">255</td><td align="center">设施名称</td></tr><tr><td align="center">is_free</td><td align="center">int</td><td align="center"></td><td align="center">是否免费(0付费，1免费)</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><p><strong>t_hotel_facilities</strong></p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">长度</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">id</td><td align="center">int</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">hotel_id</td><td align="center">int</td><td align="center"></td><td align="center">酒店id</td></tr><tr><td align="center">facilities_id</td><td align="center">int</td><td align="center"></td><td align="center">设施id</td></tr><tr><td align="center">created_at</td><td align="center">datetime</td><td align="center"></td><td align="center">创建时间</td></tr><tr><td align="center">updated_at</td><td align="center">datetime</td><td align="center"></td><td align="center">修改时间</td></tr></tbody></table><hr><p>2023.09.13</p><p>t_facilities设计有问题，is_free字段应该放在t_hotel_facilities中而不是t_facilities中；其次为用户增加了一个hotel_id的字段，提供给酒店管理人员标识其管理的酒店</p><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p>有机会再补吧，先🕊了</p><p>2023.09.13</p><p>不会再补了，彻底🕊了</p><h1 id="用户业务"><a href="#用户业务" class="headerlink" title="用户业务"></a>用户业务</h1><h2 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h2><p>以前写项目的时候根本没有怎么考虑过权限问题，很简单的做了一个token验证就结束了，现在自己开始考虑到这些问题发现自己根本想不到什么好的解决方案。</p><p>首先担心的是同角色之间资源的相互访问问题，也许可以通过验证用户的角色身份来解决一部分问题，但是如果同角色试图访问其他用户的资源，不对token中的用户id进行解析是没法解决的。这样的话我在Gateway的微服务中还需要添加与数据库的连接，我不知道是不是必须如此…我主观上是这么想的，确实想不到更优雅的办法，但是感觉这样子会很笨。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取请求头</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">    <span class="comment">//  请求路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line">    <span class="comment">//  判断是否需要核验token</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要token</span></span><br><span class="line">    <span class="keyword">if</span>(tokenShouldCheck(requestPath)) &#123;</span><br><span class="line">      <span class="comment">//  不包含token</span></span><br><span class="line">      <span class="keyword">if</span>(!headers.containsKey(<span class="string">&quot;Authorization&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  核验token是否有效,以及用户权限能否获取资源</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> headers.getFirst(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.getClaimsByToken(token);</span><br><span class="line">      <span class="comment">//  过期</span></span><br><span class="line">      <span class="keyword">if</span>(claims.getExpiration().getTime() &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().getTime()) &#123;</span><br><span class="line">        <span class="comment">//  token过期，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  没有过期，对权限进行验证  </span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  传递给下一个过滤器</span></span><br><span class="line">    <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">tokenShouldCheck</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !path.equals(<span class="string">&quot;/users/login&quot;</span>) &amp;&amp; !path.equals(<span class="string">&quot;/users/register&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整段代码我只能说，和优雅是完全不沾边，感觉过滤器只学到了皮毛…</p><hr><p>2023&#x2F;09&#x2F;06</p><p>在昨晚写下博客之后又自己捣鼓了好久，发现我确实学的不精…</p><p>我最开始的思路是用feign来获取用户信息，但是我居然认为feign的远程调用要经过http，所以我放弃了这个想法。如果真是这样的话，那微服务中使用feign调用其他微服务来实现功能都没法成立了，毕竟你在实现中哪来的token（如果要做token验证）</p><p>于是使用feign解决了，但是确实不算优雅</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  UserClient userClient;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取请求头</span></span><br><span class="line">    <span class="type">HttpHeaders</span> <span class="variable">headers</span> <span class="operator">=</span> request.getHeaders();</span><br><span class="line">    <span class="comment">//  从请求中获取参数</span></span><br><span class="line"><span class="comment">//    MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span></span><br><span class="line">    <span class="comment">//  请求路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">requestPath</span> <span class="operator">=</span> request.getURI().getPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  需要token</span></span><br><span class="line">    <span class="keyword">if</span>(tokenShouldCheck(requestPath)) &#123;</span><br><span class="line">      <span class="comment">//  不包含token</span></span><br><span class="line">      <span class="keyword">if</span>(!headers.containsKey(<span class="string">&quot;Authorization&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  核验token是否有效,以及用户权限能否获取资源</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> headers.getFirst(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">      <span class="comment">//  空token</span></span><br><span class="line">      <span class="keyword">if</span>(token == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="type">Claims</span> <span class="variable">claims</span> <span class="operator">=</span> JwtUtils.getClaimsByToken(token);</span><br><span class="line">      <span class="comment">//  过期</span></span><br><span class="line">      <span class="keyword">if</span>(claims.getExpiration().getTime() &lt; <span class="keyword">new</span> <span class="title class_">Date</span>().getTime()) &#123;</span><br><span class="line">        <span class="comment">//  token过期，设置状态码</span></span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="keyword">return</span> response.setComplete();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//  没有过期</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">id</span> <span class="operator">=</span> Integer.valueOf(claims.getSubject());</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userClient.findUserById(id);</span><br><span class="line">        <span class="comment">//  权限不足</span></span><br><span class="line">        <span class="keyword">if</span>(!hasAuthority(user, requestPath)) &#123;</span><br><span class="line">          <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">          <span class="comment">//  403权限不足</span></span><br><span class="line">          response.setStatusCode(HttpStatus.FORBIDDEN);</span><br><span class="line">          <span class="keyword">return</span> response.setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  传递给下一个过滤器</span></span><br><span class="line">    <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">tokenShouldCheck</span><span class="params">(String path)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !path.equals(<span class="string">&quot;/users/login&quot;</span>) &amp;&amp; !path.equals(<span class="string">&quot;/users/register&quot;</span>) &amp;&amp; !path.equals(<span class="string">&quot;/users/sendVerifyCode&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否有权限访问当前url下的资源</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> user 用户</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> requestPath 请求路径</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否有权限</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Boolean <span class="title function_">hasAuthority</span><span class="params">(User user, String requestPath)</span> &#123;</span><br><span class="line">    <span class="comment">//  判断管理员权限</span></span><br><span class="line">    <span class="keyword">if</span>(requestPath.equals(<span class="string">&quot;/users&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> user.getIdentity() == Identity.Admin.ordinal();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  已/users/为开头</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (requestPath.startsWith(<span class="string">&quot;/users/&quot;</span>)) &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">paramId</span> <span class="operator">=</span> requestPath.split(<span class="string">&quot;/&quot;</span>)[<span class="number">2</span>];</span><br><span class="line">      <span class="type">String</span> <span class="variable">id</span> <span class="operator">=</span> String.valueOf(user.getId());</span><br><span class="line">      <span class="comment">//  id正确</span></span><br><span class="line">      <span class="keyword">if</span>(paramId.equals(id)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//  id错误，判断是否有管理权限</span></span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> user.getIdentity() == Identity.Admin.ordinal();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  其他url</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>其他功能以前都写烂了，没什么好说的感觉，不能很好的完成权限认证是我认为这项目开局的败笔😡</p><h1 id="酒店业务"><a href="#酒店业务" class="headerlink" title="酒店业务"></a>酒店业务</h1><h2 id="Feign"><a href="#Feign" class="headerlink" title="Feign"></a>Feign</h2><p>这两天几乎遇到的所有难题都和Feign有关，可以说被Feign狠狠拷打了…</p><p><strong>错误一</strong></p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">feign.codec.DecodeException: Error <span class="keyword">while</span> extracting response <span class="keyword">for</span> <span class="built_in">type</span> [java.util.ArrayList&lt;com.magus.api.entity.Room&gt;] and content <span class="built_in">type</span> [application/json];</span><br></pre></td></tr></table></figure><p>这两天见到的最多的就是这句话，然而造成这个错误的原因是多种多样的。</p><p>我第一次遭遇这个错误是返回值不匹配造成的，起因是我在网上看到了和我同样的操作，在Controller中返回自定义的Json类，他说他在修改为Java自封装类型List之后就解决了（其实自定义类完全是可以的，但是需要创建无参构造函数）。因此我进行了尝试，以至于后面改的太乱了，有的地方是JsonResult，有的地方是User，不匹配造成了这个错误。</p><p>然后还有一个原因则是我的Feign中缺少一个配置</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.magus.base.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.ObjectProvider;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.http.HttpMessageConverters;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.converter.HttpMessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * feign的http客户端配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FeignConfig</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *No qualifying bean of type ‘org.springframework.boot.autoconfigure.http.HttpMessage</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="meta">@ConditionalOnMissingBean</span></span><br><span class="line">  <span class="keyword">public</span> HttpMessageConverters <span class="title function_">messageConverters</span><span class="params">(ObjectProvider&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">HttpMessageConverters</span>(converters.orderedStream().collect(Collectors.toList()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>HttpMessageConverters在一些版本中无法被装配，因此我们添加一个Feign的配置类对他进行@Bean装配</p><p><strong>错误二</strong></p><p>这个错误又难找又逆天，网上也搜罗不到相关的信息，我只能一点点的推测来判断。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;roomProvider&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RoomClient</span> &#123;</span><br><span class="line">  <span class="comment">//  根据id获取room</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/rooms/&#123;id&#125;&quot;)</span></span><br><span class="line">  Room <span class="title function_">findRoomById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  获取所有room</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/rooms&quot;)</span></span><br><span class="line">  ArrayList&lt;Room&gt; <span class="title function_">findAllRooms</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  根据酒店id获取room</span></span><br><span class="line">  <span class="meta">@GetMapping(&quot;/rooms/roomsOfHotel&quot;)</span></span><br><span class="line">  ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(<span class="meta">@RequestParam(&quot;hotelId&quot;)</span> Integer hotelId)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果FeignClient中定义的接口需要带参数的话，而且参数本身不是在url上，那么一定要添加注解@RequestParam，不然是无法识别到对应的controller接口的</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;roomsOfHotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(Integer hotelId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> roomService.findRoomByHotel(hotelId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我的controller接口名称，返回值，参数名，一切都是吻合的，但是依然要加@RequestParam注解，不然收获一小时调试hhh</p><h2 id="查询酒店详细信息"><a href="#查询酒店详细信息" class="headerlink" title="查询酒店详细信息"></a>查询酒店详细信息</h2><p>这个函数的实现很好的使用了Feign来跨服务调用</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> HotelDetail <span class="title function_">getDetail</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">  <span class="type">Hotel</span> <span class="variable">hotel</span> <span class="operator">=</span> hotelMapper.selectById(id);</span><br><span class="line">  <span class="comment">//  酒店id</span></span><br><span class="line">  <span class="type">Integer</span> <span class="variable">hotelId</span> <span class="operator">=</span> hotel.getId();</span><br><span class="line">  <span class="type">HotelDetail</span> <span class="variable">detail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HotelDetail</span>(hotel);</span><br><span class="line">  <span class="comment">//  设置房间列表</span></span><br><span class="line">  ArrayList&lt;Room&gt; rooms = roomClient.roomsOfHotel(hotelId);</span><br><span class="line">  detail.setRooms(rooms);</span><br><span class="line">  <span class="comment">//  设置设施列表</span></span><br><span class="line">  ArrayList&lt;Facility&gt; facilities = facilityClient.facilitiesOfHotel(hotelId);</span><br><span class="line">  detail.setFacilities(facilities);</span><br><span class="line">  <span class="keyword">return</span> detail;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计了一个dto来展示酒店详细信息</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HotelDetail</span> &#123;</span><br><span class="line">  <span class="comment">//  酒店地址</span></span><br><span class="line">  <span class="keyword">private</span> String address;</span><br><span class="line">  <span class="comment">//  品牌</span></span><br><span class="line">  <span class="keyword">private</span> String brand;</span><br><span class="line">  <span class="comment">//  商圈</span></span><br><span class="line">  <span class="keyword">private</span> String businessDistrict;</span><br><span class="line">  <span class="comment">//  酒店id</span></span><br><span class="line">  <span class="keyword">private</span> Integer id;</span><br><span class="line">  <span class="comment">//  酒店简介</span></span><br><span class="line">  <span class="keyword">private</span> String introduction;</span><br><span class="line">  <span class="comment">//  酒店名称</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">//  联系方式</span></span><br><span class="line">  <span class="keyword">private</span> String phone;</span><br><span class="line">  <span class="comment">//  星级</span></span><br><span class="line">  <span class="keyword">private</span> Integer stars;</span><br><span class="line">  <span class="comment">//  设施</span></span><br><span class="line">  ArrayList&lt;Facility&gt; facilities;</span><br><span class="line">  <span class="comment">//  房间列表</span></span><br><span class="line">  ArrayList&lt;Room&gt; rooms;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">HotelDetail</span><span class="params">(Hotel hotel)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.stars = hotel.getStars();</span><br><span class="line">    <span class="built_in">this</span>.phone = hotel.getPhone();</span><br><span class="line">    <span class="built_in">this</span>.name = hotel.getName();</span><br><span class="line">    <span class="built_in">this</span>.introduction = hotel.getIntroduction();</span><br><span class="line">    <span class="built_in">this</span>.id = hotel.getId();</span><br><span class="line">    <span class="built_in">this</span>.businessDistrict = hotel.getBusinessDistrict();</span><br><span class="line">    <span class="built_in">this</span>.brand = hotel.getBrand();</span><br><span class="line">    <span class="built_in">this</span>.address = hotel.getAddress();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="订单业务"><a href="#订单业务" class="headerlink" title="订单业务"></a>订单业务</h1><h2 id="下单"><a href="#下单" class="headerlink" title="下单"></a>下单</h2><p>下单功能的设计和代码编写过程中都遭遇不少困难。</p><h2 id="设计-1"><a href="#设计-1" class="headerlink" title="设计"></a>设计</h2><p>首先是对于库存进行加锁来避免多线程下出现库存负数的情况，在设计方面目前考虑到单服务器部署下使用jvm的synchronized来解决。</p><p>其次是异步方面的设计，要求是“将耗时的操作放到后台，而界面可以显示提示信息，并且响应等的不耐烦的用户的取消操作。”</p><p>前端设计应该需要用到异步和回调，在响应到达之前进入一个正在下单的界面，并且可以选择取消，响应到达则关闭这个界面。针对此，后端需要设计的只是取消这个功能，所以我在数据库设计方面对订单状态增加了一个下单中的状态OrderStatus.CREATING，订单在插入数据库时默认是这个状态。在用户发送取消的请求后，取消服务的实现方面，我首先会对订单的状态进行查询，因为并不确认此时的下单业务是否完成，订单状态可能处于下单中，下单失败，待支付三种状态。如果处于下单中的状态，将其修改为取消状态，是有问题的，因为代表着下单服务中的检查库存、修改订单状态还没有发生，即使将其设置为取消状态，后续也会被覆盖。</p><p>因此我认为比较合理的设计是多次询问订单状态，直至变化为下单失败或待支付，如果多次询问仍为下单中，则抛出取消失败的异常返回给前端。</p><h2 id="Feign-1"><a href="#Feign-1" class="headerlink" title="Feign"></a>Feign</h2><p>在Feign的使用上，之前学习并没有学到参数传递方面的知识点，现在已经弄清楚了。结合上一篇酒店模块中的进行一个整理</p><h3 id="路径中的参数"><a href="#路径中的参数" class="headerlink" title="路径中的参数"></a>路径中的参数</h3><p>当请求路径中代有参数，并且想要将其提取出来，需要使用@PathVariable注解，同时参数名和类型与Controller中保持一致</p><p><strong>FeignClient</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rooms/&#123;id&#125;&quot;)</span></span><br><span class="line">Room <span class="title function_">findRoomById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span>;</span><br></pre></td></tr></table></figure><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="keyword">public</span> Room <span class="title function_">findRoomById</span><span class="params">(<span class="meta">@PathVariable</span> Integer id)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> roomService.findRoomById(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法中的参数"><a href="#方法中的参数" class="headerlink" title="方法中的参数"></a>方法中的参数</h3><p>当接口方法中有参数时，使用@RequestParam注解，同时参数名和类型与Controller中保持一致，Controller中不需要@RequestParam注解</p><p><strong>FeignClient</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rooms/roomsOfHotel&quot;)</span></span><br><span class="line">ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(<span class="meta">@RequestParam(&quot;hotelId&quot;)</span> Integer hotelId)</span>;</span><br></pre></td></tr></table></figure><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;roomsOfHotel&quot;)</span></span><br><span class="line"><span class="keyword">public</span> ArrayList&lt;Room&gt; <span class="title function_">roomsOfHotel</span><span class="params">(Integer hotelId)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> roomService.findRoomByHotel(hotelId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法中自定义类"><a href="#方法中自定义类" class="headerlink" title="方法中自定义类"></a>方法中自定义类</h3><p>当接口方法中想要传递可序列化类时，使用@RequestBody注解，同时参数名和类型与Controller中保持一致，Controller中<strong>需要@RequestBody注解</strong>，很重要，一定要加</p><p><strong>FeignClient</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GetMapping(&quot;/rooms/updateRoom&quot;)</span></span><br><span class="line">JsonResult <span class="title function_">updateRoom</span><span class="params">(<span class="meta">@RequestBody</span> Room room)</span>;</span><br></pre></td></tr></table></figure><p><strong>Controller</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;updateRoom&quot;)</span></span><br><span class="line"><span class="keyword">public</span> JsonResult <span class="title function_">updateRoom</span><span class="params">(<span class="meta">@RequestBody</span> Room room)</span> &#123;</span><br><span class="line">  roomService.updateRoom(room);</span><br><span class="line">  <span class="type">JsonResult</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JsonResult</span>(OK);</span><br><span class="line">  result.setMessage(<span class="string">&quot;更新房间信息成功&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="OrderService"><a href="#OrderService" class="headerlink" title="OrderService"></a>OrderService</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">addOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">  <span class="type">LocalDate</span> <span class="variable">start</span> <span class="operator">=</span> order.getCheckInDate();</span><br><span class="line">  <span class="type">LocalDate</span> <span class="variable">end</span> <span class="operator">=</span> order.getCheckOutDate();</span><br><span class="line">  <span class="type">long</span> <span class="variable">days</span> <span class="operator">=</span> ChronoUnit.DAYS.between(start, end);</span><br><span class="line">  <span class="comment">//  对预定日期合理性做检查</span></span><br><span class="line">  <span class="keyword">if</span>(days &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderDateException</span>(<span class="string">&quot;预定日期错误&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  计算价格</span></span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomClient.findRoomById(order.getRoomId());</span><br><span class="line">  <span class="type">Integer</span> <span class="variable">roomNum</span> <span class="operator">=</span> order.getRoomNum();</span><br><span class="line">  <span class="type">Double</span> <span class="variable">price</span> <span class="operator">=</span> roomNum * days * room.getPrice();</span><br><span class="line">  order.setPrice(price);</span><br><span class="line">  <span class="comment">//  将订单状态设置为下单中并插入数据库</span></span><br><span class="line">  <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">  order.setCreatedAt(date);</span><br><span class="line">  order.setUpdatedAt(date);</span><br><span class="line">  order.setStatus(OrderStatus.CREATING.ordinal());</span><br><span class="line">  <span class="comment">//  操作数据库</span></span><br><span class="line">  <span class="keyword">if</span>(orderMapper.insert(order) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AddOrderException</span>(<span class="string">&quot;创建订单失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  String result;</span><br><span class="line">  <span class="comment">//  对库存进行核验，如果库存满足则可以下单</span></span><br><span class="line">  <span class="keyword">if</span>(checkStorage(room.getId(), roomNum)) &#123;</span><br><span class="line">    <span class="comment">//  下单成功</span></span><br><span class="line">    order.setStatus(OrderStatus.UNPAID.ordinal());</span><br><span class="line">    result = <span class="string">&quot;订单待支付&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//  库存不满足,订单状态设置为失败</span></span><br><span class="line">    order.setStatus(OrderStatus.FAIL.ordinal());</span><br><span class="line">    result = <span class="string">&quot;下单失败，库存不足&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  对状态进行更新</span></span><br><span class="line">  <span class="keyword">if</span>(orderMapper.update(order) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UpdateOrderException</span>(<span class="string">&quot;更新订单状态失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancel</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line">  <span class="comment">//  对订单状态进行检查</span></span><br><span class="line">  <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> orderMapper.selectById(id);</span><br><span class="line">  <span class="comment">//  仍处在下单中的无法进行取消，必须等待状态变为失败或未支付</span></span><br><span class="line">  <span class="keyword">while</span>(order.getStatus() == OrderStatus.CREATING.ordinal()) &#123;</span><br><span class="line">    order = orderMapper.selectById(id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  跳出循环则订单状态理论上变为失败和未支付</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//  下单成功处于未支付状态，取消订单需要还原库存</span></span><br><span class="line">  <span class="keyword">if</span>(order.getStatus() != OrderStatus.FAIL.ordinal()) &#123;</span><br><span class="line">    <span class="comment">//  不是失败也不是未支付，状态错误</span></span><br><span class="line">    <span class="keyword">if</span>(order.getStatus() != OrderStatus.UNPAID.ordinal()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">OrderStatusException</span>(<span class="string">&quot;订单状态错误&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  未支付房间库存还原(这里应该使用事务)</span></span><br><span class="line">    <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomClient.findRoomById(order.getRoomId());</span><br><span class="line">    room.setNum(room.getNum() + order.getRoomNum());</span><br><span class="line">    roomClient.updateRoom(room);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  下单失败无需还原房间库存，状态设置为取消下单即可</span></span><br><span class="line">  order.setStatus(OrderStatus.CANCEL.ordinal());</span><br><span class="line">  <span class="keyword">if</span>(orderMapper.update(order) != <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UpdateOrderException</span>(<span class="string">&quot;取消订单失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Boolean <span class="title function_">checkStorage</span><span class="params">(Integer roomId, Integer roomNum)</span> &#123;</span><br><span class="line">  <span class="comment">//  绝对的低效率</span></span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> roomClient.findRoomById(roomId);</span><br><span class="line">  <span class="keyword">if</span>(room.getNum() &gt;= roomNum) &#123;</span><br><span class="line">    room.setNum(room.getNum() - roomNum);</span><br><span class="line">    <span class="type">JsonResult</span> <span class="variable">result</span> <span class="operator">=</span> roomClient.updateRoom(room);</span><br><span class="line">    <span class="comment">//  库存充足</span></span><br><span class="line">    <span class="keyword">return</span> result.getCode() == <span class="number">200</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//  库存不足</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能说都能达到想要的效果，但是效率都不够高，多次的访问数据库进行查询就意味着效率的低下。另外就是cancel中询问订单状态应该设置一定的重试次数，使用while循环是有死循环的风险的（我这里图省事了hhh）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>前端可以说完全没做，除了flask用了一些别人写好的模板，用了一下bootstrap和jQuery，可以说是很简陋。如果有机会的话想学习一下React，之前有过Vue的入门经历，还是想对这些东西都有个初步的认识（最好都能看懂），为了在以后的前后端沟通中更加方便吧</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p><strong>Java</strong></p><p>通过这个项目自主学习和实践了一下SpringCloud的基本用法，包括Nacos，Eureka，GateWay，Feign等。也在实践中理解了一些新的概念，像是负载均衡，反向代理等。</p><p>美中不足的是没有做服务熔断降级这一块，原计划是再对Sentinel进行一下学习然后使用到这个项目中的；同时MQ和Redis也没有用到，除了使用JVM处理并发以外的其他方法也没有尝试，像用Zookeeper的锁，用乐观锁悲观锁这些都没有尝试，有机会希望都能把这些知识补上</p><p><strong>Python</strong></p><p>通过这个项目也是把python开发实践了一下，之前只做过简单的爬虫，或者是小模型的训练，没有做过Web应用这方面的。Flask框架确实很方便，配合jinja2可以很快速的搭建一些简易的平台，在前端中直接使用Python语句确实很爽。但是现在主流还是前后端分离吧，专业的人干专业的事，前端还是掌握的太少了。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> Python </category>
          
          <category> Java </category>
          
          <category> 酒店管理系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> SpringCloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask的基本概念与使用方法</title>
      <link href="/2023/09/13/038442bbfe74/"/>
      <url>/2023/09/13/038442bbfe74/</url>
      
        <content type="html"><![CDATA[<p>本文记录了一些关于Flask的基本概念与使用方法。Flask是一个轻量级的web框架，支持前后端整合，并且可在前端中直接使用相关的python语句。支持ORM（Object Relational Mapping），很好的结合mvc模式进行开发。</p><h1 id="依赖安装"><a href="#依赖安装" class="headerlink" title="依赖安装"></a>依赖安装</h1><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Flask依赖</span></span><br><span class="line">pip install Flask</span><br><span class="line"><span class="comment"># 与数据库交互</span></span><br><span class="line">pip install flask<span class="literal">-sqlalchemy</span></span><br><span class="line"><span class="comment"># 将已有数据库导入</span></span><br><span class="line">pip install sqlacodegen</span><br><span class="line"><span class="comment"># 注册发送邮件</span></span><br><span class="line">pip install flask<span class="literal">-mail</span></span><br><span class="line"><span class="comment"># 前端表单验证</span></span><br><span class="line">pip install wtforms</span><br></pre></td></tr></table></figure><h1 id="Jinja2"><a href="#Jinja2" class="headerlink" title="Jinja2"></a>Jinja2</h1><p>Jinja2是一个Python模板引擎，它提供一种将数据和模板结合在一起，以生成动态文本的方法。它能够生成具有清晰而简洁的结构、更易读取的网页代码</p><p>它的常用使用方法有：python变量、语句直接在模板中使用或执行</p><p>使用{ { } }来包含一个变量，在render_template中通过额外的参数传递变量至定位的模板中，在该模板中可以使用{ { var } }来使用传递的变量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> render_template(<span class="string">&quot;admin.html&quot;</span>, hotels=hotels, facilities=facilities)</span><br></pre></td></tr></table></figure><p>在admin.html中，可以使用来使用hotels变量</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span> <span class="attr">style</span>=<span class="string">&quot;margin-top: 20px;&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;col-10&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">&quot;question-ul&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; left: 70px; top: 30px&quot;</span>&gt;</span></span><br><span class="line">                &#123;% for hotel in hotels %&#125;</span><br><span class="line">                <span class="tag">&lt;<span class="name">li</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;hotel-main&quot;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;question-title&quot;</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line">                                &#123;&#123;hotel.name&#125;&#125;</span><br><span class="line">                            <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用{ % % }来使用python语句，例如上方的代码中想要使用python中的for循环，直接使用{ % for hotel in hotels % }即可</p><p>需要注意的是，jinja2中对于语句的使用，都需要有闭合。例如{ % if % }则需要在代码块结束之后以{ % endif % }结尾；{ % for % }则需要以{ % endfor% }结尾</p><p>更多的使用方法尚未学习🕊🕊🕊</p><h1 id="config"><a href="#config" class="headerlink" title="config"></a>config</h1><p>配置方面，和SpringBoot很相似，支持用一个config.py文件来进行数据库、发送邮件的smtp服务器以及密钥等</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">SECRET_KEY = <span class="string">&quot;Geo0426_xxxUniversity_xxx&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机</span></span><br><span class="line">HOSTNAME = <span class="string">&quot;localhost&quot;</span></span><br><span class="line"><span class="comment"># 端口</span></span><br><span class="line">PORT = <span class="number">3307</span></span><br><span class="line"><span class="comment"># 用户名</span></span><br><span class="line">USERNAME = <span class="string">&quot;root&quot;</span></span><br><span class="line"><span class="comment"># 密码</span></span><br><span class="line">PASSWORD = <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment"># 数据库名称</span></span><br><span class="line">DATABASE = <span class="string">&quot;hms&quot;</span></span><br><span class="line"><span class="comment">#  uri</span></span><br><span class="line">DB_URI = <span class="string">f&quot;mysql+pymysql://<span class="subst">&#123;USERNAME&#125;</span>:<span class="subst">&#123;PASSWORD&#125;</span>@<span class="subst">&#123;HOSTNAME&#125;</span>:<span class="subst">&#123;PORT&#125;</span>/<span class="subst">&#123;DATABASE&#125;</span>?charset=utf8mb4&quot;</span></span><br><span class="line"></span><br><span class="line">SQLALCHEMY_DATABASE_URI = DB_URI</span><br><span class="line"></span><br><span class="line"><span class="comment">#  邮箱服务</span></span><br><span class="line">MAIL_SERVER = <span class="string">&quot;smtp.163.com&quot;</span></span><br><span class="line">MAIL_USE_SSL = <span class="literal">True</span></span><br><span class="line">MAIL_PORT = <span class="number">465</span></span><br><span class="line">MAIL_USERNAME = <span class="string">&quot;xxx@163.com&quot;</span></span><br><span class="line">MAIL_PASSWORD = <span class="string">&quot;xxx&quot;</span></span><br><span class="line">MAIL_DEFAULT_SENDER = <span class="string">&quot;xxx@163.com&quot;</span></span><br></pre></td></tr></table></figure><h1 id="app"><a href="#app" class="headerlink" title="app"></a>app</h1><p>Flask的核心（有点类似Vue的感觉），相当于一个主类，将相关的数据库、控制器（这里应该是blueprints）、配置进行管理，此外“钩子”函数（请求拦截器，上下文处理器）也定义在其中</p><h2 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h2><p>在每一个请求执行之前，都会先执行的函数。这里在请求发起之前先将浏览器中session的token取出来，如果存在token信息则表示完成了登录，可以给全局变量g.user设置信息；否则将其设置为空表示没有登录</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_before_request</span>():</span><br><span class="line">    user_id = session.get(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> user_id:</span><br><span class="line">        user = User.query.get(user_id)</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><h2 id="上下文处理器"><a href="#上下文处理器" class="headerlink" title="上下文处理器"></a>上下文处理器</h2><p>用来处理一些所有页面都需要进行渲染的变量，比如登录信息，使用它就可以很好配合jinja2</p><p>例如我们将用户登录后的信息用一个user变量存储</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.context_processor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_context_processor</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user&quot;</span>: g.user&#125;</span><br></pre></td></tr></table></figure><p>它返回的是一个字典，接下里所有template中都可以使用这个键值来获取这个对象g.user</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&#123;% if user %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span>&gt;</span>&#123;&#123; user.username &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;nav-item&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span> <span class="attr">href</span>=<span class="string">&quot;&#123;&#123; url_for(&#x27;auth.logout&#x27;) &#125;&#125;&quot;</span>&gt;</span>退出登录<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;% else %&#125;</span><br></pre></td></tr></table></figure><p>完整的代码如下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, session, g</span><br><span class="line"><span class="keyword">from</span> ext <span class="keyword">import</span> db, mail</span><br><span class="line"><span class="keyword">from</span> blueprints.auth <span class="keyword">import</span> bp <span class="keyword">as</span> auth_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.users <span class="keyword">import</span> bp <span class="keyword">as</span> user_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.hotels <span class="keyword">import</span> bp <span class="keyword">as</span> hotel_bp</span><br><span class="line"><span class="keyword">from</span> blueprints.rooms <span class="keyword">import</span> bp <span class="keyword">as</span> room_bp</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> User</span><br><span class="line"><span class="keyword">import</span> config</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"><span class="comment">#  配置</span></span><br><span class="line">app.config.from_object(config)</span><br><span class="line"><span class="comment">#  解决循环引用的问题</span></span><br><span class="line">db.init_app(app)</span><br><span class="line"><span class="comment">#  注册蓝图</span></span><br><span class="line">app.register_blueprint(auth_bp)</span><br><span class="line">app.register_blueprint(user_bp)</span><br><span class="line">app.register_blueprint(hotel_bp)</span><br><span class="line">app.register_blueprint(room_bp)</span><br><span class="line">mail.init_app(app)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.before_request</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_before_request</span>():</span><br><span class="line">    user_id = session.get(<span class="string">&quot;user_id&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> user_id:</span><br><span class="line">        user = User.query.get(user_id)</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, user)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">setattr</span>(g, <span class="string">&quot;user&quot;</span>, <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#  上下文处理器，用来处理一些所有界面都需要用到的变量（可以用来对登录状态做一个保存）</span></span><br><span class="line"><span class="meta">@app.context_processor</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_context_processor</span>():</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">&quot;user&quot;</span>: g.user&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    app.run()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="models"><a href="#models" class="headerlink" title="models"></a>models</h1><p>models是Flask中ORM的核心部分，通过类定义的方式，与数据库中的表进行映射</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Facility</span>(db.Model):</span><br><span class="line">    __tablename__ = <span class="string">&#x27;t_facility&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">id</span> = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">255</span>, <span class="string">&#x27;utf8mb4_general_ci&#x27;</span>), nullable=<span class="literal">False</span>)</span><br><span class="line">    created_at = Column(DateTime, nullable=<span class="literal">False</span>)</span><br><span class="line">    updated_at = Column(DateTime, nullable=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>tablename设置为数据库中对映的表格名称，接着通过flask_sqlalchemy中的SQLAlchemy可以将models.py中定义完成的类，以表的形式在数据库中生成。</p><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask_sqlalchemy <span class="keyword">import</span> SQLAlchemy</span><br><span class="line"></span><br><span class="line">db = SQLAlchemy()</span><br><span class="line"><span class="comment"># 在完成了db.init_app(app)将app与db绑定后，执行create_all()生成数据库表</span></span><br><span class="line">db.create_all()</span><br></pre></td></tr></table></figure><p>如果想要对数据库中的表进行改动（增删字段等操作），也可以通过修改models.py中的模型，然后同步更新到数据库。</p><p>需要用到flask-migrate</p><p>安装依赖</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">pip install flask<span class="literal">-migrate</span></span><br></pre></td></tr></table></figure><p>在app.py中引入Migrate</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">migrate = Migrate(app, db)</span><br></pre></td></tr></table></figure><p>大致可以分为三步：</p><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  first step</span></span><br><span class="line">flask db init</span><br><span class="line"><span class="comment">#  second step</span></span><br><span class="line">flask db migrate</span><br><span class="line"><span class="comment">#  third step</span></span><br><span class="line">flask db upgrade</span><br></pre></td></tr></table></figure><p>在执行完第一步完成初始化之后，后续更新数据库的表只需要执行后两步即可，即flask db migrate和flask db upgrade</p><p>在Flask中不需要编写sql语句，可以通过db.session只通过对类进行操作来实现数据库的增删改查</p><h2 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h2><p>大致步骤为创建一个实体类的对象对应数据库中表的一行数据；使用db.session添加并提交</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  创建Room对象</span></span><br><span class="line">room = Room(hotel_id=hotel_id, original_price=original_price, price=price, num=num, <span class="built_in">type</span>=room_type, created_at=now, updated_at=now)</span><br><span class="line"><span class="comment">#  将其在会话中插入</span></span><br><span class="line">db.session.add(room)</span><br><span class="line"><span class="comment">#  提交</span></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>查询一条数据，可以使用class.query.get()</p><p>根据条件查询数据集合，则需要用到filter进行过滤，可以得到一个集合</p><p>.all()可以获取全部的数据; .first()能够获得第一条数据</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  根据主键查询一行数据，并映射到实体类对象</span></span><br><span class="line">room = Room.query.get(room_id)</span><br><span class="line"><span class="comment">#  按照一定的条件查询（使用过滤器）</span></span><br><span class="line">hotel_facilities = HotelFacility.query.filter_by(hotel_id=hotel.<span class="built_in">id</span>).<span class="built_in">all</span>()</span><br><span class="line"><span class="comment">#  获取集合中第一个满足该条件的数据行</span></span><br><span class="line">user = User.query.filter_by(email=email).first()</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>先在数据库中查询到对应的数据映射到一个对象中；修改对象的属性；使用db.session完成commit</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">room = Room.query.get(room_id)</span><br><span class="line">room.original_price = <span class="built_in">float</span>(form.original_price.data)</span><br><span class="line">room.price = <span class="built_in">float</span>(form.price.data)</span><br><span class="line">room.num = <span class="built_in">int</span>(form.num.data)</span><br><span class="line">room.room_type = form.room_type.data</span><br><span class="line">now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">room.updated_at = now</span><br><span class="line"><span class="comment"># 数据库更新</span></span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h2 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h2><p>删除需要先查询到该条记录，然后使用会话进行删除</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 删除设施记录  </span></span><br><span class="line">facility = Facility.query.get(<span class="number">1</span>)  </span><br><span class="line">db.session.delete(facility)  </span><br><span class="line">db.session.commit()</span><br></pre></td></tr></table></figure><h1 id="blueprints"><a href="#blueprints" class="headerlink" title="blueprints"></a>blueprints</h1><p>blueprints（蓝图）能够降低app.py中代码的复杂度，同时可以将功能模块进行拆解，便于维护，类似spring中的controller</p><p>只需要在app.py中注册该蓝图，然后在蓝图中编写请求url对应的前缀，路由以及请求方法等即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Blueprint, request, g, redirect, render_template, url_for</span><br><span class="line"><span class="keyword">from</span> models <span class="keyword">import</span> Hotel</span><br><span class="line"><span class="keyword">from</span> ext <span class="keyword">import</span> db</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> .form <span class="keyword">import</span> HotelForm</span><br><span class="line"></span><br><span class="line">bp = Blueprint(<span class="string">&quot;hotels&quot;</span>, __name__, url_prefix=<span class="string">&quot;/hotels&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加酒店</span></span><br><span class="line"><span class="meta">@bp.route(<span class="params"><span class="string">&quot;/addHotel&quot;</span>, methods=[<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>]</span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add_hotel</span>():</span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&quot;GET&quot;</span>:</span><br><span class="line">        <span class="keyword">return</span> render_template(<span class="string">&#x27;add_hotel.html&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        form = HotelForm(request.form)</span><br><span class="line">        <span class="keyword">if</span> form.validate():</span><br><span class="line">            name = form.name.data</span><br><span class="line">            address = form.address.data</span><br><span class="line">            introduction = form.introduction.data</span><br><span class="line">            phone = form.phone.data</span><br><span class="line">            stars = form.stars.data</span><br><span class="line">            brand = form.brand.data</span><br><span class="line">            business_district = form.business_district.data</span><br><span class="line">            now = datetime.now().strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line">            hotel = Hotel(name=name, address=address, introduction=introduction, phone=phone, stars=stars, brand=brand, business_district=business_district, created_at=now, updated_at=now)</span><br><span class="line">            db.session.add(hotel)</span><br><span class="line">            db.session.commit()</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">&#x27;auth.index&#x27;</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(form.errors)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;添加酒店失败，检查填写信息是否正确&quot;</span></span><br></pre></td></tr></table></figure><hr><p>2024.3.13更新</p><h1 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h1><p>Flask通过app.run(threaded&#x3D;True)开启的多线程处理，并不是指同一路由开启多个线程处理，而是不同路由使用多个线程处理</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    app.run(threaded=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>简单来说，threaded为True ，同时访问 &#x2F;t1 和 &#x2F;t2 路由 ，5秒后&#x2F;t1 和 &#x2F;t2 一起返回结果<br>threaded为False ，同时访问 &#x2F;t1 和 &#x2F;t2 路由 ，5秒后&#x2F;t1返回结果，10秒后&#x2F;t2返回结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/t1&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">t1</span>():</span><br><span class="line">   sleep(<span class="number">5</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;Hello World t1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route(<span class="params"><span class="string">&#x27;/t2&#x27;</span></span>)</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">t2</span>():</span><br><span class="line">   sleep(<span class="number">5</span>)</span><br><span class="line">   <span class="keyword">return</span> <span class="string">&#x27;Hello World t2&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>希望有机会还能用到Flask😂😂😂</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud GateWay的基本概念与应用</title>
      <link href="/2023/09/02/0a3d673be179/"/>
      <url>/2023/09/02/0a3d673be179/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud GateWay的基本概念与应用。</p><h1 id="网关功能"><a href="#网关功能" class="headerlink" title="网关功能"></a>网关功能</h1><ol><li>身份认证，权限认证</li><li>服务路由，负载均衡</li><li>请求限流</li></ol><h1 id="搭建网关"><a href="#搭建网关" class="headerlink" title="搭建网关"></a>搭建网关</h1><ol><li>添加依赖，nacos服务发现以及网关的依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--网关依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>编写路由配置以及nacos的地址</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由的id，自定义，唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># 路由的目标地址，lb是负载均衡的意思，后面跟着服务的名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路由断言，请求匹配规则，只要以user开头的就匹配</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着向网关所在端口发送请求信息，如<a href="http://localhost:10010/user/1%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0userService%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BF%94%E5%9B%9E%E3%80%82">http://localhost:10010/user/1，就可以得到userService服务的返回。</a></p><p>服务流程：</p><p><img src="https://s2.loli.net/2023/09/02/oTYa7EjHKGSqIVC.png" alt="image-20230902161302541"></p><h1 id="路由断言工厂"><a href="#路由断言工厂" class="headerlink" title="路由断言工厂"></a>路由断言工厂</h1><p>Spring提供了多种断言工厂，除了Path用来限制路径以外，还可以限制ip，限制时间等</p><p><img src="https://s2.loli.net/2023/09/02/z782hbNTxtBpIZS.png" alt="image-20230902162312852"></p><p>详情实例见SpringCloudGateway文档<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories">路由断言工厂</a></p><h1 id="路由过滤器"><a href="#路由过滤器" class="headerlink" title="路由过滤器"></a>路由过滤器</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>对请求或者响应做加工处理，比如添加请求头</p><h2 id="请求流程"><a href="#请求流程" class="headerlink" title="请求流程"></a>请求流程</h2><p>客户端向网关发起请求，请求经过多层过滤器到达服务端，服务端的响应也会经过过滤器再返回给客户端</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>假如想要给请求头添加一个token</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 路由的id，自定义，唯一即可</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userService</span> <span class="comment"># 路由的目标地址，lb是负载均衡的意思，后面跟着服务的名称</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路由断言，请求匹配规则，只要以user开头的就匹配</span></span><br><span class="line">          <span class="attr">filters:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">AddRequestHeader=token,</span> <span class="string">xxx</span></span><br><span class="line">      <span class="attr">default-filters:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="string">AddRequestHeader=token,</span> <span class="string">xxx</span> <span class="comment"># 默认过滤器，会对所有请求都生效的过滤器</span></span><br></pre></td></tr></table></figure><p>SpringCloud官网提供了31种过滤器，详细可以参考<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories">过滤器工厂</a></p><h2 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h2><p>定义一个类并且实现GlobalFilter接口，并且重写函数filter</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Order(-1)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> exchange 包含请求头，请求体的信息</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> chain 过滤器链，若通过过滤器将其放行至下一个过滤器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> Mono类型的结果，若通过过滤器只需要返回chain.filter(exchange)即可</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">    <span class="comment">//  获取请求</span></span><br><span class="line">    <span class="type">ServerHttpRequest</span> <span class="variable">request</span> <span class="operator">=</span> exchange.getRequest();</span><br><span class="line">    <span class="comment">//  从请求中获取参数</span></span><br><span class="line">    MultiValueMap&lt;String, String&gt; params = request.getQueryParams();</span><br><span class="line">    <span class="comment">//  获取具体参数</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">authorization</span> <span class="operator">=</span> params.getFirst(<span class="string">&quot;authorization&quot;</span>);</span><br><span class="line">    <span class="comment">//  判断身份信息</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="string">&quot;admin&quot;</span>.equals(authorization)) &#123;</span><br><span class="line">      <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  身份验证失败，设置状态码</span></span><br><span class="line">    <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">    <span class="comment">//  参数是HttpStatus类型的，未登录状态码为401</span></span><br><span class="line">    response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response.setComplete();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@Order(-1)注解是过滤器的执行顺序（或者说优先级），值越小优先级越高</p><p>@Component注解将过滤器注册为一个Bean</p><p><strong>总结步骤：</strong></p><ol><li>实现GlobalFilter接口</li><li>添加@Order和@Component注解至类</li><li>编写过滤处理逻辑</li></ol><h2 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h2><p>每个过滤器都有一个order值，根据order值进行排序</p><p>GlobalFilter是由我们自定义order的值的</p><p>路由过滤器与默认过滤器的order值由spring决定，spring默认按照声明顺序从1开始递增</p><p>当order值一样时，会按照默认过滤器&gt;路由过滤器&gt;全局过滤器的顺序执行</p><h1 id="跨域处理"><a href="#跨域处理" class="headerlink" title="跨域处理"></a>跨域处理</h1><p>只需要通过spring的配置就可以对网关的跨域进行处理</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line"><span class="attr">gateway:</span></span><br><span class="line">  <span class="attr">globalcors:</span></span><br><span class="line">    <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截问题</span></span><br><span class="line"><span class="attr">corsConfigurations:</span></span><br><span class="line">  <span class="string">&#x27;[/**]&#x27;</span><span class="string">:</span></span><br><span class="line">    <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求，spring boot2.4以前的配置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">&quot;http://localhost&quot;</span></span><br><span class="line"><span class="comment"># allowedOriginPatterns: &quot;*&quot; # spring boot2.4以后的配置  </span></span><br><span class="line"><span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment">#  是否允许带cookie</span></span><br><span class="line"><span class="attr">allowedMethods:</span> <span class="comment"># 跨域方法设置</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">GET</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">OPTIONS</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">PUT</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">DELETE</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">POST</span></span><br><span class="line"><span class="attr">allowedHeaders:</span> <span class="string">&quot;*&quot;</span> <span class="comment"># 允许携带的请求头信息</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">36000</span> <span class="comment"># 跨域检测的有效期,单位s</span></span><br></pre></td></tr></table></figure><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>接SpringCloud-Feign的题外话，果然有时候无法理解某个知识的时候，不妨继续学下去看看，后继拉动前驱了属于是</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> GateWay </tag>
            
            <tag> 权限认证 </tag>
            
            <tag> 服务路由 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Feign的基本概念与应用</title>
      <link href="/2023/09/02/0fa7d6cefe83/"/>
      <url>/2023/09/02/0fa7d6cefe83/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud Feign的基本概念与应用。</p><h1 id="RestTemplate"><a href="#RestTemplate" class="headerlink" title="RestTemplate"></a>RestTemplate</h1><p>由于微服务架构，无法直接请求其他服务的service，需要远程调用，因此会用到RestTemplate来做远程调用。同时我们使用Ribbon结合RestTemplate来实现使用服务名称代替ip和端口以及负载均衡。Feign则是一种更加优雅的方式，不会需要像RestTemplate一样出现url</p><h1 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h1><p>首先添加依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后主启动类上加上@EnableFeignClients注解，就像@EnableEurekaServer注解一样</p><p>在Service接口上添加@FeignClient注解，并且指定服务的名称（注册到服务注册中心的名称），因此这里就可以实现跨服务调用，只需要实现注册其他服务的名称的接口。使用起来的整体感觉像controller</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;userservice&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserClient</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line">    User <span class="title function_">findById</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Feign配置"><a href="#Feign配置" class="headerlink" title="Feign配置"></a>Feign配置</h1><p><strong>方式一：</strong>通过修改yml文件对feign进行配置</p><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  OrderService</span></span><br><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">FULL</span></span><br></pre></td></tr></table></figure><p><strong>方式二：</strong>通过配置类和注解</p><p>创建一个configuration类，配置Logger.Level这个Bean，加在指定服务的@FeignClient(value &#x3D; “userservice”)注解中，或者加在启动类的@EnableFeignClients( defaultConfiguration &#x3D; xxxconfiguration.class )注解中。</p><h1 id="Feign性能优化"><a href="#Feign性能优化" class="headerlink" title="Feign性能优化"></a>Feign性能优化</h1><p>Feign底层默认使用的URLConnection，不支持连接池，可以通过使用Apache HttpClient来支持连接池（减少连接的创建与释放）</p><h2 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h2><p>添加HttpClient依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置连接池</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 支持HttpClient的开关</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 单个路径的最大连接数</span></span><br></pre></td></tr></table></figure><h1 id="Feign-Api"><a href="#Feign-Api" class="headerlink" title="Feign-Api"></a>Feign-Api</h1><p>controller和FeignClient的重合度较高，可以通过采用定义接口，让二者都去继承这个接口，利用这种方式提供便捷。</p><p>存在的问题：紧耦合</p><p>我更偏向的方法是将FeignClient、POJO、Feign的默认配置封装到一个模块中，通过引入模块来供其他消费者使用。这样做也可以避免每个服务都要去实现一样的FeignClient，创建实体类等。</p><p>存在的问题：有的服务可能仅仅需要部分实体类和功能，有所冗余</p><h2 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h2><p>在其他服务的pom文件中引入该feign-api的依赖，这样就可以引入本模块中未创建的实体类，实现复用</p><p>在使用过程中会出现一个问题：对FeignClient的自动装配，@Autowired只能装配项目所在包目录下的Bean，因此需要在@EnableFeignClients注解上添加clients参数。</p><p>@EnableFeignClients( clients &#x3D; {UserClient.class, OrderClent.class}, defaultConfiguration &#x3D; xxxconfiguration.class ) clients参数可以是数组</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>流程梳理：</p><ol><li>服务模块不需要实现FeignClient来实现跨服务，不需要创建其他的实体</li><li>通过创建feign-api来对服务进行封装，为其他服务的跨服务调用提供接口，同时减少了实体类重复写的情况</li></ol><p>开发流程：</p><p>provider的服务相关内容按照springboot一样照常写，然后在provider-api中提供对服务controller的访问，其他服务需要跨服务调用时通过provider-api来从其它服务的controller中获取</p><h1 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h1><p>昨晚一直在思考前端到底是如何调用有多个实例的后端服务，为此去了解了一下nginx的负载均衡和反向代理。</p><p>我的纠结点在于，我目前学到的springcloud内部的负载均衡都是服务之间的调用，可以通过其他服务的名称向注册中心进行请求，然后再根据返回的服务实例列表负载均衡。那如果这个服务本身我从前端向他发起请求，又应该怎么做才能不访问固定的端口号呢？</p><p>最初想到的方法是将对这台主机的http请求，全部向nacos寻找服务名称的这种方式，当然只是我的猜想。今天查资料，貌似是通过向网关发出请求，再由网关进行路由到具体服务。就我个人而言，从设计的角度感觉非常合理，前端的请求可以通过nginx的负载均衡向不同网关实例发送，网关又可以根据url的路径向具体的服务请求，服务则又被注册到了nacos，若存在多个实例也会在openfeign中实现负载均衡。</p><p>莫名其妙就串联起来了，学完网关再看看</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Feign </tag>
            
            <tag> RestTemplate </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Nacos的基本概念与应用</title>
      <link href="/2023/09/01/0c0d4551479b/"/>
      <url>/2023/09/01/0c0d4551479b/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud Nacos的基本概念与应用。</p><h1 id="Nacos服务注册"><a href="#Nacos服务注册" class="headerlink" title="Nacos服务注册"></a>Nacos服务注册</h1><p>首先父模块的依赖控制处需要添加spring cloud alibaba</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SpringCloudAlibaba有关依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着在服务模块的pom中添加spring-cloud-starter-alibaba-nacos-discovery依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>更改配置，nacos是在springcloud配置中的</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br></pre></td></tr></table></figure><p>注：EnableDiscoveryClient注解现在是可选项了，只要依赖了以spring-cloud-starter-netflix为前缀的库(例如spring-cloud-starter-netflix-eureka-client)，就启用了<strong>服务注册发现</strong>功能；</p><h1 id="服务分层架构"><a href="#服务分层架构" class="headerlink" title="服务分层架构"></a>服务分层架构</h1><p>Nacos的服务按照服务-&gt;集群-&gt;实例来分层，优先调用本地集群内的实例，本地集群中实例不可用再调用其他集群的实例</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span> </span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HangZhou</span> <span class="comment"># 集群名称</span></span><br></pre></td></tr></table></figure><h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><p>如果想要配置优先调用本地集群内的实例，需要修改nacos的配置，例如订单服务想要优先调用本地用户服务的实例，需要使用nacos的负载均衡策略</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 规则类的名称</span></span><br></pre></td></tr></table></figure><p>NacosRule优先选择本地集群，集群内部随机选择；当本地集群健康服务数为0时，选择跨集群访问并警告</p><h1 id="权重配置"><a href="#权重配置" class="headerlink" title="权重配置"></a>权重配置</h1><p>控制台可以修改实例的权重，权重越高，用户请求更多的向该实例迁移。在服务升级中，可以通过将权重比例调为0然后进行升级，之后再调成小权重进行一段时间测试，稳定后恢复权重</p><h1 id="NameSpace"><a href="#NameSpace" class="headerlink" title="NameSpace"></a>NameSpace</h1><p>环境隔离，对相似的服务可以进行分组，如果不同组的服务也无法相互访问。每个namespace有唯一的id，需要在配置文件中修改它的值来设置环境</p><h1 id="Nacos和Eureka的区别"><a href="#Nacos和Eureka的区别" class="headerlink" title="Nacos和Eureka的区别"></a>Nacos和Eureka的区别</h1><h2 id="健康监测"><a href="#健康监测" class="headerlink" title="健康监测"></a>健康监测</h2><p>对于服务提供者的健康状态监测，nacos将服务实例分为临时实例和非临时实例</p><p>临时实例：</p><p>和Eureka一样，使用心跳检测，如果不在服务就会主动剔除（默认情况下如果不配置，实例都是临时的）</p><p>非临时实例：</p><p>非临时实例则会由nacos主动发起询问服务实例的健康状态，并且不会将不健康的服务实例清楚，会等待恢复</p><p>创建非临时实例只需要修改discovery的值</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span></span><br><span class="line">      <span class="attr">discovery:</span> </span><br><span class="line">        <span class="attr">cluster-name:</span> <span class="string">HangZhou</span> <span class="comment"># 集群名称</span></span><br><span class="line">        <span class="attr">ephemeral:</span> <span class="literal">false</span> <span class="comment"># 是否为临时实例</span></span><br></pre></td></tr></table></figure><h2 id="服务列表"><a href="#服务列表" class="headerlink" title="服务列表"></a>服务列表</h2><p>Eureka和Nacos都会定时拉取服务列表加到缓存中，提高效率。但是Nacos还采取了消息推送的形式，当服务发生变更，会主动推送消息给消费者</p><h1 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h1><h2 id="配置设置"><a href="#配置设置" class="headerlink" title="配置设置"></a>配置设置</h2><p>命名规则是 服务名-运行环境.yaml如userservice-dev.yaml</p><p>配置内容只设置有热更新需求的配置项，例如日期格式等；像数据库地址这种可以不放上去</p><h2 id="配置拉取"><a href="#配置拉取" class="headerlink" title="配置拉取"></a>配置拉取</h2><p>配置读取步骤：</p><p><img src="https://s2.loli.net/2023/09/01/iCF7szOZ6HVGjlS.png" alt="image-20230901202139446.png"></p><p>bootstap.yml配置的优先级较高，可以读取到nacos的地址，再读取nacos的配置文件，最后读取application.yml的配置文件</p><p>首先在<strong>微服务</strong>引入nacos-config依赖</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--nacos config依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接着创建bootstrap.yml文件，引导配置文件，优先级高于application.yml</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">user-service</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 开发环境</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># nacos地址</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 文件后缀名</span></span><br></pre></td></tr></table></figure><p>三者结合发现就是在控制台创建的配置id即userservice-dev.yaml</p><p>同时，之前的application.yml中的重复配置可以删除了，如服务名称和nacos地址</p><p>注：nacos配置管理是按服务分的，因此写在<strong>微服务</strong>模块中</p><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><p>前置知识：</p><p>使用@Value(“${pattern.dateformat}”)注解可以获取配置项（改成NacosValue）</p><p>@ConfigurationProperties(prefix &#x3D; “xxx”) 约定大于配置，只要prefix前缀xxx与变量名进行拼接与配置一致，就可以注入</p><p>方法一：在Value注解所在类上加一个注解@RefreshScope，可以实现配置热更新，无需重启服务</p><p>方法二：使用@ConfigurationProperties(prefix &#x3D; “xxx”)注解</p><h1 id="小插曲"><a href="#小插曲" class="headerlink" title="小插曲"></a>小插曲</h1><p>浪费了近一个小时时间在处理依赖和配置的问题上。这里属于是对dependencymanagement不熟悉了。</p><p>使用dependencyManagement可以统一管理项目的版本号，确保应用的各个项目的依赖和版本一致，不用每个模块项目都弄一个版本号，不利于管理，当需要变更版本号的时候只需要在父类容器里更新，不需要任何一个子项目的修改；如果某个子项目需要另外一个特殊的版本号时，只需要在自己的模块dependencies中声明一个版本号即可。子类就会使用子类声明的版本号，不继承于父类版本号。</p><p>误解：以为在父模块中定义dependencyManagement之后，子模块就可以继承下来，但是在maven中发现子模块中并没有继承下来依赖。实际上是子模块中依然需要添加相关依赖但是不用加版本号。</p><p>解决方法：想要实现我的需求只需要将父模块的依赖标签dependencyManagement删除，仅使用dependencies即可</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">&lt;!--nacos --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--mysql --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--web起步依赖--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Nacos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Ribbon的基本概念与应用</title>
      <link href="/2023/08/30/4064d644d905/"/>
      <url>/2023/08/30/4064d644d905/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud Ribbon的基本概念与应用。</p><h1 id="Ribbon负载均衡流程"><a href="#Ribbon负载均衡流程" class="headerlink" title="Ribbon负载均衡流程"></a>Ribbon负载均衡流程</h1><p>像这样的url：<a href="http://userservice/user/1">http://userservice/user/1</a> 是没有办法通过http访问的，因为实际上不存在这么一个网站，因此Ribbon起到一个请求拦截处理的作用</p><ol><li><p>收到请求后，向Eureka拉取服务</p></li><li><p>返回服务列表，进行负载均衡，轮询获取具体服务端口</p></li></ol><p>具体操作需要在xxx-service模块中的xxxServiceApplication中将RestTemplate注入spring容器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="keyword">public</span> RestTemplate <span class="title function_">restTemplate</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Ribbon底层"><a href="#Ribbon底层" class="headerlink" title="Ribbon底层"></a>Ribbon底层</h1><ol><li>LoadBalancerInterceptor拦截http请求，将请求解析得到服务名称</li><li>将服务名称交给RibbonLoadBalancerClient</li><li>RibbonLoadBalancerClient通过DynamicServerListLoadBalancer向eureka拉取服务列表</li><li>DynamicServerListLoadBalancer通过负载均衡策略IRule从服务列表中进行选择，提交给RibbonLoadBalancerClient</li><li>RibbonLoadBalancerClient对url进行修改，发起请求</li></ol><h1 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h1><p><img src="https://s2.loli.net/2023/08/30/Vc82tw4vB5gkmPi.png" alt="image-20230830184232870.png"></p><h2 id="修改策略"><a href="#修改策略" class="headerlink" title="修改策略"></a>修改策略</h2><ol><li>通过在相关服务中将IRule注入spring容器实现对负载均衡策略的修改，例如xxx-service模块中的xxxServiceApplication中（本身也算是配置类）</li></ol><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> IRule <span class="title function_">randomRule</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RandomRule</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>配置文件的方式，在xxx-service模块中的yml配置中添加</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.magus.config.RandomRule</span> <span class="comment"># 规则类的名称</span></span><br></pre></td></tr></table></figure><h1 id="饥饿加载"><a href="#饥饿加载" class="headerlink" title="饥饿加载"></a>饥饿加载</h1><p>Ribbon默认是懒加载，第一次访问才会创建LoadBalancerClient，请求时间较长。使用饥饿加载可以在服务启动时就创建，减少请求时间</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line">  <span class="attr">eager-load:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="string">userservice</span> <span class="comment"># 单个服务</span></span><br><span class="line">    <span class="attr">clients:</span> <span class="comment"># 多个服务</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">userservice</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">orderservice</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> 微服务 </tag>
            
            <tag> Ribbon </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringCloud Eureka的基本概念与应用</title>
      <link href="/2023/08/30/813ced141348/"/>
      <url>/2023/08/30/813ced141348/</url>
      
        <content type="html"><![CDATA[<p>本文介绍了一些关于SpringCloud Eureka的基本概念与应用。</p><h1 id="Eureka角色"><a href="#Eureka角色" class="headerlink" title="Eureka角色"></a>Eureka角色</h1><p>服务端：EurekaServer，服务端，注册中心。负责心跳监控，记录服务信息</p><p>客户端：EurekaClient，分为消费者和提供者。</p><h1 id="Eureka的作用"><a href="#Eureka的作用" class="headerlink" title="Eureka的作用"></a>Eureka的作用</h1><p>eureka服务类似注册中心：</p><ol><li>服务消费者和提供者将服务信息注册到注册中心</li><li>消费者向注册中心拉取提供者的新消息</li><li>通过负载均衡进行选择</li><li>实现远程调用</li></ol><p>注册中心使用心跳续约，随时监控服务状态</p><h1 id="Eureka搭建"><a href="#Eureka搭建" class="headerlink" title="Eureka搭建"></a>Eureka搭建</h1><p>搭建服务步骤如下：</p><ol><li>创建模块，引入spring-cloud-starter-netflix-eureka-server依赖</li></ol><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka服务端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果父工程中已经选好了springcloud的版本以及相关依赖，这里不需要填写版本号</p><ol start="2"><li>编写启动类，并添加@EnableEurekaServer注解</li><li>编写yml配置文件，服务端口、服务名称、地址信息（用于eureka集群通信）</li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tomcat</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">9099</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Spring</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="comment"># 应用名称</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">hms_eureka</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">sevice-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:$&#123;server.port&#125;/eureka</span></span><br><span class="line">    <span class="comment"># 这里选择不将自己注册 </span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="服务注册"><a href="#服务注册" class="headerlink" title="服务注册"></a>服务注册</h1><p>在依赖中引入</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时在application.yml中配置eureka相关信息</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:9099/eureka</span></span><br></pre></td></tr></table></figure><p>注：启动类上要加上@EnableEurekaServer注解</p><p>一直遇到一个问题，日志内容如下：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">2023-08-30 16:57:34.306  INFO 1076 --- [           main] com.magus.UserServiceApplication         : No active profile <span class="built_in">set</span>, falling back to default profiles: default</span><br><span class="line">2023-08-30 16:57:34.580  INFO 1076 --- [           main] o.s.cloud.context.scope.GenericScope     : BeanFactory <span class="built_in">id</span>=24ae86d6-4a71-3421-838c-868a60323ef7</span><br><span class="line">2023-08-30 16:57:34.621  INFO 1076 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">&#x27;org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration&#x27;</span> of <span class="built_in">type</span> [org.springframework.transaction.annotation.ProxyTransactionManagementConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$9adaa148</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2023-08-30 16:57:34.632  INFO 1076 --- [           main] trationDelegate<span class="variable">$BeanPostProcessorChecker</span> : Bean <span class="string">&#x27;org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration&#x27;</span> of <span class="built_in">type</span> [org.springframework.cloud.autoconfigure.ConfigurationPropertiesRebinderAutoConfiguration$$EnhancerBySpringCGLIB$<span class="variable">$b6f4a445</span>] is not eligible <span class="keyword">for</span> getting processed by all BeanPostProcessors (<span class="keyword">for</span> example: not eligible <span class="keyword">for</span> auto-proxying)</span><br><span class="line">2023-08-30 16:57:34.644  WARN 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span><br><span class="line">2023-08-30 16:57:34.644  INFO 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : To <span class="built_in">enable</span> URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span><br><span class="line">2023-08-30 16:57:34.649  WARN 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : No URLs will be polled as dynamic configuration sources.</span><br><span class="line">2023-08-30 16:57:34.649  INFO 1076 --- [           main] c.n.c.sources.URLConfigurationSource     : To <span class="built_in">enable</span> URLs as dynamic configuration sources, define System property archaius.configurationSource.additionalUrls or make config.properties available on classpath.</span><br><span class="line">2023-08-30 16:57:36.516  INFO 1076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine <span class="built_in">local</span> hostname</span><br><span class="line">2023-08-30 16:57:38.145  INFO 1076 --- [           main] o.s.cloud.commons.util.InetUtils         : Cannot determine <span class="built_in">local</span> hostname</span><br><span class="line">2023-08-30 16:57:38.203  INFO 1076 --- [           main] o.s.c.n.eureka.InstanceInfoFactory       : Setting initial instance status as: STARTING</span><br><span class="line">2023-08-30 16:57:38.224  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Initializing Eureka <span class="keyword">in</span> region us-east-1</span><br><span class="line">2023-08-30 16:57:38.855  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON encoding codec LegacyJacksonJson</span><br><span class="line">2023-08-30 16:57:38.855  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using JSON decoding codec LegacyJacksonJson</span><br><span class="line">2023-08-30 16:57:38.928  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML encoding codec XStreamXml</span><br><span class="line">2023-08-30 16:57:38.929  INFO 1076 --- [           main] c.n.d.provider.DiscoveryJerseyProvider   : Using XML decoding codec XStreamXml</span><br><span class="line">2023-08-30 16:57:39.042  INFO 1076 --- [           main] c.n.d.s.r.aws.ConfigClusterResolver      : Resolving eureka endpoints via configuration</span><br><span class="line">2023-08-30 16:57:39.460  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Disable delta property : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Single vip registry refresh property : null</span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Force full registry fetch : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application is null : <span class="literal">false</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Registered Applications size is zero : <span class="literal">true</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Application version is -1: <span class="literal">true</span></span><br><span class="line">2023-08-30 16:57:39.461  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Getting all instance registry info from the eureka server</span><br><span class="line">2023-08-30 16:57:39.535  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : The response status is 200</span><br><span class="line">2023-08-30 16:57:39.536  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Starting heartbeat executor: renew interval is: 30</span><br><span class="line">2023-08-30 16:57:39.538  INFO 1076 --- [           main] c.n.discovery.InstanceInfoReplicator     : InstanceInfoReplicator onDemand update allowed rate per min is 4</span><br><span class="line">2023-08-30 16:57:39.541  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Discovery Client initialized at timestamp 1693385859540 with initial instances count: 0</span><br><span class="line">2023-08-30 16:57:39.542  INFO 1076 --- [           main] o.s.c.n.e.s.EurekaServiceRegistry        : Registering application USER-SERVICE with eureka with status UP</span><br><span class="line">2023-08-30 16:57:39.543  INFO 1076 --- [           main] com.netflix.discovery.DiscoveryClient    : Saw <span class="built_in">local</span> status change event StatusChangeEvent [timestamp=1693385859543, current=UP, previous=STARTING]</span><br><span class="line">2023-08-30 16:57:39.544  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999: registering service...</span><br><span class="line">2023-08-30 16:57:39.554  INFO 1076 --- [           main] com.magus.UserServiceApplication         : Started UserServiceApplication <span class="keyword">in</span> 9.058 seconds (JVM running <span class="keyword">for</span> 10.165)</span><br><span class="line">2023-08-30 16:57:39.556  INFO 1076 --- [       Thread-5] o.s.c.n.e.s.EurekaServiceRegistry        : Unregistering application USER-SERVICE with eureka with status DOWN</span><br><span class="line">2023-08-30 16:57:39.557  WARN 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Saw <span class="built_in">local</span> status change event StatusChangeEvent [timestamp=1693385859557, current=DOWN, previous=UP]</span><br><span class="line">2023-08-30 16:57:39.561  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Shutting down DiscoveryClient ...</span><br><span class="line">2023-08-30 16:57:39.602  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - registration status: 204</span><br><span class="line">2023-08-30 16:57:39.603  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999: registering service...</span><br><span class="line">2023-08-30 16:57:39.614  INFO 1076 --- [nfoReplicator-0] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - registration status: 204</span><br><span class="line">2023-08-30 16:57:39.615  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Unregistering ...</span><br><span class="line">2023-08-30 16:57:39.630  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : DiscoveryClient_USER-SERVICE/localhost:user-service:9999 - deregister  status: 200</span><br><span class="line">2023-08-30 16:57:39.637  INFO 1076 --- [       Thread-5] com.netflix.discovery.DiscoveryClient    : Completed shut down of DiscoveryClient</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> Eureka客户端（服务提供者&#x2F;消费者）没有成功引入web的starter（头疼了半小时）。</p><h2 id="注册多个实例"><a href="#注册多个实例" class="headerlink" title="注册多个实例"></a>注册多个实例</h2><p>可以对服务的配置进行复制然后在VM设置中添加参数-Dserver.port&#x3D;xxxx</p><h1 id="服务拉取"><a href="#服务拉取" class="headerlink" title="服务拉取"></a>服务拉取</h1><ol><li>同注册，引入依赖，配置eureka地址。</li><li>给ResTemplate添加@LoadBanlanced注解（负载均衡）</li><li>用服务提供者的注册服务名称代替url中的一部分进行远程调用，例如 <a href="http://userservice/user/1">http://userservice/user/1</a> (restful)</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Eureka起到为服务之间提供远程调用的作用，来实现将服务分离又能交互</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> SpringCloud </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringCloud </tag>
            
            <tag> Eureka </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>My First Blog</title>
      <link href="/2023/08/29/3ed187a62f30/"/>
      <url>/2023/08/29/3ed187a62f30/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h1><p>2023年8月29日正式搭建属于我的博客，希望有一天我也能写出像hexo一样能被万人使用的project</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
